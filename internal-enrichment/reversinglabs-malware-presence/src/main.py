import os
import textwrap
from datetime import datetime
from typing import Dict

import stix2
from lib.internal_enrichment import InternalEnrichmentConnector
from pycti import (
    STIX_EXT_OCTI_SCO,
    Identity,
    Indicator,
    Malware,
    Note,
    OpenCTIConnectorHelper,
    StixCoreRelationship,
)
from ReversingLabs.SDK.ticloud import (
    DomainThreatIntelligence,
    FileAnalysis,
    FileReputation,
    IPThreatIntelligence,
    NetworkReputation,
    URLThreatIntelligence,
)


class ReversingLabsConnector(InternalEnrichmentConnector):
    def __init__(self):
        super().__init__()
        self._get_config_variables()
        # Reversinglabs identity
        self.reversinglabs_identity = self.helper.api.identity.create(
            type="Organization",
            name="ReversingLabs",
            description="www.reversinglabs.com",
        )
        # Set create indicators flag (true/false)
        self.create_indicators = self.reversinglabs_create_indicators

    def _get_config_variables(self):
        self.connector_name = os.environ.get("CONNECTOR_NAME", None)
        self.opencti_url = os.environ.get("OPENCTI_URL", None)
        self.opencti_token = os.environ.get("OPENCTI_TOKEN", None)
        self.reversinglabs_titaniumcloud_url = os.environ.get(
            "REVERSINGLABS_TITANIUMCLOUD_URL", None
        )
        self.reversinglabs_titaniumcloud_username = os.environ.get(
            "REVERSINGLABS_TITANIUMCLOUD_USERNAME", None
        )
        self.reversinglabs_titaniumcloud_password = os.environ.get(
            "REVERSINGLABS_TITANIUMCLOUD_PASSWORD", None
        )
        self.reversinglabs_titaniumcloud_max_tlp = os.environ.get(
            "REVERSINGLABS_MAX_TLP", None
        )
        self.reversinglabs_create_indicators = os.environ.get(
            "REVERSINGLABS_CREATE_INDICATORS"
        )
        self.reversinglabs_titaniumcloud_user_agent = "ReversingLabs OpenCTI v1.0.0"

    """
    Extract TLP and check if max_tlp is less than or equal to the marking access
    of the entity. If true we can send data for enrichment.
    """

    def _check_tlp_markings(self, entity):
        tlp = "TLP:CLEAR"
        for marking_definition in entity["objectMarking"]:
            if marking_definition["definition_type"] == "TLP":
                tlp = marking_definition["definition"]

            if not OpenCTIConnectorHelper.check_max_tlp(
                tlp, self.reversinglabs_titaniumcloud_max_tlp
            ):
                raise ValueError(
                    "Do not send any data, TLP of the observable is greater than MAX TLP"
                )
        return tlp

    def _generate_stix_relationship(
        self, source_ref, stix_core_relationship_type, target_ref
    ):
        return stix2.Relationship(
            id=StixCoreRelationship.generate_id(
                stix_core_relationship_type, source_ref, target_ref
            ),
            relationship_type=stix_core_relationship_type,
            source_ref=source_ref,
            target_ref=target_ref,
            created_by_ref=self.reversinglabs_identity["standard_id"],
            object_marking_refs=[stix2.TLP_AMBER],
        )

    def _generate_stix_identity(self):
        organization = "ReversingLabs"

        stix_organization = stix2.Identity(
            id=Identity.generate_id(organization, "Organization"),
            name=organization,
            identity_class="organization",
            created_by_ref=self.reversinglabs_identity["standard_id"],
        )
        self.stix_objects.append(stix_organization)

    def _generate_stix_malware(self, malware_family, malware_type):
        stix_malware_with_relationship = []
        now = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")

        # Create Malware
        stix_malware = stix2.Malware(
            id=Malware.generate_id(malware_family),
            created=now,
            name=malware_family,
            malware_types=[f"{malware_type}"],
            description="ReversingLabs",
            is_family="false",
            created_by_ref=self.reversinglabs_identity["standard_id"],
        )
        self.stix_objects.append(stix_malware)
        stix_malware_with_relationship.append(stix_malware)

        # Generate Relationship : observable -> "related-to" -> Malware
        observable_to_malware = self._generate_stix_relationship(
            self.stix_entity["id"], "related-to", stix_malware.id
        )
        self.stix_objects.append(observable_to_malware)
        stix_malware_with_relationship.append(observable_to_malware)
        return stix_malware_with_relationship

    def _generate_stix_indicator(
        self, data, indicator_name, indicator_pattern, main_observable_type
    ):
        stix_indicator_with_relationship = []
        now = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")
        rl_threat_platform = data["rl_threat_platform"]

        # Create indicator
        stix_indicator = stix2.Indicator(
            id=Indicator.generate_id(indicator_name),
            name=indicator_name,
            description=data["description"],
            labels=data["labels"],
            pattern=indicator_pattern,
            created_by_ref=self.reversinglabs_identity["standard_id"],
            valid_from=now,
            object_marking_refs=[stix2.TLP_AMBER],
            custom_properties={
                "pattern_type": "stix",
                "x_opencti_score": data["score"],
                "x_opencti_main_observable_type": main_observable_type,
                "x_mitre_platforms": f"{rl_threat_platform}",
                "detection": True,
            },
        )
        self.stix_objects.append(stix_indicator)
        stix_indicator_with_relationship.append(stix_indicator)

        # Generate Relationship Indicator -> Based on -> Observable
        indicator_to_observable = self._generate_stix_relationship(
            stix_indicator.id, "based-on", self.stix_entity["id"]
        )

        self.stix_objects.append(indicator_to_observable)
        stix_indicator_with_relationship.append(indicator_to_observable)
        return stix_indicator_with_relationship

    def _generate_stix_note(self, data):
        now = datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ")
        hash = data["rl"]["malware_presence"]["query_hash"]
        status = data["rl"]["malware_presence"]["status"]
        scanner_count = data["rl"]["malware_presence"]["scanner_count"]
        scanner_match = data["rl"]["malware_presence"]["scanner_match"]
        scanner_percent = data["rl"]["malware_presence"]["scanner_percent"]

        abstract = "ReversingLabs Spectra Intelligence Results"
        content = textwrap.dedent(
            f"""
        ## ReversingLabs Spectra Intelligence Results
        Detected hash {hash} is **{status}**
        | Scanner       |                 |
        | ------------- | --------------- |
        | Count         | {scanner_count} |
        | Match         | {scanner_match} |
        | (%)           | {scanner_percent} |
        """
        )

        # Create Note
        stix_note = stix2.Note(
            id=Note.generate_id(now, content),
            abstract=abstract,
            content=content,
            created_by_ref=self.reversinglabs_identity["standard_id"],
            object_refs=[self.stix_entity["id"]],
            object_marking_refs=[stix2.TLP_AMBER],
            custom_properties={"note_types": ["external"]},
        )
        self.stix_objects.append(stix_note)

    def _generate_score(self, score):
        self.helper.api.stix2.put_attribute_in_extension(
            self.stix_entity, STIX_EXT_OCTI_SCO, "x_opencti_score", score, True
        )
        return score

    def _upsert_stix_file_observable(self, data):
        custom_props = {"x_opencti_score": data["score"]}
        if data["upsert_description"]:
            custom_props["x_opencti_description"] = data["description"]
        stix_observable = stix2.File(
            id=self.stix_entity["id"],
            type="file",
            hashes=self.stix_entity["hashes"],
            size=data["sample_size"],
            custom_properties=custom_props,
        )

        self.stix_objects.append(stix_observable)
        return stix_observable

    def _upsert_stix_network_observable(self, data):
        kwargs = {
            "id": self.stix_entity["id"],
            "type": data["network_type"],
            "value": self.stix_entity["value"],
            "custom_properties": {
                "x_opencti_description": data["description"],
                "x_opencti_score": data["score"],
                "x_opencti_type": data["network_type"],
            },
        }
        constructors = {
            "url": stix2.URL,
            "domain-name": stix2.DomainName,
            "ipv4-addr": stix2.IPv4Address,
            "ipv6-addr": stix2.IPv6Address,
        }
        data_type = data.get("network_type")
        if data_type in constructors.keys():
            stix_observable = constructors[data_type](**kwargs)
            self.stix_objects.append(stix_observable)
            return stix_observable

    def _generate_stix_bundle(self, stix_objects, stix_entity):
        self.stix_objects = stix_objects
        self.stix_entity = stix_entity

        uniq_bundles_objects = list(
            {obj["id"]: obj for obj in self.stix_objects}.values()
        )
        self.helper.log_info(
            f"{self.helper.connect_name} Number of Stix bundles to be enriched: {len(uniq_bundles_objects)}"
        )
        return self.helper.stix2_create_bundle(uniq_bundles_objects)

    # TCA-0101
    def _file_reputation(self, hash):
        file_reputation = FileReputation(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = file_reputation.get_file_reputation(hash)
        rl_response = response.json()
        return rl_response

    # TCA-0104
    def _file_analysis(self, hash):
        file_analysis = FileAnalysis(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = file_analysis.get_analysis_results(hash)
        rl_response = response.json()
        return rl_response

    # TCA-0407
    def _network_reputation(self, network_location):
        network_reputation = NetworkReputation(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = network_reputation.get_network_reputation(self.network_location)
        rl_response = response.json()
        return rl_response

    # TCA-0403
    def _url_threat_intelligence(self, url):
        url_reputation = URLThreatIntelligence(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = url_reputation.get_url_report(url)
        rl_response = response.json()
        return rl_response

    # TCA-0405
    def _domain_threat_intelligence(self, domain):
        domain_reputation = DomainThreatIntelligence(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = domain_reputation.get_domain_report(domain)
        rl_response = response.json()
        return rl_response

    # TCA-0406
    def _ip_threat_intelligence(self, ip):
        ip_reputation = IPThreatIntelligence(
            host=self.reversinglabs_titaniumcloud_url,
            username=self.reversinglabs_titaniumcloud_username,
            password=self.reversinglabs_titaniumcloud_password,
            user_agent=self.reversinglabs_titaniumcloud_user_agent,
        )
        response = ip_reputation.get_ip_report(ip)
        rl_response = response.json()
        return rl_response

    def _check_network_reputation(
        self, stix_objects, stix_entity, opencti_entity, network_location, network_type
    ):
        self.stix_objects = stix_objects
        self.stix_entity = stix_entity
        self.network_location = [network_location]

        network_result = {}
        network_result["network_type"] = network_type

        network_result["upsert_allowed"] = True
        if self.stix_entity["type"] == "file":
            network_result["upsert_allowed"] = False

        self.helper.log_info(
            f"{self.helper.connect_name} Upsert observable: {str(network_result)}"
        )

        # API call to TCA-0407
        network_reputation_report = self._network_reputation(self.network_location)

        entries = network_reputation_report["rl"]["entries"]
        for ent in entries:
            network_result["rl_network_type"] = ent["type"]
            network_result["associated_malware"] = ent["associated_malware"]
            network_result["malicious"] = ent["third_party_reputations"]["malicious"]
            try:
                network_result["classification"] = ent["classification"]
            except:
                network_result["classification"] = ""

        self.helper.log_info(
            f"{self.helper.connect_name} Network result: {str(network_result)}"
        )

        if (
            network_result["classification"] == "malicious"
            or network_result["associated_malware"] == True
            or network_result["malicious"] > 0
        ):
            self.helper.log_info(
                f"{self.helper.connect_name} Executing additional check on Threat Intelligence"
            )
            match network_result["rl_network_type"]:
                case "url":
                    main_observable_type = "Url"
                    for url in self.network_location:
                        network_report = self._url_threat_intelligence(url)
                        network_result["requested_location"] = network_report["rl"][
                            "requested_url"
                        ]

                        try:
                            top_threats = network_report["rl"]["analysis"][
                                "top_threats"
                            ]
                            network_report["threat_level"] = 0
                            network_result["labels"] = []
                            if top_threats.size != 0:
                                for threat in top_threats:
                                    threat_level = threat["threat_level"]
                                    if threat_level >= network_report["threat_level"]:
                                        network_result["threat_level"] = threat_level
                                    rl_threat_name = threat["threat_name"].split(".")
                                    network_result["malware_family"] = rl_threat_name[2]
                                    network_result["malware_type"] = rl_threat_name[1]
                                    network_result["rl_threat_platform"] = (
                                        rl_threat_name[0]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_family"]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_type"]
                                    )
                                score = (network_result["threat_level"] * 10) + 50
                                network_result["score"] = self._generate_score(score)
                            else:
                                network_result["rl_threat_platform"] = ""
                                network_location["threat_level"] = 0
                                score = (network_result["threat_level"] * 10) + 50
                                network_result["score"] = self._generate_score(score)
                        except:
                            score = 50
                            network_result["score"] = self._generate_score(score)
                            network_result["malware_family"] = ""
                            network_result["malware_type"] = ""
                            network_result["rl_threat_platform"] = ""
                            network_result["labels"] = ""
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )

                        if (
                            network_result["score"] > 50
                            or network_result["malicious"] > 0
                        ):
                            network_result["description"] = (
                                "For provided network location we observed malicious activity"
                            )
                        else:
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )

                case "ip":
                    main_observable_type = "IPv4-Addr"
                    for ip in self.network_location:
                        network_report = self._ip_threat_intelligence(ip)
                        network_result["requested_location"] = network_report["rl"][
                            "requested_ip"
                        ]

                        try:
                            top_threats = network_report["rl"]["top_threats"]
                            network_result["threat_level"] = 0
                            network_result["labels"] = []
                            if top_threats.size != 0:
                                for threat in top_threats:
                                    threat_level = threat["threat_level"]
                                    if threat_level >= network_result["threat_level"]:
                                        network_result["threat_level"] = threat_level
                                    rl_threat_name = threat["threat_name"].split(".")
                                    network_result["malware_family"] = rl_threat_name[2]
                                    network_result["malware_type"] = rl_threat_name[1]
                                    network_result["rl_threat_platform"] = (
                                        rl_threat_name[0]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_family"]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_type"]
                                    )
                                score = (network_result["threat_level"] * 10) + 50
                                network_result["score"] = self._generate_score(score)
                            else:
                                network_result["rl_threat_platform"] = ""
                                network_location["threat_level"] = 0
                                score = (network_result["threat_level"] * 10) + 50
                                network_result["score"] = self._generate_score(score)
                        except:
                            score = 50
                            network_result["score"] = self._generate_score(score)
                            network_result["malware_family"] = ""
                            network_result["malware_type"] = ""
                            network_result["rl_threat_platform"] = ""
                            network_result["labels"] = ""
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )

                        if (
                            network_result["score"] > 50
                            or network_result["malicious"] > 0
                        ):
                            network_result["description"] = (
                                "For provided network location we observed malicious activity"
                            )
                        else:
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )

                case "domain":
                    main_observable_type = "Domain-Name"
                    for domain in self.network_location:
                        network_report = self._domain_threat_intelligence(domain)
                        network_result["requested_location"] = network_report["rl"][
                            "requested_domain"
                        ]

                        try:
                            top_threats = network_report["rl"]["top_threats"]
                            network_result["threat_level"] = 0
                            network_result["labels"] = []
                            if top_threats.size != 0:
                                for threat in top_threats:
                                    threat_level = threat["threat_level"]
                                    if threat_level >= network_result["threat_level"]:
                                        network_result["threat_level"] = threat_level
                                    rl_threat_name = threat["threat_name"].split(".")
                                    network_result["malware_family"] = rl_threat_name[2]
                                    network_result["malware_type"] = rl_threat_name[1]
                                    network_result["rl_threat_platform"] = (
                                        rl_threat_name[0]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_family"]
                                    )
                                    network_result["labels"].append(
                                        network_result["malware_type"]
                                    )
                                    score = (network_result["threat_level"] * 10) + 50
                                    network_result["score"] = self._generate_score(
                                        score
                                    )
                            else:
                                network_result["rl_threat_platform"] = ""
                                network_location["threat_level"] = 0
                                score = (network_result["threat_level"] * 10) + 50
                                network_result["score"] = self._generate_score(score)
                        except:
                            score = 50
                            network_result["score"] = self._generate_score(score)
                            network_result["malware_family"] = ""
                            network_result["malware_type"] = ""
                            network_result["rl_threat_platform"] = ""
                            network_result["labels"] = ""
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )

                        if (
                            network_result["score"] > 50
                            or network_result["malicious"] > 0
                        ):
                            network_result["description"] = (
                                "For provided network location we observed malicious activity"
                            )
                        else:
                            network_result["description"] = (
                                "There is no information about malicious activity on given network location!"
                            )
                case _:
                    return

            if network_result["score"] > 50 or network_result["malicious"] > 0:
                # Generate Identity (Organization)
                self._generate_stix_identity()

                net_type = network_result["network_type"]
                req_loc = network_result["requested_location"]
                indicator_pattern = f"[{net_type}:value = '{req_loc}']"
                indicator_name = network_result["requested_location"]
                self._generate_stix_indicator(
                    network_result,
                    indicator_name,
                    indicator_pattern,
                    main_observable_type,
                )

                self.helper.log_info(
                    f"{self.helper.connect_name}: Generated indicator from observable {str(indicator_name)} with relationships"
                )

                self.helper.log_info(
                    f"{self.helper.connect_name}: Create malware and relationships on malicious observable"
                )

                # Create Malware and relationships
                if (
                    network_result["malware_family"] != ""
                    and network_result["malware_type"] != ""
                ):
                    self._generate_stix_malware(
                        network_result["malware_family"], network_result["malware_type"]
                    )

                    # Create labels
                    for label in network_result["labels"]:
                        self.helper.api.stix_cyber_observable.add_label(
                            id=self.stix_entity["id"], label_name=label
                        )
        else:
            score = 50
            network_result["score"] = self._generate_score(score)
            network_result["description"] = (
                "There is no information about malicious activity on given network location!"
            )

        if network_result["upsert_allowed"] == True:
            self._upsert_stix_network_observable(network_result)

        self.helper.log_info(
            f"{self.helper.connect_name}: Finished with _check_network_reputation"
        )

    def _check_file_reputation(
        self, stix_objects, stix_entity, opencti_entity, hash, hash_type
    ):
        self.stix_objects = stix_objects
        self.stix_entity = stix_entity
        self.hash = hash
        self.hash_type = hash_type
        hashes = {hash_type: hash}

        self.helper.log_info(
            f"{self.helper.connect_name}: Fetching reputation data for hash {str(self.hash)} from ReversingLabs"
        )

        # API call to TCA-0101
        file_reputation_report = self._file_reputation(self.hash)
        results = {}

        results["upsert_description"] = True
        if hashes != self.stix_entity["hashes"]:
            results["upsert_description"] = False

        match file_reputation_report["rl"]["malware_presence"]["status"]:
            case "UNKNOWN":
                results["description"] = (
                    "Malware presence is UNKNOWN (no threats found)"
                )
                results["score"] = 50
                results["sample_size"] = 0
                results["rl_threat_platform"] = ""
                self._upsert_stix_file_observable(results)

            case "KNOWN":
                results["trust_factor"] = file_reputation_report["rl"][
                    "malware_presence"
                ]["trust_factor"]
                try:
                    results["threat_level"] = file_reputation_report["rl"][
                        "malware_presence"
                    ]["threat_level"]
                except:
                    results["threat_level"] = 0
                score = (results["trust_factor"] + results["threat_level"]) * 10
                results["score"] = self._generate_score(score)
                results["description"] = (
                    "Provided hash is classified as GOODWARE by ReversingLabs"
                )
                results["rl_threat_platform"] = ""
                results["sample_size"] = 0
                self._upsert_stix_file_observable(results)

            case "SUSPICIOUS" | "MALICIOUS":
                results["trust_factor"] = file_reputation_report["rl"][
                    "malware_presence"
                ]["trust_factor"]
                results["labels"] = []
                try:
                    results["threat_level"] = file_reputation_report["rl"][
                        "malware_presence"
                    ]["threat_level"]
                except:
                    results["threat_level"] = 0
                score = (results["trust_factor"] + results["threat_level"]) * 10
                results["score"] = self._generate_score(score)
                results["rl_threat_platform"] = file_reputation_report["rl"][
                    "malware_presence"
                ]["classification"]["platform"]
                results["malware_family"] = file_reputation_report["rl"][
                    "malware_presence"
                ]["classification"]["family_name"]
                results["malware_type"] = file_reputation_report["rl"][
                    "malware_presence"
                ]["classification"]["type"]
                results["labels"].append(results["malware_family"])
                results["labels"].append(results["malware_type"])

                self.helper.log_info(
                    f"{self.helper.connect_name}: Adding labels to the observable"
                )

                for label in results["labels"]:
                    self.helper.api.stix_cyber_observable.add_label(
                        id=self.stix_entity["id"], label_name=label
                    )

                # Generate data from TCA-0104
                file_analysis_report = self._file_analysis(self.hash)
                results["sample_size"] = file_analysis_report["rl"]["sample"][
                    "sample_size"
                ]
                results["description"] = file_analysis_report["rl"]["sample"]["xref"][
                    "sample_type"
                ]

                # Generate Identity (Organization)
                self._generate_stix_identity()

                if results["score"] > 50:
                    # Generate indicator from observable with relationships
                    indicator_pattern = (
                        f"[file:hashes. '{self.hash_type}' = '{self.hash}']"
                    )
                    main_observable_type = "File"
                    indicator_name = self.hash
                    self._generate_stix_indicator(
                        results, indicator_name, indicator_pattern, main_observable_type
                    )

                    # Create Malware and relationships
                    self._generate_stix_malware(
                        results["malware_family"], results["malware_type"]
                    )

                # Create Note to Observable
                self._generate_stix_note(file_reputation_report)

                # Create Idicators from container_sample_sha1
                container_sample_sha1 = file_analysis_report["rl"]["sample"][
                    "relationships"
                ]["container_sample_sha1"]
                sample_sha1 = file_analysis_report["rl"]["sample"]["sha1"]
                for sha1 in container_sample_sha1:
                    if sha1 != sample_sha1:
                        self._check_file_reputation(
                            stix_objects, stix_entity, opencti_entity, sha1, "SHA-1"
                        )

                # Create Indicators from interesting strings
                entries = file_analysis_report["rl"]["sample"]["analysis"]["entries"]

                for ent in entries:
                    try:
                        int_strings = ent["tc_report"]["interesting_strings"]
                        for net_loc in int_strings:
                            self.helper.log_info(
                                f"{self.helper.connect_name}: NET_LOC {str(net_loc)}"
                            )
                            try:
                                match net_loc["category"]:
                                    case "ipv4" | "ipv6":
                                        network_type = "ipv4-addr"
                                    case "url" | "http":
                                        network_type = "url"
                                    case "domain":
                                        network_type = "domain-name"
                                    case _:
                                        return
                            except:
                                continue

                            for val in net_loc["values"]:
                                network_location = str(val)
                                network_type = str(network_type)
                                self._check_network_reputation(
                                    stix_objects,
                                    stix_entity,
                                    opencti_entity,
                                    network_location,
                                    network_type,
                                )
                    except:
                        self.helper.log_info(
                            f"{self.helper.connect_name}: There are no interesting strings for given hash."
                        )

                # Update existing observable with enrichment
                self._upsert_stix_file_observable(results)

            case _:
                self.helper.log_info(
                    f"{self.helper.connect_name}: There is no defined type for provided observable. Exiting..."
                )
                return

        self.helper.log_info(
            f"{self.helper.connect_name}: Finished with _check_file_reputation"
        )

    def _process_message(self, data: Dict):
        stix_objects = data["stix_objects"]
        stix_entity = data["stix_entity"]
        opencti_entity = data["enrichment_entity"]

        self.helper.log_info(
            f"{self.helper.connect_name}: Checking TLP marking on object."
        )
        self._check_tlp_markings(opencti_entity)
        opencti_type = stix_entity["x_opencti_type"]

        match opencti_type:
            case "StixFile" | "File" | "File-sha256" | "File-sha1":
                # Extract hash type and value from Entity
                hashes = opencti_entity.get("hashes")
                hash = hashes[0]["hash"]
                hash_type = hashes[0]["algorithm"]

                # Initiate Malware Presence Check on Entity
                self._check_file_reputation(
                    stix_objects, stix_entity, opencti_entity, hash, hash_type
                )

            case "IPv4-Addr" | "IPv6-Addr" | "Url" | "Domain-Name":
                network_location = stix_entity["value"]
                network_type = stix_entity["type"]
                self._check_network_reputation(
                    stix_objects,
                    stix_entity,
                    opencti_entity,
                    network_location,
                    network_type,
                )

            case _:
                self.helper.log_info(
                    f"{self.helper.connect_name}: Connector is not configured for data type: {opencti_type}"
                )
                return

        bundle = self._generate_stix_bundle(stix_objects, stix_entity)
        bundles_sent = self.helper.send_stix2_bundle(bundle)
        self.helper.log_info(
            f"{self.helper.connect_name}: Number of stix bundles sent for workers: {str(len(bundles_sent))}"
        )


if __name__ == "__main__":
    connector = ReversingLabsConnector()
    connector.start()
