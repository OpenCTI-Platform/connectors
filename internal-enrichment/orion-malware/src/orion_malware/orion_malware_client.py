"""Orion Malware client module"""
import base64
import json
import time
from hashlib import sha256
from typing import NoReturn

import requests
from pycti import OpenCTIConnectorHelper
from requests import RequestException
from requests.exceptions import ConnectTimeout, ReadTimeout


class OrionMalwareClientException(Exception):
    """Orion Malware client exception"""

    pass


class OrionMalwareClient:
    """Orion Malware client"""

    _API_TASKS = "/orion/api/v4.0/tasks"
    _API_GET_TASK = "/orion/api/v4.0/tasks/id="
    _API_SEARCH_REPORT = "/orion/api/v4.0/search"
    _API_FILE_REPORTS = "/orion/api/v4.0/filereports/"

    def __init__(
        self,
        base_url: str,
        helper: OpenCTIConnectorHelper,
        api_timeout: int,
        verify_ssl: bool,
    ):
        """Initialize Orion Malware client"""
        self._base_url = base_url
        self._helper = helper
        self._verify_ssl = verify_ssl
        self._api_timeout = api_timeout

        self._tlp_mapping_visibility = {
            "TLP:CLEAR": "public",
            "TLP:GREEN": "public",
            "TLP:AMBER": "group",
            "TLP:AMBER+STRICT": "group",
            "TLP:RED": "private",
        }

    @staticmethod
    def _current_time_ms():
        return int(round(time.time() * 1000))

    @staticmethod
    def _duration_ms(start_time_ms):
        return OrionMalwareClient._current_time_ms() - start_time_ms

    def _header(self, apikey: str):
        headers = {"apikey": apikey}
        return headers

    def _header_with_content_type(self, apikey: str):
        headers = {"content-type": "application/json", "apikey": apikey}
        return headers

    def create_tasks_file_analyse(
        self, filename: str, data: bytes, tlp: str, apikey: str
    ) -> str:
        self._helper.log_debug(f"create_tasks_file_analyse filename: {filename}")

        if data is None:
            msg = "File's data is empty"
            self._raise_client_exception(msg)

        if filename is None:
            filename = sha256(data).hexdigest()

        form_data = {
            "filename": filename,
            "client_version": 1,
            "visibility": self._tlp_mapping_visibility[tlp],
            "force": False,
        }
        json_data = {"json": json.dumps(form_data)}

        files_data = {"data": (None, data)}
        url = self._base_url + self._API_TASKS
        res = self._call_post_api(url, json_data, apikey, files_data=files_data)
        return res.text

    def get_task_status(self, id: str, apikey: str):
        url = self._base_url + self._API_GET_TASK + id
        return self._call_get_api(url, apikey).text

    def get_file_report_with_report_id(self, report_id: str, apikey: str):
        url = self._base_url + self._API_FILE_REPORTS + report_id
        return self._call_get_api(url, apikey).text

    def get_latest_file_report_for_given_hash(self, file_hash: str, apikey: str):
        url = self._base_url + self._API_SEARCH_REPORT
        json_data = {"query": {"hash": file_hash}}
        result = json.loads(
            self._call_post_api(url, json.dumps(json_data), apikey).text
        )
        if result.get("result"):
            return result.get("result")[0]
        else:
            raise ValueError(
                f"No report found for {file_hash}, or user has no reading permission on it"
            )

    def get_pdf_file_report(self, report_id: str, apikey: str):
        url = self._base_url + self._API_FILE_REPORTS + report_id + "/pdf"
        res = self._call_get_api(url, apikey)
        base_64_data = json.loads(res.text)["filereport"]["pdf"]
        return base64.b64decode(base_64_data)

    def _call_get_api(self, url: str, apikey: str):
        try:
            return requests.get(
                url,
                headers=self._header_with_content_type(apikey),
                verify=self._verify_ssl,
                timeout=self._api_timeout,
            )
        except ConnectTimeout:
            msg = f"Connection timed out after {self._api_timeout} seconds"
            self._raise_client_exception(msg)
        except ReadTimeout:
            msg = f"Waiting for response timed out after {self._api_timeout} seconds"
            self._raise_client_exception(msg)
        except RequestException as re:
            msg = f"Request to Orion failed: {str(re)}"
            self._raise_client_exception(msg)

    def _call_post_api(self, url: str, json_data, apikey: str, files_data=None):
        try:
            if files_data:
                return requests.post(
                    url,
                    data=json_data,
                    files=files_data,
                    headers=self._header(apikey),
                    verify=self._verify_ssl,
                    timeout=self._api_timeout,
                )
            else:
                return requests.post(
                    url,
                    data=json_data,
                    headers=self._header_with_content_type(apikey),
                    verify=self._verify_ssl,
                    timeout=self._api_timeout,
                )
        except ConnectTimeout:
            msg = f"Connection timed out after {self._api_timeout} seconds"
            self._raise_client_exception(msg)
        except ReadTimeout:
            msg = f"Waiting for response timed out after {self._api_timeout} seconds"
            self._raise_client_exception(msg)
        except RequestException as re:
            msg = f"Request to Orion failed: {str(re)}"
            self._raise_client_exception(msg)

    def _raise_client_exception(self, message: str) -> NoReturn:
        self._helper.log_error(message)
        raise OrionMalwareClientException(message)
