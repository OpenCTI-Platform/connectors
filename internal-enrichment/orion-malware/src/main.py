import datetime
import ipaddress
import json
import os
import re
import sys
import time
from typing import List

import stix2
import yaml
from orion_malware.orion_malware_client import (
    OrionMalwareClient,
    OrionMalwareClientException,
)
from pycti import OpenCTIConnectorHelper, StixCoreRelationship, get_config_variable


class OrionMalwareConnector:
    _API_FILE_REPORTS = "/orion/api/v4.0/filereports/hash="

    orion_score = {"Severe": 100, "High": 75, "Medium": 50, "Low": 20, "Safe": 0}

    def __init__(self):
        # Instantiate the connector helper from config
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        self.helper = OpenCTIConnectorHelper(config)

        self.identity = self.helper.api.identity.create(
            type="Organization", name="OrionMalware", description="Hybrid file analyser"
        )

        self.octi_api_url = get_config_variable(
            "OPENCTI_URL", ["opencti", "url"], config
        )

        self._api_url = get_config_variable(
            "ORION_MALWARE_URL", ["orion_malware", "url"], config
        )
        self._verify_ssl = get_config_variable(
            "ORION_MALWARE_VERIFY_SSL", ["orion_malware", "verify_ssl"], config
        )
        self._default_tlp = get_config_variable(
            "ORION_MALWARE_DEFAULT_TLP", ["orion_malware", "default_tlp"], config
        )
        self._api_timeout = get_config_variable(
            "ORION_MALWARE_API_TIMEOUT",
            ["orion_malware", "api_timeout"],
            config,
            isNumber=True,
        )
        self._orion_default_api_key = get_config_variable(
            "ORION_MALWARE_DEFAULT_API_KEY",
            ["orion_malware", "default_api_key"],
            config,
        )
        self._orion_tlp_red_visibility = get_config_variable(
            "ORION_MALWARE_TLP_RED_VISIBILITY",
            ["orion_malware", "tlp_red_visibility"],
            config,
        )
        self._orion_tlp_amber_visibility = get_config_variable(
            "ORION_MALWARE_TLP_AMBER_AND_AMBER_STRICT_VISIBILITY",
            ["orion_malware", "tlp_amber_and_amber_strict_visibility"],
            config,
        )
        self._orion_tlp_clear_and_green_visibility = get_config_variable(
            "ORION_MALWARE_TLP_CLEAR_AND_GREEN_VISIBILITY",
            ["orion_malware", "tlp_clear_and_green_visibility"],
            config,
        )
        open_cti_organisation_string = get_config_variable(
            "OPEN_CTI_ORGANISATIONS", ["orion_malware", "organisations"], config
        )
        if open_cti_organisation_string is not None:
            self._open_cti_organisations = {
                key: value
                for key, value in (
                    item.split(":") for item in open_cti_organisation_string.split(",")
                )
            }
        else:
            self._open_cti_organisations = {}

        self._verify_ssl = get_config_variable(
            "ORION_MALWARE_VERIFY_SSL", ["orion_malware", "verify_ssl"], config
        )
        self._orion_malware_client = OrionMalwareClient(
            self._api_url, self.helper, self._api_timeout, self._verify_ssl
        )

        self._confidence = int(
            get_config_variable(
                "CONNECTOR_CONFIDENCE_LEVEL", ["connector", "confidence_level"], config
            )
        )
        self._add_label = bool(
            get_config_variable(
                "CONNECTOR_ADD_LABEL", ["connector", "add_label"], config
            )
        )
        # Create default labels
        self._orion_opencti_score = {
            "Severe": "Malicious",
            "High": "Malicious",
            "Medium": "Suspicious",
            "Low": "Benign",
            "Safe": "Benign",
        }
        self._hashes_mapping = {"SHA-256": "sha256", "MD5": "md5", "SHA-1": "sha1"}

    def _process_observable(self, observable: dict, apikey: str, tlp: dict):
        if not observable.get("importFiles"):
            hash_value = None
            hash_type = None
            # Check if there is a report in Orion for the selected hashes file
            for hashes in observable.get("hashes"):
                if hashes.get("algorithm") in self._hashes_mapping:
                    hash_value = hashes.get("hash")
            if hash_type is None and hash_value is None:
                raise ValueError(
                    "No correct hashes for the given Observable: sha256/md5/sha1"
                )
            # Get the report id
            report_id = (
                self._orion_malware_client.get_latest_file_report_for_given_hash(
                    hash_value, apikey
                )
            )
            # Fetch the report
            analysis_report = self._orion_malware_client.get_file_report_with_report_id(
                report_id, apikey
            )

            # Process all analyses
            self._process_analysis(observable, analysis_report, report_id, apikey, tlp)

        else:
            # Download the Artifact from OpenCTI
            file_data, file_name = self._download_artifact(observable)
            self.helper.log_debug(
                f"Submitting {observable['importFiles'][0]['name']} to Orion Malware for analysis..."
            )
            # Submit the sample to Orion Malware
            result = self._orion_malware_client.create_tasks_file_analyse(
                file_name, file_data, tlp.get("definition"), apikey
            )
            try:
                submission_id = json.loads(result)["task"]["$oid"]
            except Exception:
                self.helper.log_error(str(result))
                raise ValueError(str(result))
            # Process submission
            self._process_submission(observable, submission_id, apikey, tlp)

    def _process_observables(self, observable: dict, apikey: str, tlp: dict):
        submission_ids = []
        artefacts = []
        objects = observable["objects"]
        for object in objects:
            if object["entity_type"] in ["StixFile", "Artifact"]:
                # Download the Artifact from OpenCTI
                file_observable = self.helper.api.stix_cyber_observable.read(
                    id=object["id"], withFiles=True
                )
                file_data, file_name = self._download_artifact(file_observable)
                self.helper.log_debug(
                    f"Submitting {file_observable['importFiles'][0]['name']} to Orion Malware for analysis..."
                )
                # Submit the sample to Orion Malware
                result = self._orion_malware_client.create_tasks_file_analyse(
                    file_name, file_data, tlp.get("definition"), apikey
                )
                try:
                    submission_id = json.loads(result)["task"]["$oid"]
                except Exception:
                    self.helper.log_error(str(result))
                    continue
                submission_ids.append(submission_id)
                artefacts.append(file_observable)
        # Process submission
        self._process_submissions(artefacts, submission_ids, apikey, tlp)

    def _download_artifact(self, observable) -> (bytes, str):
        """
        Download Artifact from OpenCTI
        """

        file_name = observable["importFiles"][0]["name"]
        file_id = observable["importFiles"][0]["id"]
        file_uri = f"{self.octi_api_url}/storage/get/{file_id}"
        file_content = self.helper.api.fetch_opencti_file(file_uri, binary=True)
        return file_content, file_name

    def _process_submission(
        self, observable: dict, submission_id: str, apikey: str, tlp: dict
    ):
        """
        observable: The dict containing the observable to enrich
        submission_id: Int representing the submission id
        returns: a str representing a message to return to OpenCTI
        """

        # Wait for all analyses to finish
        analysis_info = self._wait_for_analysis(submission_id, apikey)
        analysis_report = json.loads(
            self._orion_malware_client.get_file_report_with_report_id(
                analysis_info["task"]["report_id"], apikey
            )
        )

        # Process all analyses
        self._process_analysis(
            observable, analysis_report, analysis_info["task"]["report_id"], apikey, tlp
        )

    def _process_submissions(
        self, observables: List, submission_ids: List, apikey: str, tlp: dict
    ):
        """
        observable: The dict containing the observable to enrich
        submission_id: Int representing the submission id
        returns: a str representing a message to return to OpenCTI
        """

        # Wait for all analyses to finish
        analyses_report = []
        while True:
            analyses_info = []
            for observable, submission_id in zip(observables, submission_ids):
                try:
                    analyses_info.append(self._wait_for_analysis(submission_id, apikey))
                except OrionMalwareClientException:
                    observables.remove(observable)
                    submission_ids.remove(submission_id)
            if len(analyses_info) == len(submission_ids):
                break

        for analysis_info in analyses_info:
            analyses_report.append(
                json.loads(
                    self._orion_malware_client.get_file_report_with_report_id(
                        analysis_info["task"]["report_id"], apikey
                    )
                )
            )

        # Process all analyses
        for analysis_report, observable, analysis_info in zip(
            analyses_report, observables, analyses_info
        ):
            self._process_analysis(
                observable,
                analysis_report,
                analysis_info["task"]["report_id"],
                apikey,
                tlp,
            )

    def _wait_for_analysis(self, submission_id: str, apikey: str) -> dict:
        """
        Wait for submission to finish and return the analyses.
        """
        # TODO: Timout Global à mettre en place
        while True:
            # Sleep for a second before attempting to check on the analyses
            time.sleep(5)
            submission_info = json.loads(
                self._orion_malware_client.get_task_status(submission_id, apikey)
            )
            if (
                submission_info["task"]["status"] == 0
                or submission_info["task"]["status"] == 1
            ):
                continue
            elif submission_info["task"]["status"] == 2:
                return submission_info
            elif submission_info["task"]["status"] == 3:
                raise OrionMalwareClientException(f"Analyse {submission_id} failed")

    def _process_analysis(
        self, observable, analysis_report: dict, report_id: str, apikey: str, tlp: dict
    ):
        """
        Process all analyses and create observables/relationships
        """
        label_value = []
        # Attach external reference
        analysis_url = f"{self._api_url}/report/file/{report_id}"
        external_reference = self.helper.api.external_reference.create(
            source_name="Orion Malware File Analysis",
            url=analysis_url,
            description="Orion Malware Analysis",
            external_id=report_id,
        )
        self.helper.api.stix_cyber_observable.add_external_reference(
            id=observable["id"], external_reference_id=external_reference["id"]
        )

        # Update file score
        self.helper.api.stix_cyber_observable.update_field(
            id=observable["id"],
            input={
                "key": "x_opencti_score",
                "value": str(
                    self.orion_score.get(
                        analysis_report["filereport"]["overview"]["risk"]["level"]
                    )
                ),
            },
        )

        # Add antivirus signatures as label on the observable
        if self._add_label:
            try:
                antivirus_results = (
                    analysis_report.get("filereport")
                    .get("static")
                    .get("antivirus")
                    .get("antivirus_results")
                )
                if antivirus_results:
                    for antivirus_result in antivirus_results:
                        if antivirus_result["infected"]:
                            threat_name = (
                                antivirus_result["antivirus_name"]
                                + " : "
                                + antivirus_result["threat_name"]
                            )
                            label_value.append(threat_name)
                            antivirus_label = self.helper.api.label.create(
                                value=threat_name
                            )
                            self.helper.api.stix_cyber_observable.add_label(
                                id=observable["id"], label_id=antivirus_label["id"]
                            )
                else:
                    pass
            except Exception as e:
                self.helper.log_debug(str(e))
                pass

        try:
            ssdeep = (
                analysis_report.get("filereport")
                .get("static")
                .get("scanner")
                .get("pe")
                .get("info")
                .get("ssdeep")
            )

            # add SSDEEP value on the observable
            if ssdeep:
                self.helper.api.stix_cyber_observable.update_field(
                    id=observable["id"],
                    input={
                        "key": "hashes.ssdeep",
                        "value": ssdeep,
                    },
                )
                observable = self.helper.api.stix_cyber_observable.read(
                    id=observable["id"], withFiles=True
                )
            else:
                pass
        except Exception as e:
            self.helper.log_debug(str(e))
            pass

        if self._add_label:
            try:
                signatures_hits = analysis_report.get("filereport")("static")(
                    "signatures_hits"
                )
                if signatures_hits:
                    # Add signatures hits name as label on the observable
                    for signature_hit in signatures_hits:
                        label_value.append(signature_hit["name"])
                        signature_hit_label = self.helper.api.label.create(
                            value=signature_hit["name"]
                        )
                        self.helper.api.stix_cyber_observable.add_label(
                            id=observable["id"], label_id=signature_hit_label["id"]
                        )
                else:
                    pass
            except Exception as e:
                self.helper.log_debug(str(e))
                pass

        risk = self._orion_opencti_score.get(
            analysis_report["filereport"]["overview"]["risk"]["level"]
        )

        # update the creation value on the modified observable
        self.helper.api.stix_cyber_observable.update_field(
            id=observable["id"],
            input={
                "key": "createdBy",
                "value": self.identity["id"],
            },
        )
        # parse the file analysis string description
        file_analysis_description = self._process_file_activities(
            analysis_report["filereport"]
        )

        # Parse filereport element as Bundle Stix2 object
        self._process_json(
            observable,
            analysis_report["filereport"],
            external_reference,
            analysis_url,
            report_id,
            file_analysis_description,
            apikey,
            tlp,
            risk,
        )

    def _process_json(
        self,
        observable: dict,
        json_report: dict,
        external_reference: dict,
        analysis_url: str,
        report_id: str,
        file_analysis_description: str,
        apikey: str,
        tlp: dict,
        risk: str,
    ):
        """
        Handle the json report
        """
        sco_objects = []
        sdo_objects = []
        sro_objects = []
        sco_objects_ids = []
        sdo_objects_ids = []
        sro_objects_ids = []

        # Extract any identified Malware network communications IP / Domain Name / URL
        # and create relationship with initial observable
        network_communications = json_report.get("network")
        if network_communications:
            for network_communication in network_communications:
                try:
                    ip_value = network_communication.get("destination").get("host")
                    try:
                        if ipaddress.ip_address(ip_value).is_loopback:
                            self.helper.log_debug(f"Skipping private IP: {ip_value}")
                            continue
                    except Exception:
                        pass
                    if self._is_ipv4_address(ip_value):
                        ip_stix = stix2.IPv4Address(
                            value=ip_value,
                            custom_properties={
                                "created_by_ref": self.identity["standard_id"],
                            },
                            object_marking_refs=[tlp.get("standard_id")],
                        )
                        relationship_ip = stix2.Relationship(
                            id=StixCoreRelationship.generate_id(
                                "communicates-with",
                                observable["standard_id"],
                                ip_stix.id,
                            ),
                            relationship_type="communicates-with",
                            created_by_ref=self.identity["standard_id"],
                            source_ref=observable["standard_id"],
                            target_ref=ip_stix.id,
                            allow_custom=True,
                            confidence=self._confidence,
                            object_marking_refs=[tlp.get("standard_id")],
                        )
                        sco_objects.append(ip_stix)
                        sro_objects.append(relationship_ip)
                        sco_objects_ids.append(ip_stix.id)
                        sro_objects_ids.append(relationship_ip.id)
                    if network_communication.get("dns") is not None:
                        domain_name = network_communication.get("dns").get("hostname")
                        if (
                            domain_name is not None
                            and domain_name.lower() != "cherrymike-pc"
                            and "<" not in domain_name
                            and ">" not in domain_name
                            and not self._is_ipv4_address(domain_name)
                        ):
                            domain_stix = stix2.DomainName(
                                value=domain_name,
                                custom_properties={
                                    "created_by_ref": self.identity["standard_id"],
                                },
                                object_marking_refs=[tlp.get("standard_id")],
                            )
                            relationship_domain = stix2.Relationship(
                                id=StixCoreRelationship.generate_id(
                                    "communicates-with",
                                    observable["standard_id"],
                                    domain_stix.id,
                                ),
                                relationship_type="communicates-with",
                                created_by_ref=self.identity["standard_id"],
                                source_ref=observable["standard_id"],
                                target_ref=domain_stix.id,
                                confidence=self._confidence,
                                object_marking_refs=[tlp.get("standard_id")],
                            )
                            sco_objects.append(domain_stix)
                            sro_objects.append(relationship_domain)
                            sco_objects_ids.append(domain_stix.id)
                            sro_objects_ids.append(relationship_domain.id)

                    if network_communication.get("http") is not None:
                        http_request_stix = stix2.HTTPRequestExt(
                            request_method=network_communication.get("http")
                            .get("request")
                            .get("method"),
                            request_value=network_communication.get("destination").get(
                                "host"
                            )
                            + network_communication.get("http")
                            .get("request")
                            .get("path"),
                            request_header={
                                "User-Agent": network_communication.get("http")
                                .get("request")
                                .get("user_agent"),
                                "Parameters": network_communication.get("http")
                                .get("request")
                                .get("params"),
                            },
                        )
                        url_name = (
                            network_communication.get("service_name")
                            + "://"
                            + network_communication.get("destination").get("host")
                            + network_communication.get("http")
                            .get("request")
                            .get("path")
                        )
                        url_stix = stix2.URL(
                            value=url_name,
                            custom_properties={
                                "created_by_ref": self.identity["standard_id"],
                            },
                            object_marking_refs=[tlp.get("standard_id")],
                            extensions={"http-request-ext": http_request_stix},
                        )
                        relationship_url = stix2.Relationship(
                            id=StixCoreRelationship.generate_id(
                                "related-to",
                                url_stix.id,
                                observable["standard_id"],
                            ),
                            relationship_type="related-to",
                            created_by_ref=self.identity["standard_id"],
                            source_ref=url_stix.id,
                            target_ref=observable["standard_id"],
                            confidence=self._confidence,
                            object_marking_refs=[tlp.get("standard_id")],
                        )
                        sco_objects.append(url_stix)
                        sro_objects.append(relationship_url)
                        sco_objects_ids.append(url_stix.id)
                        sro_objects_ids.append(relationship_url.id)

                except Exception as e:
                    self.helper.log_error(str(e))
                    continue

        # Extract any identified Malware Attack Pattern (MITRE ATT&CK ID)
        # and create relationship with initial observable
        attack_ids = json_report.get("dynamic").get("matched_mitre_attack_id")
        for attack_id in attack_ids:
            try:
                attack_pattern = self.helper.api.attack_pattern.list(
                    filters={
                        "mode": "and",
                        "filters": [{"key": "x_mitre_id", "values": attack_id}],
                        "filterGroups": [],
                    }
                )[0]
                relationship_attack_pattern = stix2.Relationship(
                    id=StixCoreRelationship.generate_id(
                        "uses", observable["standard_id"], attack_pattern["standard_id"]
                    ),
                    relationship_type="uses",
                    created_by_ref=self.identity["standard_id"],
                    source_ref=observable["standard_id"],
                    target_ref=attack_pattern["standard_id"],
                    confidence=self._confidence,
                    object_marking_refs=[tlp.get("standard_id")],
                )
                sro_objects.append(relationship_attack_pattern)
                sdo_objects_ids.append(attack_pattern["standard_id"])
                sro_objects_ids.append(relationship_attack_pattern.id)
            except Exception as e:
                self.helper.log_debug(str(e))
                continue

        external_reference_object = stix2.ExternalReference(
            source_name="Orion Malware File Analysis",
            url=analysis_url,
            description="Orion Malware Analysis",
            external_id=report_id,
        )

        # Extract information about the malware analysis environment
        # and create Malware Analysis object and relationship with the analysed observable
        modules = []
        if "dynamic" in json_report:
            modules.append("Sandbox")
        if "antivirus" in json_report.get("static"):
            modules.append("Antivirus")
        if "scanner" in json_report.get("static"):
            modules.append("Static scanner & AI models")
        if json_report.get("static").get("signatures_hits"):
            modules.append("Rules based detection (Yara & IOC")
        if "reputation_hashlist" in json_report.get("static"):
            modules.append("Reputation Hashlist")

        start_analysis = json_report.get("overview").get("submissions").get("last_date")
        end_analysis = json_report.get("overview").get("last_updated")

        malware_analysis = stix2.MalwareAnalysis(
            product="Orion Malware",
            result_name=f"Report {report_id}",
            created_by_ref=self.identity["standard_id"],
            analysis_sco_refs=sco_objects_ids,
            result=risk,
            sample_ref=observable["standard_id"],
            external_references=[external_reference_object],
            confidence=self._confidence,
            modules=modules,
            submitted=json_report.get("overview").get("submissions").get("first_date"),
            analysis_started=datetime.datetime.fromisoformat(start_analysis),
            analysis_ended=datetime.datetime.fromisoformat(end_analysis),
            version=json_report.get("overview").get("version"),
            object_marking_refs=[tlp.get("standard_id")],
        )

        malware_analysis_relationship = stix2.Relationship(
            id=StixCoreRelationship.generate_id(
                "related-to", malware_analysis.id, observable["standard_id"]
            ),
            relationship_type="related-to",
            created_by_ref=self.identity["standard_id"],
            source_ref=malware_analysis.id,
            target_ref=observable["standard_id"],
            confidence=self._confidence,
            object_marking_refs=[tlp.get("standard_id")],
        )

        sro_objects.append(malware_analysis_relationship)
        sro_objects_ids.append(malware_analysis_relationship.id)
        sco_objects_ids.append(observable["standard_id"])
        sdo_objects.append(malware_analysis)
        sdo_objects_ids.append(malware_analysis.id)

        # Create a grouping object that referer all observable extract during the analysis (Stix2 Cyber Observable,
        # Stix2 Data Observable and Stix2 Relationship Observable)

        grouping = stix2.Grouping(
            name=f"Orion Malware Analysis {report_id}",
            created_by_ref=self.identity["standard_id"],
            context="malware-analysis",
            object_refs=sco_objects_ids + sdo_objects_ids + sro_objects_ids,
            external_references=[external_reference_object],
            description=file_analysis_description,
            confidence=self._confidence,
            object_marking_refs=[tlp.get("standard_id")],
        )
        sdo_objects.append(grouping)

        artifact_relationship = stix2.Relationship(
            id=StixCoreRelationship.generate_id(
                "related-to", grouping.id, observable["standard_id"]
            ),
            relationship_type="related-to",
            created_by_ref=self.identity["standard_id"],
            source_ref=grouping.id,
            target_ref=observable["standard_id"],
            confidence=self._confidence,
            object_marking_refs=[tlp.get("standard_id")],
        )
        sro_objects.append(artifact_relationship)

        # send bundle to OpenCTI
        self._send_bundle_objects(sco_objects + sdo_objects + sro_objects)

        try:
            # Upload the full pdf report
            data = self._orion_malware_client.get_pdf_file_report(report_id, apikey)
            self.helper.api.external_reference.add_file(
                id=external_reference["id"],
                file_name=f"filereport-{report_id}-pdf",
                data=data,
                mime_type="application/pdf",
            )
        except Exception as e:
            self.helper.log_debug(f"Failed to retrieve pdf report, exception: {e}")

    def _get_observable_tlp(self, observable: dict) -> dict:
        object_marking = observable.get("objectMarking")
        if not object_marking:
            tlp = self.helper.api.marking_definition.read(
                filters={
                    "mode": "and",
                    "filters": [{"key": "definition", "values": [self._default_tlp]}],
                    "filterGroups": [],
                }
            )
            return tlp
        elif len(object_marking) > 1:
            raise ValueError(
                "Failed to process observable TLP, multiple TLP find on Observable."
            )
        else:
            if object_marking[0].get("definition_type") == "TLP":
                return object_marking[0]

    def _get_api_key_of_organization(self, observable):
        created_by = observable.get("createdBy")
        if created_by:
            for organisation_name, apikey in self._open_cti_organisations.items():
                if created_by.get("name").lower() == organisation_name.lower():
                    return apikey
            return self._orion_default_api_key
        else:
            return self._orion_default_api_key

    def _send_bundle_objects(self, bundle_objects):
        if bundle_objects:
            bundle = stix2.Bundle(objects=bundle_objects, allow_custom=True).serialize()
            bundles_sent = self.helper.send_stix2_bundle(bundle)
            self.helper.log_debug(
                f"Sent {len(bundles_sent)} stix bundle(s) for worker import"
            )
        else:
            self.helper.log_debug("Nothing to attach")

    def _is_ipv4_address(self, ip):
        try:
            m = re.match(r"^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$", ip)
            return bool(m) and all(map(lambda n: 0 <= int(n) <= 255, m.groups()))
        except Exception:
            return False

    def _process_message(self, data):
        observable_value = self.helper.api.stix_core_object.read(id=data["entity_id"])
        if observable_value["entity_type"] in ["StixFile", "Artifact"]:
            observable = self.helper.api.stix_cyber_observable.read(
                id=data["entity_id"], withFiles=True
            )
            if not observable:
                raise ValueError(
                    "Observable not found"
                    "(may be linked to data segregation, check your group and permissions)"
                )
            apikey = self._get_api_key_of_organization(observable)
            tlp = self._get_observable_tlp(observable)
            self._process_observable(observable, apikey, tlp)
        elif observable_value["entity_type"] in ["Report"]:
            observable = self.helper.api.report.read(id=data["entity_id"])
            if not observable:
                raise ValueError(
                    "Observable not found"
                    "(may be linked to data segregation, check your group and permissions)"
                )
            apikey = self._get_api_key_of_organization(observable)
            tlp = self._get_observable_tlp(observable)
            self._process_observables(observable, apikey, tlp)

    def _process_file_activities(self, analysis_report: dict) -> str:
        dynamic_file_activities = analysis_report.get("dynamic").get("risk")
        static_file_activities = analysis_report.get("static").get("risk")
        description = ""
        description += "Dynamic Analysis : \n\n"
        if dynamic_file_activities.get("files_activity").get("malicious_activities"):
            description += "File Activities : "
            for activities in dynamic_file_activities.get("files_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if dynamic_file_activities.get("network_activity").get("malicious_activities"):
            description += "    Network Activities : "
            for activities in dynamic_file_activities.get("network_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if dynamic_file_activities.get("persistence_activity").get(
            "malicious_activities"
        ):
            description += "  Persistence Activities : "
            for activities in dynamic_file_activities.get("persistence_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if dynamic_file_activities.get("process_activity").get("malicious_activities"):
            description += "  Process Activities : "
            for activities in dynamic_file_activities.get("process_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if dynamic_file_activities.get("system_activity").get("malicious_activities"):
            description += "    System Activities : "
            for activities in dynamic_file_activities.get("system_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"

        description += "Static Analysis : \n\n"
        if static_file_activities.get("files_activity").get("malicious_activities"):
            description += "    File Activities : "
            for activities in static_file_activities.get("files_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if static_file_activities.get("network_activity").get("malicious_activities"):
            description += "    Network Activities : "
            for activities in static_file_activities.get("network_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if static_file_activities.get("persistence_activity").get(
            "malicious_activities"
        ):
            description += "    Persistence Activities : "
            for activities in static_file_activities.get("persistence_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if static_file_activities.get("process_activity").get("malicious_activities"):
            description += "  Process Activities : "
            for activities in static_file_activities.get("process_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        if static_file_activities.get("system_activity").get("malicious_activities"):
            description += "  System Activities : "
            for activities in static_file_activities.get("system_activity").get(
                "malicious_activities"
            ):
                description += "{}, ".format(activities)
            description += "\n\n"
        description += "Anti-Virus Analysis : \n\n"
        if analysis_report.get("static").get("antivirus"):
            for antivirus_result in (
                analysis_report.get("static").get("antivirus").get("antivirus_results")
            ):
                if antivirus_result["infected"]:
                    description += "{} : {}, ".format(
                        antivirus_result["antivirus_name"],
                        antivirus_result["threat_name"],
                    )
                    description += "\n"
        description += "\n\n"

        return description

    # Start the main l
    def start(self):
        self.helper.listen(self._process_message)


if __name__ == "__main__":
    try:
        orion_malware = OrionMalwareConnector()
        orion_malware.start()
    except Exception as e:
        print(e)
        time.sleep(10)
        sys.exit(0)
