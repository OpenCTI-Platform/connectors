import json

import pycti
import stix2
from pycti import (
    STIX_EXT_OCTI_SCO,
    OpenCTIStix2,
    StixCoreRelationship,
)


class ConverterToSTIX:
    """
    Provides methods for converting various types of input data into STIX 2.1 objects.
    """

    def __init__(self, helper: pycti.OpenCTIConnectorHelper):
        self._identity = self._create_identity()
        self._helper = helper

    def _create_identity(
        self,
    ) -> stix2.Identity:
        return stix2.Identity(
            id=pycti.Identity.generate_id(name="GLIMPS", identity_class="organization"),
            name="GLIMPS",
            identity_class="organization",
            description="Malware Analysis Platform",
        )

    def _add_score(self, entity: dict, malware: bool, analysis_score: int) -> None:
        score = 0
        if malware:
            score = 100
        elif analysis_score >= 1000:
            score = 75
        elif analysis_score >= 100:
            score = 50

        OpenCTIStix2.put_attribute_in_extension(
            entity, STIX_EXT_OCTI_SCO, "score", score
        )

    def _add_labels(self, entity: dict, labels: list) -> None:
        """Add labels to observable via OpenCTI extensions"""
        for label in labels:
            OpenCTIStix2.put_attribute_in_extension(
                entity, STIX_EXT_OCTI_SCO, "labels", label, True
            )

    def _add_external_reference(self, entity: dict, url: str, uuid: str) -> None:
        OpenCTIStix2.put_attribute_in_extension(
            entity,
            STIX_EXT_OCTI_SCO,
            "external_references",
            {
                "source_name": "GLIMPS_MALWARE",
                "url": url,
                "description": "GLIMPS Malware file analysis",
                "external_id": uuid,
            },
            True,
        )

    def _update_entity_from_bundle_file(self, entity: dict, bundle_file: dict) -> None:
        entity["size"] = bundle_file["size"]
        entity["mime_type"] = bundle_file["mime_type"]

        bundle_hashes = bundle_file.get("hashes", {})
        if bundle_hashes:
            if "hashes" not in entity:
                entity["hashes"] = {}
            entity["hashes"].update(bundle_hashes)

        entity["contains_refs"] = bundle_file.get("contains_refs", [])

    def _update_references_in_objects(
        self, objects: list[dict], old_id: str, new_id: str
    ) -> None:
        for obj in objects:
            if isinstance(obj, dict):
                if obj.get("source_ref", "") == old_id:
                    obj["source_ref"] = new_id
                if obj.get("target_ref", "") == old_id:
                    obj["target_ref"] = new_id

                if "object_refs" in obj and isinstance(obj["object_refs"], list):
                    obj["object_refs"] = [
                        new_id if ref == old_id else ref for ref in obj["object_refs"]
                    ]

    def build_bundle(
        self,
        file_sha256: str,
        entity: dict,
        gmalware_result: dict,
        gmalware_url: str,
        gmalware_raw_bundle: bytes,
    ) -> list:
        """
        Build bundle from base entity and gmalware results, also modify entity to enrich it.
        """
        additional_objects = []
        bundle_file_id_to_replace = None

        self._add_score(
            entity=entity,
            malware=gmalware_result.get("is_malware", False),
            analysis_score=gmalware_result.get("score", 0),
        )

        # Collect labels from AV results
        labels = []
        for file_data in gmalware_result.get("files", []):
            for av_result in file_data.get("av_results", []):
                label_value = f"{av_result['av'].removeprefix('Signature')}: {av_result['result']}"
                labels.append(label_value)
        if labels:
            self._add_labels(entity, labels)
        if gmalware_url != "":
            self._add_external_reference(
                entity, gmalware_url, gmalware_result.get("uuid", "")
            )

        additional_objects.append(self._identity)

        if gmalware_raw_bundle:
            try:
                gmalware_bundle = json.loads(gmalware_raw_bundle.decode("utf-8"))

                for obj in gmalware_bundle.get("objects", []):
                    if isinstance(obj, dict):
                        if (
                            obj.get("type", "") == "file"
                            and obj.get("hashes", {}).get("SHA-256", "") == file_sha256
                        ):
                            if entity.get("type") == "file":
                                bundle_file_id_to_replace = obj.get("id")
                                self._update_entity_from_bundle_file(entity, obj)
                                continue

                            additional_objects.append(obj)
                            relationship = stix2.Relationship(
                                id=StixCoreRelationship.generate_id(
                                    "related-to", entity["id"], obj.get("id")
                                ),
                                relationship_type="related-to",
                                source_ref=entity["id"],
                                target_ref=obj.get("id"),
                                created_by_ref=self._identity.id,
                            )
                            additional_objects.append(relationship)
                            continue

                        additional_objects.append(obj)

                if bundle_file_id_to_replace:
                    self._update_references_in_objects(
                        additional_objects, bundle_file_id_to_replace, entity["id"]
                    )

            except Exception as e:
                self._helper.connector_logger.warning(
                    f"Failed to process GLIMPS bundle: {str(e)}"
                )

        return additional_objects
