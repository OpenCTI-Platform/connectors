import hashlib
import io

import gdetect
from gdetect import Client as GDdetectClient
from pycti import OpenCTIConnectorHelper

from .config_loader import GLIMPSMalwareConfig
from .converter_to_stix import ConverterToSTIX


class GLIMPSMalwareConnector:
    def __init__(self, config: GLIMPSMalwareConfig, helper: OpenCTIConnectorHelper):
        self.config = config
        self.helper = helper

        self._converter = ConverterToSTIX(helper=helper)

        # Initialize GDdetect client
        self._gdetect_client = GDdetectClient(
            url=self.config.gdetect_url, token=self.config.gdetect_token
        )
        self._gdetect_client.verify = not (self.config.gdetect_insecure)
        self._gdetect_analysis_timeout = self.config.gdetect_timeout

        self._gdetect_tags = self.config.gdetect_raw_tags.split(",")

    def _submit(self, filesha256: str, filename: str, file_content: bytes) -> dict:
        try:
            analysis_result = self._gdetect_client.get_by_sha256(filesha256)
            self.helper.connector_logger.info(
                f"file already submitted, result UUID: {analysis_result['uuid']}"
            )

            return analysis_result
        except gdetect.exceptions.GDetectError as e:
            self.helper.connector_logger.warning(f"Could not get result, {e}")

        try:
            self.helper.connector_logger.info("Submitting file for analysis")
            reader = io.BytesIO(file_content)
            analysis_result = self._gdetect_client.waitfor_reader(
                filename=filename,
                reader=reader,
                timeout=self._gdetect_analysis_timeout,
                tags=self._gdetect_tags,
            )
            return analysis_result
        except gdetect.exceptions.GDetectTimeoutError:
            self.helper.connector_logger.error(
                "Error submitting file to GLIMPS Malware: analysis take too much time."
            )
            raise
        except gdetect.exceptions.GDetectError as e:
            self.helper.connector_logger.error(f"GLIMPS API error: {e}")
            raise
        except Exception as e:
            self.helper.connector_logger.error(
                f"Error submitting file to GLIMPS Malware: {e}"
            )
            raise

    def _process_file(
        self, observable: dict, stix_entity: dict, stix_objects: list
    ) -> str:
        self.helper.connector_logger.info("GLIMPS Malware connector triggered...")
        if observable["entity_type"] not in ["StixFile", "Artifact"]:
            raise ValueError(
                f"Failed to process observable, {observable['entity_type']} is not a supported entity type."
            )
        if not observable.get("importFiles"):
            raise ValueError(f"No files found for {observable['observable_value']}")

        # Build the URI to download the file
        file_id = observable["importFiles"][0]["id"]
        file_name = observable["importFiles"][0]["name"]

        file_uri = f"{self.helper.opencti_url}/storage/get/{file_id}"
        file_content = self.helper.api.fetch_opencti_file(file_uri, True)

        file_sha256 = ""
        for hash_obj in observable.get("hashes", []):
            if hash_obj["algorithm"] == "SHA-256":
                file_sha256 = hash_obj["hash"]
                break
        else:
            file_sha256 = str(hashlib.sha256(file_content).hexdigest())

        # Submit file for analysis and get results
        try:
            analysis_result = self._submit(file_sha256, file_name, file_content)
        except Exception as e:
            self.helper.connector_logger.error(f"Failed to retrieve results: {str(e)}")
            raise

        # Get raw STIX bundle if possible
        raw_export_bundle = None
        try:
            self.helper.connector_logger.info(
                f"retrieve stix bundle from uuid: {analysis_result['uuid']}"
            )
            raw_export_bundle = self._gdetect_client.export_result(
                analysis_result["uuid"], "stix", "en", True
            )
        except Exception:
            self.helper.connector_logger.warning(
                "Failed to retrieve stix bundle from glimps malware, check your profile permission"
            )

        expert_url = ""
        try:
            expert_url = self._gdetect_client.extract_url_token_view(analysis_result)
        except gdetect.exceptions.MissingTokenError:
            self.helper.connector_logger.warning("could not get view token url")

        try:
            expert_url = self._gdetect_client.extract_expert_url(analysis_result)
        except gdetect.exceptions.MissingSIDError:
            self.helper.connector_logger.warning("could not get expert url")

        additional_objects = self._converter.build_bundle(
            file_sha256, stix_entity, analysis_result, expert_url, raw_export_bundle
        )

        return additional_objects

    def _send_bundle(self, stix_objects: list) -> str:
        stix_objects_bundle = self.helper.stix2_create_bundle(stix_objects)
        bundles_sent = self.helper.send_stix2_bundle(stix_objects_bundle)
        return f"Sending {len(bundles_sent)} stix bundle(s) for worker import"

    def _process_message(self, data: dict) -> str:
        observable = data["enrichment_entity"]
        stix_entity = data["stix_entity"]
        stix_objects = data["stix_objects"]

        # avoid pushing entire file to rabbitmq
        stix_entity.pop("x_opencti_files", None)

        # Extract TLP
        tlp = "TLP:CLEAR"
        for marking_definition in observable["objectMarking"]:
            if marking_definition["definition_type"] == "TLP":
                tlp = marking_definition["definition"]
        if not OpenCTIConnectorHelper.check_max_tlp(tlp, self.config.max_tlp):
            raise ValueError(
                "Do not send any data, TLP of the observable is greater than MAX TLP"
            )

        try:
            additional_objects = self._process_file(
                observable, stix_entity, stix_objects=stix_objects
            )
            for i, obj in enumerate(stix_objects):
                if isinstance(obj, dict) and obj.get("id") == observable["id"]:
                    stix_objects[i] = observable
                    break
            else:
                stix_objects.append(observable)

            if additional_objects:
                stix_objects.extend(additional_objects)

            return self._send_bundle(stix_objects)
        except Exception as e:
            self.helper.connector_logger.error(f"Error processing observable: {str(e)}")
            return self._send_bundle(stix_objects=stix_objects)

    def run(self) -> None:
        """
        Run the main process in self.helper.listen() method
        The method continuously monitors a message queue associated with a specific connector
        The connector have to listen a specific queue to get and then enrich the information.
        The helper provide an easy way to listen to the events.
        """
        self.helper.listen(message_callback=self._process_message)
