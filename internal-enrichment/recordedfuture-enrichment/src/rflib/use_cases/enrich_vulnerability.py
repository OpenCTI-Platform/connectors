from datetime import datetime, timezone

from connectors_sdk.models.octi import (
    URL,
    AttackPattern,
    BaseIdentifiedEntity,
    City,
    Country,
    DomainName,
    ExternalReference,
    File,
    Indicator,
    Individual,
    IPV4Address,
    IPV6Address,
    Malware,
    Note,
    Organization,
    OrganizationAuthor,
    Relationship,
    Report,
    Software,
    TLPMarking,
    Vulnerability,
)
from connectors_sdk.models.octi.enums import TLPLevel
from pycti import OpenCTIConnectorHelper

# Import ValidationError from pydantic because it's the type of errors raised by connectors-sdk models
# In the near future, the error type should be imported from connectors-sdk exceptions module
from pydantic import ValidationError
from rf_client.models import VulnerabilityEnrichment
from rflib.rf_utils import get_hash_algorithm, parse_cpe, validate_ip_or_cidr

REPORT_TYPES_BY_RF_TOPIC = {
    "Actor Profile": "Threat-Actor",
    "Analyst On-Demand Report": "Threat-Report",
    "Cyber Threat Analysis": "Threat-Report",
    "Executive Insights": "Threat-Report",
    "Flash Report": "Threat-Report",
    "Geopolitical Flash Event": "Threat-Report",
    "Geopolitical Intelligence Summary": "Threat-Report",
    "Geopolitical Profile": "Threat-Actor",
    "Geopolitical Threat Forecast": "Threat-Actor",
    "Geopolitical Validated Event": "Observed-Data",
    "Hunting Package": "Attack-Pattern",
    "Indicator": "Indicator",
    "Informational": "Threat-Report",
    "Insikt Research Lead": "Intrusion-Set",
    "Malware/Tool Profile": "Malware",
    "Regular Vendor Vulnerability Disclosures": "Vulnerability",
    "Sigma Rule": "Attack-Pattern",
    "SNORT Rule": "Indicator",
    "Source Profile": "Observed-Data",
    "The Record by Recorded Future": "Threat-Report",
    "Threat Lead": "Threat-Actor",
    "TTP Instance": "Attack-Pattern",
    "Validated Intelligence Event": "Observed-Data",
    "Weekly Threat Landscape": "Threat-Report",
    "YARA Rule": "Indicator",
}


class VulnerabilityEnrichmentError(Exception):
    """Custom exception for error during enrichment of a vulnerability."""


class VulnerabilityEnricher:
    def __init__(self, helper: OpenCTIConnectorHelper, tlp_level: TLPLevel):
        self.helper = helper  # to import pycti logger
        self.author = self._create_author()
        self.tlp_marking = self._create_tlp_marking(tlp_level)

    def _create_author(self) -> OrganizationAuthor:
        """Create Recorded Future Author"""
        return OrganizationAuthor(name="Recorded Future")

    def _create_tlp_marking(self, tlp_level: TLPLevel = "red") -> TLPMarking:
        """Create a TLP Marking definition for OCTI objects imported from RecordedFuture."""
        return TLPMarking(level=tlp_level)

    def _create_relationship(
        self,
        relationship_type: str,
        source: BaseIdentifiedEntity,
        target: BaseIdentifiedEntity,
    ) -> Relationship:
        """Create a relationship between two entities."""
        return Relationship(
            type=relationship_type,
            source=source,
            target=target,
            author=self.author,
        )

    def _convert_vulnerability_nvd_references(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[ExternalReference]:
        """Create OCTI External References from RecordedFuture vulnerability's NVD references.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI External References
        """
        external_references = []
        for nvd_reference in vulnerability_enrichment.nvdReferences:
            if nvd_reference.url:
                external_references.append(
                    ExternalReference(
                        url=nvd_reference.url,
                        source_name="NVD",
                        description=vulnerability_enrichment.nvdDescription,
                    )
                )

        return external_references

    def _convert_vulnerability_related_links(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[ExternalReference]:
        """Create OCTI External References from RecordedFuture vulnerability's related links.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI External References
        """
        external_references = []
        for url in vulnerability_enrichment.relatedLinks:
            external_references.append(
                ExternalReference(
                    url=url,
                    source_name="Recorded Future",
                )
            )

        return external_references

    def _convert_vulnerability_cvss_s(
        self,
        vulnerability_enrichment: VulnerabilityEnrichment,
        octi_vulnerability_data: dict,
    ) -> Vulnerability:
        """Create OCTI Vulnerability from RecordedFuture vulnerability's CVSS data.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :param octi_vulnerability_data: Original vulnerability data on OCTI
        :return: An OCTI Vulnerability
        """
        # On RecordedFuture, CVSS are v2 by default
        cvss_v2 = vulnerability_enrichment.cvss
        cvss_v3 = vulnerability_enrichment.cvssv3
        cvss_v4 = vulnerability_enrichment.cvssv4

        vulnerability_description = (
            vulnerability_enrichment.aiInsights.text
            if vulnerability_enrichment.aiInsights
            else octi_vulnerability_data.get("description") or ""
        )
        for cvss_object in [cvss_v2, cvss_v3, cvss_v4]:
            cvss_source_name = getattr(cvss_object, "source", None)
            cvss_version = getattr(cvss_object, "version", "(unknown version)")
            if cvss_source_name:
                source_description = (
                    f"Source of CVSS {cvss_version}: {cvss_source_name}"
                )
                if source_description not in vulnerability_description:
                    vulnerability_description += f"  \n{source_description}"

        return Vulnerability(
            name=octi_vulnerability_data.get("name"),
            description=vulnerability_description,
            labels=[vulnerability_enrichment.lifecycleStage],
            aliases=vulnerability_enrichment.commonNames,
            score=vulnerability_enrichment.risk.score,
            cvss_v2_vector_string=cvss_v2.vectorString,
            cvss_v2_base_score=cvss_v2.score,
            cvss_v2_access_vector=cvss_v2.accessVector,
            cvss_v2_access_complexity=cvss_v2.accessComplexity,
            cvss_v2_authentication=cvss_v2.authentication,
            cvss_v2_confidentiality_impact=cvss_v2.confidentiality,
            cvss_v2_integrity_impact=cvss_v2.integrity,
            cvss_v2_availability_impact=cvss_v2.availability,
            cvss_v3_vector_string=cvss_v3.vectorString,
            cvss_v3_base_score=cvss_v3.baseScore,
            cvss_v3_base_severity=(
                cvss_v3.baseSeverity.upper() if cvss_v3.baseSeverity else None
            ),
            cvss_v3_attack_vector=cvss_v3.attackVector,
            cvss_v3_attack_complexity=cvss_v3.attackComplexity,
            cvss_v3_privileges_required=cvss_v3.privilegesRequired,
            cvss_v3_user_interaction=cvss_v3.userInteraction,
            cvss_v3_scope=cvss_v3.scope,
            cvss_v3_confidentiality_impact=cvss_v3.vectorString,
            cvss_v3_integrity_impact=cvss_v3.vectorString,
            cvss_v3_availability_impact=cvss_v3.vectorString,
            cvss_v4_vector_string=cvss_v4.vectorString,
            cvss_v4_base_score=cvss_v4.baseScore,
            cvss_v4_base_severity=(
                cvss_v4.baseSeverity.upper() if cvss_v4.baseSeverity else None
            ),
            cvss_v4_attack_vector=cvss_v4.attackVector,
            cvss_v4_attack_complexity=cvss_v4.attackComplexity,
            cvss_v4_attack_requirements=cvss_v4.attackRequirements,
            cvss_v4_privileges_required=cvss_v4.privilegesRequired,
            cvss_v4_user_interaction=cvss_v4.userInteraction,
            cvss_v4_vs_confidentiality_impact=cvss_v4.vulnerableSystemConfidentiality,
            cvss_v4_ss_confidentiality_impact=cvss_v4.subsequentSystemConfidentiality,
            cvss_v4_vs_integrity_impact=cvss_v4.vulnerableSystemIntegrity,
            cvss_v4_ss_integrity_impact=cvss_v4.subsequentSystemIntegrity,
            cvss_v4_vs_availability_impact=cvss_v4.vulnerableSystemAvailability,
            cvss_v4_ss_availability_impact=cvss_v4.subsequentSystemAvailability,
            author=self.author,
            markings=[self.tlp_marking],
            external_references=[
                ExternalReference(
                    url=vulnerability_enrichment.intelCard,
                    source_name="RecordedFuture",
                )
            ],
        )

    def _convert_vulnerability_cpe_s(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[Software]:
        """Create OCTI Software objects from RecordedFuture vulnerability's CPE 2.3 list.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI Software objects
        """
        software_s = []
        for cpe_string in vulnerability_enrichment.cpe:
            try:
                cpe_dict = parse_cpe(cpe_string)
                software_s.append(
                    Software(
                        name=cpe_dict["product"],
                        vendor=cpe_dict["vendor"],
                        version=cpe_dict["version"],
                        cpe=cpe_string,
                        author=self.author,
                        markings=[
                            self._create_tlp_marking("green")
                        ],  # lower access right (default is "red")
                    )
                )
            except ValidationError as err:
                self.helper.connector_logger.error(
                    f"Recorded Future CPE skipped due to the following error: {err}",
                    {"err": err},
                )
                continue

        return software_s

    def _convert_vulnerability_analyst_notes(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[Report]:
        """Create OCTI reports and their related entities from RecordedFuture vulnerability's analyst notes.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI reports
        """
        octi_objects = []

        for analyst_note in vulnerability_enrichment.analystNotes or []:
            try:
                report_objects = []
                report_external_references = []
                for validation_url in analyst_note.attributes.validation_urls or []:
                    report_external_references.append(
                        ExternalReference(
                            source_name="Recorded Future",
                            url=validation_url.name,
                        )
                    )
                for note_entity in analyst_note.attributes.note_entities or []:
                    entity_type = note_entity.type
                    entity_value = note_entity.name
                    risk_score = vulnerability_enrichment.risk.score

                    match entity_type:
                        case "Company" | "Organization":
                            report_objects.append(
                                Organization(
                                    name=entity_value,
                                    author=self.author,
                                )
                            )
                        case "Person":
                            report_objects.append(
                                Individual(
                                    name=entity_value,
                                    author=self.author,
                                )
                            )
                        case "CyberVulnerability":
                            report_objects.append(
                                Vulnerability(
                                    name=entity_value,
                                    author=self.author,
                                )
                            )
                        case "MitreAttackIdentifier" | "ExternalIdentifier":
                            report_objects.append(
                                AttackPattern(
                                    name=entity_value,
                                    description=note_entity.description,
                                    author=self.author,
                                    markings=[self.tlp_marking],
                                )
                            )
                        case "ProductIdentifier" | "Product":
                            report_objects.append(
                                Software(
                                    name=entity_value,
                                    description=note_entity.description,
                                    author=self.author,
                                    markings=[self.tlp_marking],
                                )
                            )
                        case "Country":
                            report_objects.append(
                                Country(
                                    name=entity_value,
                                    author=self.author,
                                )
                            )
                        case "City":
                            report_objects.append(
                                City(
                                    name=entity_value,
                                    author=self.author,
                                )
                            )
                        case "Hash":
                            hash_algorithm = get_hash_algorithm(entity_value)

                            report_objects.append(
                                File(
                                    hashes={hash_algorithm: entity_value},
                                    author=self.author,
                                )
                            )
                            report_objects.append(
                                Indicator(
                                    name=entity_value,
                                    score=risk_score,
                                    pattern=f"[file:hashes.'{hash_algorithm}' = '{entity_value}']",
                                    pattern_type="stix",
                                    main_observable_type="StixFile",
                                    author=self.author,
                                )
                            )
                        case "InternetDomainName":
                            report_objects.append(
                                DomainName(
                                    value=entity_value,
                                    author=self.author,
                                )
                            )
                            report_objects.append(
                                Indicator(
                                    name=entity_value,
                                    score=risk_score,
                                    pattern=f"[domain-name:value = '{entity_value}']",
                                    pattern_type="stix",
                                    main_observable_type="Domain-Name",
                                    author=self.author,
                                )
                            )
                        case "IpAddress":
                            ip_version = validate_ip_or_cidr(entity_value)
                            if ip_version.startswith("IPv4"):
                                report_objects.append(
                                    IPV4Address(
                                        value=entity_value,
                                        author=self.author,
                                    )
                                )
                                report_objects.append(
                                    Indicator(
                                        name=entity_value,
                                        score=risk_score,
                                        pattern=f"[ipv4-addr:value = '{entity_value}']",
                                        pattern_type="stix",
                                        main_observable_type="IPv4-Addr",
                                        author=self.author,
                                    )
                                )
                            if ip_version.startswith("IPv6"):
                                report_objects.append(
                                    IPV6Address(
                                        value=entity_value,
                                        author=self.author,
                                    )
                                )
                                report_objects.append(
                                    Indicator(
                                        name=entity_value,
                                        score=risk_score,
                                        pattern=f"[ipv6-addr:value = '{entity_value}']",
                                        pattern_type="stix",
                                        main_observable_type="IPv6-Addr",
                                        author=self.author,
                                    )
                                )
                        case "URL":
                            report_objects.append(
                                URL(
                                    value=entity_value,
                                    author=self.author,
                                )
                            )
                            report_objects.append(
                                Indicator(
                                    name=entity_value,
                                    score=risk_score,
                                    pattern=f"[url:value = '{entity_value}']",
                                    pattern_type="stix",
                                    main_observable_type="Url",
                                    author=self.author,
                                )
                            )
                        case "Source":
                            report_external_references.append(
                                ExternalReference(
                                    source_name="Recorded Future",
                                    url=entity_value,
                                )
                            )
                        case _:
                            self.helper.connector_logger.warning(
                                f"Unsupported Recorded Future analyst note's entity type '{entity_type}'. "
                                "Skipped."
                            )

                report_type = None
                if analyst_note.attributes.topic:
                    report_type = REPORT_TYPES_BY_RF_TOPIC.get(
                        analyst_note.attributes.topic.name
                    )
                    if not report_type:
                        self.helper.connector_logger.warning(
                            f"Unsupported Recorded Future topic '{analyst_note.attributes.topic.name}'. "
                            "Report's type will not be set."
                        )

                octi_objects.append(
                    Report(
                        name=analyst_note.attributes.title,
                        publication_date=analyst_note.attributes.published,
                        description=analyst_note.attributes.text,
                        report_types=[report_type] if report_type else None,
                        labels=(
                            [analyst_note.attributes.topic.name]
                            if analyst_note.attributes.topic
                            else None
                        ),
                        objects=report_objects,
                        external_references=report_external_references,
                        author=self.author,
                        markings=[self.tlp_marking],
                    )
                )
            except ValidationError as err:
                self.helper.connector_logger.error(
                    f"Recorded Future analyst note skipped due to the following error: {err}",
                    {"err": err},
                )
                continue

        return octi_objects

    def _convert_vulnerability_risk(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[Note]:
        """Create OCTI Note objects from RecordedFuture vulnerability's risk data.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI notes
        """
        octi_objects = []

        note_markdown_table = (
            "  \n"
            "| Field | Value |  \n"
            "| --- | --- |  \n"
            f"| **Risk summary** | {vulnerability_enrichment.risk.riskSummary or '/'} |  \n"
            f"| **Risk String** | {vulnerability_enrichment.risk.riskString or '/'} |  \n"
            f"| **Rules** | {vulnerability_enrichment.risk.rules or '/'} |  \n"
            f"| **Criticality** | {vulnerability_enrichment.risk.criticality or '/'} |  \n"
            f"| **Criticality Label** | {vulnerability_enrichment.risk.criticalityLabel or '/'} |  \n"
            f"| **Score** | {vulnerability_enrichment.risk.score or '/'} |  \n"
            "  \n"
        )
        octi_objects.append(
            Note(
                abstract=vulnerability_enrichment.risk.riskSummary,
                publication_date=datetime.now(tz=timezone.utc),
                content=note_markdown_table,
                author=self.author,
                markings=[self.tlp_marking],
            )
        )

        for evidence in vulnerability_enrichment.risk.evidenceDetails or []:
            note_evidence_markdown_table = (
                "  \n"
                "| Field | Value |  \n"
                "| --- | --- |  \n"
                f"| **Evidence** | {evidence.evidenceString or '/'} |  \n"
                f"| **Mitigation** | {evidence.mitigationString or '/'} |  \n"
                f"| **Rule** | {evidence.rule or '/'} |  \n"
                f"| **Criticality** | {evidence.criticality or '/'} |  \n"
                f"| **Criticality Label** | {evidence.criticalityLabel or '/'} |  \n"
                f"| **Timestamp** | {evidence.timestamp or '/'} |  \n"
                "  \n"
            )
            octi_objects.append(
                Note(
                    abstract=evidence.evidenceString,
                    publication_date=evidence.timestamp,
                    content=note_evidence_markdown_table,
                    author=self.author,
                    markings=[self.tlp_marking],
                )
            )

        return octi_objects

    def _build_octi_objects_relationships(
        self,
        enriched_vulnerability: Vulnerability,
        octi_objects: list[BaseIdentifiedEntity],
    ) -> list[Relationship]:
        """Build relationships between enriched vulnerability and the other OCTI objects created from Recorded Future data.
        :param enriched_vulnerability: OCTI vulnerability being enriched
        :param octi_objects: OCTI objects to link to enriched vulnerability
        :return: A list of OCTI relationships
        """
        octi_relationships = []

        for octi_object in octi_objects:
            if octi_object.id == enriched_vulnerability.id:
                continue  # do not create loop relationships

            relationship = None
            match octi_object:
                case Software():
                    relationship = self._create_relationship(
                        relationship_type="has",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Organization() | Individual():
                    relationship = self._create_relationship(
                        relationship_type="related-to",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Vulnerability():
                    relationship = self._create_relationship(
                        relationship_type="related-to",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case AttackPattern() | Malware():
                    relationship = self._create_relationship(
                        relationship_type="targets",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Indicator():
                    if octi_object.main_observable_type == "StixFile":
                        observable = next(
                            obj
                            for obj in octi_objects
                            if isinstance(obj, File)
                            and octi_object.name in obj.hashes.values()
                        )
                    else:
                        observable = next(
                            obj
                            for obj in octi_objects
                            if isinstance(
                                obj,
                                (DomainName, IPV4Address, IPV6Address, URL),
                            )
                            and obj.value == octi_object.name
                        )
                    if observable:
                        relationship = self._create_relationship(
                            relationship_type="based-on",
                            source=octi_object,
                            target=observable,
                        )
            if relationship:
                octi_relationships.append(relationship)

        return octi_relationships

    def process_vulnerability_enrichment(
        self,
        octi_vulnerability_data: dict,
        vulnerability_enrichment: VulnerabilityEnrichment,
    ) -> list[BaseIdentifiedEntity]:
        """Create OCTI entities from RecordedFuture vulnerability's enrichment data.
        :param octi_vulnerability_data: Original data to enrich (as sent by OCTI)
        :param vulnerability_enrichment: RecordedFuture enrichment data
        :return: List of OCTI objects
        """
        try:
            octi_objects: list[BaseIdentifiedEntity] = []

            # Extract external references
            nvd_external_references = self._convert_vulnerability_nvd_references(
                vulnerability_enrichment
            )
            any_external_references = self._convert_vulnerability_related_links(
                vulnerability_enrichment
            )
            external_references = nvd_external_references + any_external_references

            # Extract vulnerability
            vulnerability = self._convert_vulnerability_cvss_s(
                vulnerability_enrichment,
                octi_vulnerability_data=octi_vulnerability_data,
            )
            vulnerability.external_references.extend(external_references)
            octi_objects.append(vulnerability)

            # Extract software_s
            software_s = self._convert_vulnerability_cpe_s(vulnerability_enrichment)
            octi_objects.extend(software_s)

            # Extract reports
            reports = self._convert_vulnerability_analyst_notes(
                vulnerability_enrichment
            )
            for report in reports:
                report.objects.extend([vulnerability] + software_s)
                report.external_references.extend(external_references)
                octi_objects.extend(report.objects)
                octi_objects.append(report)

            # Extract note
            notes = self._convert_vulnerability_risk(vulnerability_enrichment)
            for note in notes:
                note.objects = [vulnerability] + software_s
                note.external_references = external_references
                octi_objects.append(note)

            # Add relationships between entities
            octi_objects.extend(
                self._build_octi_objects_relationships(
                    enriched_vulnerability=vulnerability,
                    octi_objects=octi_objects,
                )
            )

            return [self.author, self.tlp_marking] + octi_objects
        except Exception as err:
            raise VulnerabilityEnrichmentError(
                f"An error occured during vulnerability enrichment: {err}"
            ) from err
