from datetime import datetime, timezone

from connectors_sdk.models.octi import (
    URL,
    AttackPattern,
    BaseIdentifiedEntity,
    DomainName,
    ExternalReference,
    File,
    Indicator,
    Individual,
    IPV4Address,
    IPV6Address,
    Malware,
    Note,
    Organization,
    OrganizationAuthor,
    Relationship,
    Software,
    TLPMarking,
    Vulnerability,
)
from connectors_sdk.models.octi.enums import TLPLevel
from pycti import OpenCTIConnectorHelper

# Import ValidationError from pydantic because it's the type of errors raised by connectors-sdk models
# In the near future, the error type should be imported from connectors-sdk exceptions module
from pydantic import ValidationError
from rf_client.models import VulnerabilityEnrichment
from rflib.rf_utils import parse_cpe


class VulnerabilityEnrichmentError(Exception):
    """Custom exception for error during enrichment of a vulnerability."""


class VulnerabilityEnricher:
    def __init__(self, helper: OpenCTIConnectorHelper, tlp_level: TLPLevel):
        self.helper = helper  # to import pycti logger
        self.author = self._create_author()
        self.tlp_marking = self._create_tlp_marking(tlp_level)

    def _create_author(self) -> OrganizationAuthor:
        """Create Recorded Future Author"""
        return OrganizationAuthor(name="Recorded Future")

    def _create_tlp_marking(self, tlp_level: TLPLevel = "red") -> TLPMarking:
        """Create a TLP Marking definition for OCTI objects imported from RecordedFuture."""
        return TLPMarking(level=tlp_level)

    def _create_relationship(
        self,
        relationship_type: str,
        source: BaseIdentifiedEntity,
        target: BaseIdentifiedEntity,
    ) -> Relationship:
        """Create a relationship between two entities."""
        return Relationship(
            type=relationship_type,
            source=source,
            target=target,
            author=self.author,
        )

    def _convert_vulnerability_nvd_references(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[ExternalReference]:
        """Create OCTI External References from RecordedFuture vulnerability's NVD references.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI External References
        """
        external_references = []
        for nvd_reference in vulnerability_enrichment.nvdReferences:
            if nvd_reference.url:
                external_references.append(
                    ExternalReference(
                        url=nvd_reference.url,
                        source_name="NVD",
                        description=vulnerability_enrichment.nvdDescription,
                    )
                )

        return external_references

    def _convert_vulnerability_related_links(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[ExternalReference]:
        """Create OCTI External References from RecordedFuture vulnerability's related links.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI External References
        """
        external_references = []
        for url in vulnerability_enrichment.relatedLinks:
            external_references.append(
                ExternalReference(
                    url=url,
                    source_name="Recorded Future",
                )
            )

        return external_references

    def _convert_vulnerability_cvss_s(
        self,
        vulnerability_enrichment: VulnerabilityEnrichment,
        octi_vulnerability_data: dict,
    ) -> Vulnerability:
        """Create OCTI Vulnerability from RecordedFuture vulnerability's CVSS data.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :param octi_vulnerability_data: Original vulnerability data on OCTI
        :return: An OCTI Vulnerability
        """
        # On RecordedFuture, CVSS are v2 by default
        cvss_v2 = vulnerability_enrichment.cvss
        cvss_v3 = vulnerability_enrichment.cvssv3
        cvss_v4 = vulnerability_enrichment.cvssv4

        vulnerability_description = (
            vulnerability_enrichment.aiInsights.text
            if vulnerability_enrichment.aiInsights
            else octi_vulnerability_data.get("description") or ""
        )
        for cvss_object in [cvss_v2, cvss_v3, cvss_v4]:
            cvss_source_name = getattr(cvss_object, "source", None)
            cvss_version = getattr(cvss_object, "version", "(unknown version)")
            if cvss_source_name:
                source_description = (
                    f"Source of CVSS {cvss_version}: {cvss_source_name}"
                )
                if source_description not in vulnerability_description:
                    vulnerability_description += f"  \n{source_description}"

        return Vulnerability(
            name=octi_vulnerability_data.get("name"),
            description=vulnerability_description,
            labels=[vulnerability_enrichment.lifecycleStage],
            aliases=vulnerability_enrichment.commonNames,
            score=vulnerability_enrichment.risk.score,
            cvss_v2_vector_string=cvss_v2.vectorString,
            cvss_v2_base_score=cvss_v2.score,
            cvss_v2_access_vector=cvss_v2.accessVector,
            cvss_v2_access_complexity=cvss_v2.accessComplexity,
            cvss_v2_authentication=cvss_v2.authentication,
            cvss_v2_confidentiality_impact=cvss_v2.confidentiality,
            cvss_v2_integrity_impact=cvss_v2.integrity,
            cvss_v2_availability_impact=cvss_v2.availability,
            cvss_v3_vector_string=cvss_v3.vectorString,
            cvss_v3_base_score=cvss_v3.baseScore,
            cvss_v3_base_severity=(
                cvss_v3.baseSeverity.upper() if cvss_v3.baseSeverity else None
            ),
            cvss_v3_attack_vector=cvss_v3.attackVector,
            cvss_v3_attack_complexity=cvss_v3.attackComplexity,
            cvss_v3_privileges_required=cvss_v3.privilegesRequired,
            cvss_v3_user_interaction=cvss_v3.userInteraction,
            cvss_v3_scope=cvss_v3.scope,
            cvss_v3_confidentiality_impact=cvss_v3.vectorString,
            cvss_v3_integrity_impact=cvss_v3.vectorString,
            cvss_v3_availability_impact=cvss_v3.vectorString,
            cvss_v4_vector_string=cvss_v4.vectorString,
            cvss_v4_base_score=cvss_v4.baseScore,
            cvss_v4_base_severity=(
                cvss_v4.baseSeverity.upper() if cvss_v4.baseSeverity else None
            ),
            cvss_v4_attack_vector=cvss_v4.attackVector,
            cvss_v4_attack_complexity=cvss_v4.attackComplexity,
            cvss_v4_attack_requirements=cvss_v4.attackRequirements,
            cvss_v4_privileges_required=cvss_v4.privilegesRequired,
            cvss_v4_user_interaction=cvss_v4.userInteraction,
            cvss_v4_vs_confidentiality_impact=cvss_v4.vulnerableSystemConfidentiality,
            cvss_v4_ss_confidentiality_impact=cvss_v4.subsequentSystemConfidentiality,
            cvss_v4_vs_integrity_impact=cvss_v4.vulnerableSystemIntegrity,
            cvss_v4_ss_integrity_impact=cvss_v4.subsequentSystemIntegrity,
            cvss_v4_vs_availability_impact=cvss_v4.vulnerableSystemAvailability,
            cvss_v4_ss_availability_impact=cvss_v4.subsequentSystemAvailability,
            author=self.author,
            markings=[self.tlp_marking],
            external_references=[
                ExternalReference(
                    url=vulnerability_enrichment.intelCard,
                    source_name="RecordedFuture",
                )
            ],
        )

    def _convert_vulnerability_cpe_s(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[Software]:
        """Create OCTI Software objects from RecordedFuture vulnerability's CPE 2.3 list.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI Software objects
        """
        software_s = []
        for cpe_string in vulnerability_enrichment.cpe:
            try:
                cpe_dict = parse_cpe(cpe_string)
                software_s.append(
                    Software(
                        name=cpe_dict["product"],
                        vendor=cpe_dict["vendor"],
                        version=cpe_dict["version"],
                        cpe=cpe_string,
                        author=self.author,
                        markings=[
                            self._create_tlp_marking("green")
                        ],  # lower access right (default is "red")
                    )
                )
            except ValidationError as err:
                self.helper.connector_logger.error(
                    f"Recorded Future CPE skipped due to the following error: {err}",
                    {"err": err},
                )
                continue

        return software_s

    def _convert_vulnerability_risk(
        self, vulnerability_enrichment: VulnerabilityEnrichment
    ) -> list[Note]:
        """Create OCTI Note objects from RecordedFuture vulnerability's risk data.
        :param vulnerability_enrichment: RecordedFuture vulnerability's enrichment data
        :return: A list of OCTI notes
        """
        octi_objects = []

        note_markdown_table = (
            "  \n"
            "| Field | Value |  \n"
            "| --- | --- |  \n"
            f"| **Risk summary** | {vulnerability_enrichment.risk.riskSummary or '/'} |  \n"
            f"| **Risk String** | {vulnerability_enrichment.risk.riskString or '/'} |  \n"
            f"| **Rules** | {vulnerability_enrichment.risk.rules or '/'} |  \n"
            f"| **Criticality** | {vulnerability_enrichment.risk.criticality or '/'} |  \n"
            f"| **Criticality Label** | {vulnerability_enrichment.risk.criticalityLabel or '/'} |  \n"
            f"| **Score** | {vulnerability_enrichment.risk.score or '/'} |  \n"
            "  \n"
        )
        octi_objects.append(
            Note(
                abstract=vulnerability_enrichment.risk.riskSummary,
                publication_date=datetime.now(tz=timezone.utc),
                content=note_markdown_table,
                author=self.author,
                markings=[self.tlp_marking],
            )
        )

        for evidence in vulnerability_enrichment.risk.evidenceDetails or []:
            note_evidence_markdown_table = (
                "  \n"
                "| Field | Value |  \n"
                "| --- | --- |  \n"
                f"| **Evidence** | {evidence.evidenceString or '/'} |  \n"
                f"| **Mitigation** | {evidence.mitigationString or '/'} |  \n"
                f"| **Rule** | {evidence.rule or '/'} |  \n"
                f"| **Criticality** | {evidence.criticality or '/'} |  \n"
                f"| **Criticality Label** | {evidence.criticalityLabel or '/'} |  \n"
                f"| **Timestamp** | {evidence.timestamp or '/'} |  \n"
                "  \n"
            )
            octi_objects.append(
                Note(
                    abstract=evidence.evidenceString,
                    publication_date=evidence.timestamp,
                    content=note_evidence_markdown_table,
                    author=self.author,
                    markings=[self.tlp_marking],
                )
            )

        return octi_objects

    def _build_octi_objects_relationships(
        self,
        enriched_vulnerability: Vulnerability,
        octi_objects: list[BaseIdentifiedEntity],
    ) -> list[Relationship]:
        """Build relationships between enriched vulnerability and the other OCTI objects created from Recorded Future data.
        :param enriched_vulnerability: OCTI vulnerability being enriched
        :param octi_objects: OCTI objects to link to enriched vulnerability
        :return: A list of OCTI relationships
        """
        octi_relationships = []

        for octi_object in octi_objects:
            if octi_object.id == enriched_vulnerability.id:
                continue  # do not create loop relationships

            relationship = None
            match octi_object:
                case Software():
                    relationship = self._create_relationship(
                        relationship_type="has",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Organization() | Individual():
                    relationship = self._create_relationship(
                        relationship_type="related-to",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Vulnerability():
                    relationship = self._create_relationship(
                        relationship_type="related-to",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case AttackPattern() | Malware():
                    relationship = self._create_relationship(
                        relationship_type="targets",
                        source=octi_object,
                        target=enriched_vulnerability,
                    )
                case Indicator():
                    if octi_object.main_observable_type == "StixFile":
                        observable = next(
                            obj
                            for obj in octi_objects
                            if isinstance(obj, File)
                            and octi_object.name in obj.hashes.values()
                        )
                    else:
                        observable = next(
                            obj
                            for obj in octi_objects
                            if isinstance(
                                obj,
                                (DomainName, IPV4Address, IPV6Address, URL),
                            )
                            and obj.value == octi_object.name
                        )
                    if observable:
                        relationship = self._create_relationship(
                            relationship_type="based-on",
                            source=octi_object,
                            target=observable,
                        )
            if relationship:
                octi_relationships.append(relationship)

        return octi_relationships

    def process_vulnerability_enrichment(
        self,
        octi_vulnerability_data: dict,
        vulnerability_enrichment: VulnerabilityEnrichment,
    ) -> list[BaseIdentifiedEntity]:
        """Create OCTI entities from RecordedFuture vulnerability's enrichment data.
        :param octi_vulnerability_data: Original data to enrich (as sent by OCTI)
        :param vulnerability_enrichment: RecordedFuture enrichment data
        :return: List of OCTI objects
        """
        try:
            octi_objects: list[BaseIdentifiedEntity] = []

            # Extract external references
            nvd_external_references = self._convert_vulnerability_nvd_references(
                vulnerability_enrichment
            )
            any_external_references = self._convert_vulnerability_related_links(
                vulnerability_enrichment
            )
            external_references = nvd_external_references + any_external_references

            # Extract vulnerability
            vulnerability = self._convert_vulnerability_cvss_s(
                vulnerability_enrichment,
                octi_vulnerability_data=octi_vulnerability_data,
            )
            vulnerability.external_references.extend(external_references)
            octi_objects.append(vulnerability)

            # Extract software_s
            software_s = self._convert_vulnerability_cpe_s(vulnerability_enrichment)
            octi_objects.extend(software_s)

            # Extract note
            notes = self._convert_vulnerability_risk(vulnerability_enrichment)
            for note in notes:
                note.objects = [vulnerability]
                octi_objects.append(note)

            # Add relationships between entities
            octi_objects.extend(
                self._build_octi_objects_relationships(
                    enriched_vulnerability=vulnerability,
                    octi_objects=octi_objects,
                )
            )

            return [self.author, self.tlp_marking] + octi_objects
        except Exception as err:
            raise VulnerabilityEnrichmentError(
                f"An error occured during vulnerability enrichment: {err}"
            ) from err
