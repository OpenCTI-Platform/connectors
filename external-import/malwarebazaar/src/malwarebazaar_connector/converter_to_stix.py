import stix2
import validators
from pycti import Identity, Indicator, MarkingDefinition, StixCoreRelationship


class ConverterToStix:
    """
    Provides methods for converting various types of input data into STIX 2.1 objects.

    REQUIREMENTS:
    - generate_id() for each entity from OpenCTI pycti library except observables to create
    """

    def __init__(self, helper, config):
        self.helper = helper
        self.config = config
        self.author = self.create_author(self.helper.connect_name)
        self.tlp_marking = self._create_tlp_marking(level=self.config.tlp_level.lower())

    @staticmethod
    def create_author(connector_name: str) -> dict:
        """
        Create Author based on configured CONNECTOR_NAME
        :return: Author in Stix2 object
        """
        # Allocate an Author Organization of based on CONNECTOR_NAME for the connector to use
        author = stix2.Identity(
            id=Identity.generate_id(name=connector_name, identity_class="organization"),
            name=connector_name,
            identity_class="organization",
            description="For more info, see https://bazaar.abuse.ch/about/",
            custom_properties={
                "x_opencti_organization_type": "vendor",
            },
        )
        return author

    @staticmethod
    def _create_tlp_marking(level) -> str:
        mapping = {
            "white": stix2.TLP_WHITE,
            "clear": stix2.TLP_WHITE,
            "green": stix2.TLP_GREEN,
            "amber": stix2.TLP_AMBER,
            "amber+strict": stix2.MarkingDefinition(
                id=MarkingDefinition.generate_id("TLP", "TLP:AMBER+STRICT"),
                definition_type="statement",
                definition={"statement": "custom"},
                custom_properties={
                    "x_opencti_definition_type": "TLP",
                    "x_opencti_definition": "TLP:AMBER+STRICT",
                },
            ),
            "red": stix2.TLP_RED,
        }
        return mapping[level]

    def create_file_observable(self, entity: dict, labels: list) -> dict:
        """
        Creates File Observable object based on MalwareBazaar Entity Data
        :param entity: entity dict from MalwareBazaar
        :param labels: List of Labels/Tags to apply
        :return: File Observable STIX2 object
        """
        file_observable = stix2.File(
            name=entity["file_name"],
            size=entity["file_size"],
            mime_type=entity["file_type_mime"],
            hashes={
                "MD5": entity["md5_hash"],
                "SHA-1": entity["sha1_hash"],
                "SHA-256": entity["sha256_hash"],
                # "SHA-512": entity["sha512_hash"], # API for MalwareBazaar currently does NOT provide a SHA512
            },
            object_marking_refs=self.tlp_marking,
            custom_properties={
                "x_opencti_created_by_ref": self.author["id"],
                # "x_opencti_external_references": self.external_reference,
                "x_opencti_additional_names": [
                    entity["sha256_hash"],
                    # entity["file_name"],
                ],
                "x_opencti_score": int(self.config.x_opencti_score),
                "x_opencti_description": f'Uploaded to MalwareBazaar by Twitter user: {entity["reporter"]}',
                "x_opencti_labels": labels,
            },
        )

        return file_observable

    def create_indicator(self, entity: dict, labels: list) -> dict:
        """
        Creates Indicator object based on File SHA256
        :param entity: entity dict from MalwareBazaar
        :param labels: List of Labels/Tags to apply
        :return: Indicator STIX2 object
        """
        indicator_pattern = f"[file:hashes.'SHA-256' = '{entity['sha256_hash']}']"
        indicator_description = f"Indicator for hash SHA256 {entity['sha256_hash']}"
        indicator = stix2.Indicator(
            id=Indicator.generate_id(indicator_pattern),
            name=f"{entity['sha256_hash']}",
            pattern=indicator_pattern,
            pattern_type="stix",
            description=indicator_description,
            labels=labels,
            created_by_ref=self.author["id"],
            object_marking_refs=self.tlp_marking,
            custom_properties={
                "x_opencti_score": int(self.config.x_opencti_score),
                "x_opencti_main_observable_type": "File",
            },
        )

        return indicator

    def create_relationship(
        self, source_id: str, relationship_type: str, target_id: str, labels: list
    ) -> dict:
        """
        Creates Relationship object
        :param source_id: ID of source in string
        :param relationship_type: Relationship type in string
        :param target_id: ID of target in string
        :param labels: List of Labels/Tags to apply
        :return: Relationship STIX2 object
        """
        relationship = stix2.Relationship(
            id=StixCoreRelationship.generate_id(
                relationship_type, source_id, target_id
            ),
            relationship_type=relationship_type,
            source_ref=source_id,
            target_ref=target_id,
            labels=labels,
            created_by_ref=self.author["id"],
            object_marking_refs=self.tlp_marking,
            # external_references=self.external_reference,
        )
        return relationship

    @staticmethod
    def _is_valid_md5(value: str) -> bool:
        """
        Determine whether the string is a valid MD5
        :param value: Value in string
        :return: A boolean
        """
        if validators.hashes.md5(value):
            return True
        else:
            return False

    @staticmethod
    def _is_valid_sha1(value: str) -> bool:
        """
        Determine whether the string is a valid SHA1
        :param value: Value in string
        :return: A boolean
        """
        if validators.hashes.sha1(value):
            return True
        else:
            return False

    @staticmethod
    def _is_valid_sha256(value: str) -> bool:
        """
        Determine whether the string is a valid SHA256
        :param value: Value in string
        :return: A boolean
        """
        if validators.hashes.sha256(value):
            return True
        else:
            return False

    @staticmethod
    def _is_valid_sha512(value: str) -> bool:
        """
        Determine whether the string is a valid SHA512
        :param value: Value in string
        :return: A boolean
        """
        if validators.hashes.sha512(value):
            return True
        else:
            return False

    def create_obs(self, entity: dict) -> dict:
        """
        Create observable according to given file data
        :param dict: Returned JSON Dict from Malware Bazaar of a malicious file object
        :return: Stix object for StixFile
        """
        file_observable_set = {
            "FILE_OBSERVABLE": None,
            "INDICATOR_4_FILE": None,
            "FILE_2_INDICATOR_RELATIONSHIP": None,
        }
        if (
            self._is_valid_md5(entity["md5_hash"]) is True
            and self._is_valid_sha1(entity["sha1_hash"]) is True
            and self._is_valid_sha256(entity["sha256_hash"]) is True
            and len(entity["reporter"]) >= 1
            and len(entity["file_name"]) >= 1
        ):
            # Customize the tags/labels to apply
            tags_as_labels = entity["tags"] if entity["tags"] else []
            if self.config.labels:
                labels = self.config.labels.split(",")
                for label in labels:
                    tags_as_labels.append(label)

            # Create the STIX File observable object
            file_observable = self.create_file_observable(
                entity=entity, labels=tags_as_labels
            )

            # Create Indicator based on SHA256 of File
            indicator = self.create_indicator(entity=entity, labels=tags_as_labels)

            # Create Relationship between Indicator and File Observable
            relationship = self.create_relationship(
                source_id=indicator["id"],
                relationship_type="based-on",
                target_id=file_observable["id"],
                labels=tags_as_labels,
            )

            # Define set of data to return
            file_observable_set = {
                "FILE_OBSERVABLE": file_observable,
                "INDICATOR_4_FILE": indicator,
                "FILE_2_INDICATOR_RELATIONSHIP": relationship,
            }

        else:
            self.helper.connector_logger.error(
                "This observable entity is not a valid for ingest, missing one or more required fields (md5_hash, sha1_hash, sha256_hash, reporter, or filename): ",
                {"entity": entity},
            )

        return file_observable_set
