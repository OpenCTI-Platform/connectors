"""Module to test the threat actor malware import feature end-to-end (MVP4)."""

import json
from os import environ as os_environ
from pathlib import Path
from typing import Any
from unittest.mock import MagicMock
from uuid import uuid4

import pytest
from conftest import mock_env_vars
from crowdstrike_feeds_connector.actor.builder import ActorBundleBuilder
from crowdstrike_feeds_connector.actor.importer import ActorImporter
from models.configs.config_loader import ConfigLoader
from stix2 import TLP_AMBER, Bundle, Identity, MarkingDefinition

# =====================
# Fixtures
# =====================


@pytest.fixture
def fake_actor_data() -> dict:
    """Load fake actor data from JSON file."""
    faker_dir = Path(__file__).parent.parent / "faker"
    with open(faker_dir / "api_actor.json", "r") as f:
        data = json.load(f)
        return data["body"]["resources"][0]


@pytest.fixture
def fake_actor_data_without_malware(fake_actor_data: dict) -> dict:
    """Sample actor data without malware fields."""
    actor_without_malware = fake_actor_data.copy()
    actor_without_malware["uses_threats"] = None
    actor_without_malware["develops_threats"] = None
    return actor_without_malware


@pytest.fixture
def author_identity() -> Identity:
    """Create author identity."""
    return Identity(  # pylint: disable=W9101 # it's a test no real ingest
        name="CrowdStrike",
        identity_class="organization",
    )


@pytest.fixture
def tlp_marking() -> MarkingDefinition:
    """Create TLP marking."""
    return TLP_AMBER


@pytest.fixture
def mock_helper() -> MagicMock:
    """Mock OpenCTI helper."""
    helper = MagicMock()
    helper.api.work.to_processed = MagicMock(return_value="processed_id")
    return helper


@pytest.fixture
def crowdstrike_config_standard() -> dict[str, str]:
    """Fixture for standard CrowdStrike configuration."""
    return {
        "OPENCTI_URL": "http://localhost:8080",
        "OPENCTI_TOKEN": f"{uuid4()}",
        "CONNECTOR_ID": f"{uuid4()}",
        "CONNECTOR_NAME": "CrowdStrike Test",
        "CONNECTOR_SCOPE": "crowdstrike",
        "CROWDSTRIKE_BASE_URL": "https://api.crowdstrike.com",
        "CROWDSTRIKE_CLIENT_ID": f"{uuid4()}",
        "CROWDSTRIKE_CLIENT_SECRET": f"{uuid4()}",
        "CROWDSTRIKE_MALWARE_AS_FAMILY": "true",
    }


# =====================
# Tests
# =====================


def test_import_malware_for_threat_actor(
    crowdstrike_config_standard: dict[str, str],
    fake_actor_data: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_helper: MagicMock,
) -> None:
    """
    Feature: Threat Actor Malware Relationships
      As a Threat Intel Analyst
      I want to see malware used and developed by threat actors
      Because understanding actor toolsets is essential for threat hunting

    Scenario: Import malware from existing fields
    """
    # Given the Crowdstrike API already provides uses_threats and develops_threats in actor data
    mock_env, config, actor_with_malware = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data
    )

    try:
        # When the System imports the actor
        bundle = _when_the_system_imports_an_actor(
            actor_data=actor_with_malware,
            author=author_identity,
            tlp_marking=tlp_marking,
            helper=mock_helper,
        )

        # Then the System creates Malware entities from these existing fields
        _then_system_creates_malware_entities(bundle, actor_with_malware)

        # And the Threat Intel Analyst sees proper malware relationships
        _then_analyst_sees_proper_malware_relationships(bundle, actor_with_malware)
    finally:
        mock_env.stop()


def test_distinguish_used_vs_developed_malware(
    crowdstrike_config_standard: dict[str, str],
    fake_actor_data: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_helper: MagicMock,
) -> None:
    """
    Feature: Threat Actor Malware Relationships
      As a Threat Intel Analyst
      I want to distinguish between used and developed malware
      Because this helps understand actor capabilities and attribution

    Scenario: Distinguish used vs developed malware
    """
    # Given the actor data contains both uses_threats and develops_threats
    mock_env, config, actor_data = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data
    )

    try:
        # When the System processes the actor
        bundle = _when_the_system_imports_an_actor(
            actor_data=actor_data,
            author=author_identity,
            tlp_marking=tlp_marking,
            helper=mock_helper,
        )

        # Then the System creates "uses" relationships for uses_threats
        _then_system_creates_uses_relationships(bundle, actor_data)

        # And the System creates "authored-by" relationships for develops_threats
        _then_system_creates_authored_by_relationships(bundle, actor_data)
    finally:
        mock_env.stop()


def test_handle_actors_without_malware(
    crowdstrike_config_standard: dict[str, str],
    fake_actor_data_without_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_helper: MagicMock,
) -> None:
    """
    Feature: Handle Actors Without Malware
      As the System
      I want to handle actors that don't have malware data
      Because not all actors have documented malware relationships

    Scenario: Import actor without malware data
    """
    # Given the Crowdstrike API returns actor without malware data
    mock_env, config, actor_without_malware = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data_without_malware
    )

    try:
        # When the System imports actor without malware
        bundle = _when_the_system_imports_an_actor(
            actor_data=actor_without_malware,
            author=author_identity,
            tlp_marking=tlp_marking,
            helper=mock_helper,
        )

        # Then the System creates actor without malware relationships
        _then_system_creates_actor_without_malware_relationships(bundle)

        # And the Threat Intel Analyst sees actor without malware
        _then_analyst_sees_actor_without_malware(bundle)
    finally:
        mock_env.stop()


def test_access_existing_malware_fields(
    crowdstrike_config_standard: dict[str, str], fake_actor_data: dict
) -> None:
    """
    Feature: Access Existing Malware Data
      As the System
      I want to use the existing malware fields in actor data
      Because these fields are already available but not being processed

    Scenario: Read threat fields from actor
    """
    # Given the actor data already contains uses_threats and develops_threats
    mock_env, config, actor_data = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data
    )

    try:
        # When the System processes actor data
        uses_threats, develops_threats = _when_system_processes_actor_data(actor_data)

        # Then the System reads actor["uses_threats"] and actor["develops_threats"]
        _then_system_reads_threat_fields(uses_threats, develops_threats, actor_data)

        # And the System extracts family_name from each entry
        _then_system_extracts_family_names(uses_threats, develops_threats)
    finally:
        mock_env.stop()


def test_create_malware_from_existing_fields(
    crowdstrike_config_standard: dict[str, str],
    fake_actor_data: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
) -> None:
    """
    Feature: Create Malware from Existing Fields
      As the System
      I want to create Malware entities from the threat fields
      Because the data is already there, just not being used

    Scenario: Create malware families
    """
    # Given the System has uses_threats and develops_threats data
    mock_env, config, actor_data = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data
    )

    try:
        # When the System builds the actor bundle
        bundle = _when_the_system_imports_an_actor(
            actor_data, author_identity, tlp_marking
        )

        # Then the System creates Malware entities with is_family=True
        _then_system_creates_malware_entities_with_family_flag(bundle, actor_data)

        # And each malware has name=family_name from the field
        _then_each_malware_has_correct_family_name(bundle, actor_data)
    finally:
        mock_env.stop()


def test_create_malware_relationships(
    crowdstrike_config_standard: dict[str, str],
    fake_actor_data: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
) -> None:
    """
    Feature: Create Malware Relationships
      As the System
      I want to create relationships based on the threat type
      Because we need to distinguish between used and developed malware

    Scenario: Create uses and authorship relationships
    """
    # Given the System has malware from both uses_threats and develops_threats fields
    mock_env, config, actor_data = _given_actor_data(
        crowdstrike_config_standard, fake_actor_data
    )

    try:
        # When the System builds relationships
        bundle = _when_the_system_imports_an_actor(
            actor_data, author_identity, tlp_marking
        )

        # Then the System creates IntrusionSet-uses-Malware relationships
        _then_system_creates_intrusion_set_uses_malware_relationships(
            bundle, actor_data
        )

        # And the System creates Malware-authored-by-IntrusionSet relationships
        _then_system_creates_malware_authored_by_intrusion_set_relationships(
            bundle, actor_data
        )
    finally:
        mock_env.stop()


# Given helper functions
def _given_actor_data(
    config_data: dict[str, str], actor_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given the actor data with appropriate assertions based on content."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    # Check that threat fields exist in the data structure
    assert "uses_threats" in actor_data  # noqa: S101
    assert "develops_threats" in actor_data  # noqa: S101

    # The data can have None values (for actors without malware)
    # or actual list values (for actors with malware)
    if actor_data["uses_threats"] is not None:
        assert isinstance(actor_data["uses_threats"], list)  # noqa: S101
        if len(actor_data["uses_threats"]) > 0:
            for threat in actor_data["uses_threats"]:
                assert "family_name" in threat  # noqa: S101

    if actor_data["develops_threats"] is not None:
        assert isinstance(actor_data["develops_threats"], list)  # noqa: S101
        if len(actor_data["develops_threats"]) > 0:
            for threat in actor_data["develops_threats"]:
                assert "family_name" in threat  # noqa: S101

    return mock_env, config, actor_data


# When helper functions
def _when_the_system_imports_an_actor(
    actor_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    helper: MagicMock | None = None,
) -> Bundle:
    """When the System imports the actor."""
    if helper is None:
        helper = MagicMock()
        helper.api.work.to_processed = MagicMock(return_value="processed_id")

    importer = ActorImporter(
        helper=helper,
        author=author,
        default_latest_timestamp=0,
        tlp_marking=tlp_marking,
    )

    malware = importer._get_and_create_malware(actor_data)

    builder = ActorBundleBuilder(
        actor=actor_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        confidence_level=80,
        malware=malware,
    )

    return builder.build()


def _when_system_processes_actor_data(actor_data: dict) -> tuple:
    """When the System processes actor data."""
    uses_threats = actor_data.get("uses_threats", [])
    develops_threats = actor_data.get("develops_threats", [])

    return uses_threats, develops_threats


# Then helper functions
def _then_system_creates_malware_entities(bundle: Bundle, actor_data: dict) -> None:
    """Then the System creates Malware entities from these existing fields."""
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    uses_names = (
        {threat["family_name"] for threat in actor_data["uses_threats"]}
        if actor_data["uses_threats"]
        else set()
    )
    develops_names = (
        {threat["family_name"] for threat in actor_data["develops_threats"]}
        if actor_data["develops_threats"]
        else set()
    )
    expected_unique_names = uses_names | develops_names
    expected_malware_count = len(expected_unique_names)

    assert len(malware_objects) == expected_malware_count  # noqa: S101

    for malware in malware_objects:
        assert hasattr(malware, "name")  # noqa: S101
        assert hasattr(malware, "is_family")  # noqa: S101
        assert malware.is_family is True  # noqa: S101


def _then_analyst_sees_proper_malware_relationships(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then the Threat Intel Analyst sees proper malware relationships."""
    relationships = [obj for obj in bundle.objects if obj.type == "relationship"]
    malware_relationships = [
        rel for rel in relationships if rel.relationship_type in ["uses", "authored-by"]
    ]

    expected_uses_count = (
        len(actor_data["uses_threats"]) if actor_data["uses_threats"] else 0
    )
    expected_authored_count = (
        len(actor_data["develops_threats"]) if actor_data["develops_threats"] else 0
    )
    expected_total = expected_uses_count + expected_authored_count

    assert len(malware_relationships) == expected_total  # noqa: S101


def _then_system_creates_uses_relationships(bundle: Bundle, actor_data: dict) -> None:
    """Then the System creates "uses" relationships for uses_threats."""
    uses_relationships = [
        obj
        for obj in bundle.objects
        if obj.type == "relationship" and obj.relationship_type == "uses"
    ]

    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]
    malware_uses_relationships = [
        rel
        for rel in uses_relationships
        if any(malware.id == rel.target_ref for malware in malware_objects)
    ]

    expected_count = (
        len(actor_data["uses_threats"]) if actor_data["uses_threats"] else 0
    )

    assert len(malware_uses_relationships) == expected_count  # noqa: S101


def _then_system_creates_authored_by_relationships(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then the System creates "authored-by" relationships for develops_threats."""
    authored_by_relationships = [
        obj
        for obj in bundle.objects
        if obj.type == "relationship" and obj.relationship_type == "authored-by"
    ]

    expected_count = (
        len(actor_data["develops_threats"]) if actor_data["develops_threats"] else 0
    )

    assert len(authored_by_relationships) == expected_count  # noqa: S101


def _then_system_creates_actor_without_malware_relationships(bundle: Bundle) -> None:
    """Then the System creates actor without malware relationships."""
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]
    malware_relationships = [
        obj
        for obj in bundle.objects
        if obj.type == "relationship"
        and obj.relationship_type in ["uses", "authored-by"]
    ]

    malware_uses_relationships = [
        rel
        for rel in malware_relationships
        if rel.relationship_type == "uses"
        and any(malware.id == rel.target_ref for malware in malware_objects)
    ]
    malware_authored_relationships = [
        rel
        for rel in malware_relationships
        if rel.relationship_type == "authored-by"
        and any(malware.id == rel.source_ref for malware in malware_objects)
    ]

    assert len(malware_objects) == 0  # noqa: S101
    assert len(malware_uses_relationships) == 0  # noqa: S101
    assert len(malware_authored_relationships) == 0  # noqa: S101


def _then_analyst_sees_actor_without_malware(bundle: Bundle) -> None:
    """Then the Threat Intel Analyst sees actor without malware."""
    intrusion_sets = [obj for obj in bundle.objects if obj.type == "intrusion-set"]
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    assert len(intrusion_sets) > 0  # noqa: S101
    assert len(malware_objects) == 0  # noqa: S101


def _then_system_reads_threat_fields(
    uses_threats: list, develops_threats: list, actor_data: dict
) -> None:
    """Then the System reads actor["uses_threats"] and actor["develops_threats"]."""
    assert uses_threats == actor_data["uses_threats"]  # noqa: S101
    assert develops_threats == actor_data["develops_threats"]  # noqa: S101


def _then_system_extracts_family_names(
    uses_threats: list, develops_threats: list
) -> None:
    """Then the System extracts family_name from each entry."""
    for threat in uses_threats or []:
        assert "family_name" in threat  # noqa: S101
        assert threat["family_name"] is not None  # noqa: S101
        assert len(threat["family_name"]) > 0  # noqa: S101

    for threat in develops_threats or []:
        assert "family_name" in threat  # noqa: S101
        assert threat["family_name"] is not None  # noqa: S101
        assert len(threat["family_name"]) > 0  # noqa: S101


def _then_system_creates_malware_entities_with_family_flag(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then the System creates Malware entities with is_family=True."""
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    for malware in malware_objects:
        assert malware.is_family is True  # noqa: S101


def _then_each_malware_has_correct_family_name(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then each malware has name=family_name from the field."""
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    expected_names = set()
    if actor_data["uses_threats"]:
        for threat in actor_data["uses_threats"]:
            expected_names.add(threat["family_name"])
    if actor_data["develops_threats"]:
        for threat in actor_data["develops_threats"]:
            expected_names.add(threat["family_name"])

    actual_names = {malware.name for malware in malware_objects}

    assert actual_names == expected_names  # noqa: S101


def _then_system_creates_intrusion_set_uses_malware_relationships(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then the System creates IntrusionSet-uses-Malware relationships."""
    uses_relationships = [
        obj
        for obj in bundle.objects
        if obj.type == "relationship" and obj.relationship_type == "uses"
    ]

    intrusion_set = next(
        (obj for obj in bundle.objects if obj.type == "intrusion-set"), None
    )
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    assert intrusion_set is not None  # noqa: S101

    malware_uses_relationships = [
        rel
        for rel in uses_relationships
        if rel.source_ref == intrusion_set.id
        and any(malware.id == rel.target_ref for malware in malware_objects)
    ]

    expected_uses_count = (
        len(actor_data["uses_threats"]) if actor_data["uses_threats"] else 0
    )
    assert len(malware_uses_relationships) == expected_uses_count  # noqa: S101


def _then_system_creates_malware_authored_by_intrusion_set_relationships(
    bundle: Bundle, actor_data: dict
) -> None:
    """Then the System creates Malware-authored-by-IntrusionSet relationships."""
    authored_by_relationships = [
        obj
        for obj in bundle.objects
        if obj.type == "relationship" and obj.relationship_type == "authored-by"
    ]

    intrusion_set = next(
        (obj for obj in bundle.objects if obj.type == "intrusion-set"), None
    )
    malware_objects = [obj for obj in bundle.objects if obj.type == "malware"]

    assert intrusion_set is not None  # noqa: S101

    malware_authored_relationships = [
        rel
        for rel in authored_by_relationships
        if rel.target_ref == intrusion_set.id
        and any(malware.id == rel.source_ref for malware in malware_objects)
    ]

    expected_authored_count = (
        len(actor_data["develops_threats"]) if actor_data["develops_threats"] else 0
    )
    assert len(malware_authored_relationships) == expected_authored_count  # noqa: S101
