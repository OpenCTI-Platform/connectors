# -*- coding: utf-8 -*-
"""MVP5: Malware Data Collection Import - Focused BDD Tests

Tests cover the essential scenarios from MVP.md:
1. Import malware from collection
2. Import malware with relationships
3. MITRE ATT&CK mapping
4. Sector targeting
"""

import json
from unittest.mock import Mock

import pytest
from crowdstrike_feeds_connector.malware.builder import MalwareBundleBuilder
from crowdstrike_feeds_connector.malware.importer import MalwareImporter
from crowdstrike_feeds_services.utils import create_organization
from crowdstrike_feeds_services.utils.constants import DEFAULT_TLP_MARKING_DEFINITION


# Test fixtures
@pytest.fixture
def fake_malware_data():
    """Basic malware data from faker JSON file."""
    import os

    faker_path = os.path.join(
        os.path.dirname(__file__), "..", "faker", "api_malware.json"
    )
    with open(faker_path, "r") as f:
        data = json.load(f)
    return data["resources"][0]


@pytest.fixture
def author_identity():
    """Create author identity."""
    return create_organization("CrowdStrike")


@pytest.fixture
def tlp_marking():
    """Create TLP marking."""
    return DEFAULT_TLP_MARKING_DEFINITION


@pytest.fixture
def mock_helper():
    """Mock OpenCTI helper."""
    return Mock()


# MVP5 Core Tests
def test_import_malware_from_collection(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Scenario: Import malware from collection
    Given the Crowdstrike API provides a malware collection endpoint
    When the System runs the malware importer
    Then the System creates Malware entities with all attributes
    """
    # Given
    malware_data = _given_crowdstrike_provides_malware_collection([fake_malware_data])

    # When
    bundle = _when_system_imports_malware_collection(
        malware_data, author_identity, tlp_marking
    )

    # Then
    _then_system_creates_malware_entities(bundle, fake_malware_data)


def test_import_malware_with_mitre_relationships(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Scenario: Import malware with relationships
    Given the Crowdstrike API provides malware with MITRE data
    When the System imports a malware
    Then the System creates uses relationships to AttackPatterns
    """
    # Given
    malware_data = _given_malware_has_mitre_data(fake_malware_data)

    # When
    bundle = _when_system_processes_malware_with_mitre(
        malware_data, author_identity, tlp_marking
    )

    # Then
    _then_system_creates_attack_patterns(bundle)
    _then_system_creates_uses_relationships(bundle)


def test_malware_bundle_builder_core_functionality(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Scenario: Build STIX malware bundle
    Given the Crowdstrike API returns malware data
    When the System processes the malware
    Then the System creates STIX Malware with proper attributes
    """
    # Given
    malware_data = _given_crowdstrike_returns_malware_data(fake_malware_data)

    # When
    malware_entity = _when_system_builds_stix_malware(
        malware_data, author_identity, tlp_marking
    )

    # Then
    _then_stix_malware_has_correct_attributes(malware_entity, malware_data)


def test_malware_importer_handles_pagination(mock_helper, author_identity, tlp_marking):
    """
    Scenario: Paginated malware import
    Given the Admin has configured malware scope
    When the System runs the importer
    Then the System queries malware using query_malware_entities
    """
    # Given
    importer = _given_malware_importer_configured(
        mock_helper, author_identity, tlp_marking
    )

    # When
    query_params = _when_importer_queries_malware_entities(importer)

    # Then
    _then_system_uses_correct_api_parameters(query_params)


# Edge case tests
def test_handle_malware_without_mitre_data(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Scenario: Handle malware without MITRE data gracefully
    Given the Crowdstrike API provides malware without MITRE data
    When the System processes the malware
    Then the System creates malware without relationships
    """
    # Given
    malware_data = _given_malware_without_mitre_data(fake_malware_data)

    # When
    bundle = _when_system_processes_malware_with_mitre(
        malware_data, author_identity, tlp_marking
    )

    # Then
    _then_system_creates_malware_without_relationships(bundle, malware_data)


def test_handle_malware_with_iso_timestamps(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Scenario: Handle ISO timestamp format from API
    Given the Crowdstrike API returns malware with ISO timestamps
    When the System processes the malware
    Then the System handles timestamps correctly without errors
    """
    # Given
    malware_data = _given_malware_with_iso_timestamps(fake_malware_data)

    # When
    bundle = _when_system_processes_malware_with_mitre(
        malware_data, author_identity, tlp_marking
    )

    # Then
    _then_system_handles_iso_timestamps_correctly(bundle, malware_data)


# BDD step implementations
def _given_crowdstrike_provides_malware_collection(malware_list):
    """Given the Crowdstrike API provides a malware collection endpoint."""
    return {"resources": malware_list}


def _given_malware_has_mitre_data(malware_data):
    """Given the malware data contains MITRE ATT&CK information."""
    assert "mitre" in malware_data
    assert len(malware_data["mitre"]) > 0
    return malware_data


def _given_crowdstrike_returns_malware_data(malware_data):
    """Given the Crowdstrike API returns malware data."""
    assert "name" in malware_data
    assert "description" in malware_data
    return malware_data


def _given_malware_importer_configured(helper, author, tlp_marking):
    """Given the malware importer is configured."""
    return MalwareImporter(
        helper=helper,
        author=author,
        default_latest_timestamp=1640995200,
        tlp_marking=tlp_marking,
    )


def _given_malware_without_mitre_data(fake_malware_data):
    """Given the Crowdstrike API provides malware without MITRE data."""
    malware_data = fake_malware_data.copy()
    malware_data["mitre"] = []
    return malware_data


def _given_malware_with_iso_timestamps(fake_malware_data):
    """Given the Crowdstrike API returns malware with ISO timestamps."""
    return fake_malware_data


def _when_system_imports_malware_collection(api_data, author, tlp_marking):
    """When the System imports malware collection."""
    malware_data = api_data["resources"][0]

    attack_patterns = []
    for attack in malware_data.get("mitre", []):
        from crowdstrike_feeds_services.utils import create_attack_pattern

        attack_pattern = create_attack_pattern(
            name=attack["technique_name"],
            mitre_id=attack["technique_id"],
            created_by=author,
            object_markings=[tlp_marking],
        )
        attack_patterns.append(attack_pattern)

    bundle_builder = MalwareBundleBuilder(
        malware=malware_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        confidence_level=75,
        attack_patterns=attack_patterns,
    )

    return bundle_builder.build()


def _when_system_processes_malware_with_mitre(malware_data, author, tlp_marking):
    """When the System processes malware with MITRE data."""
    return _when_system_imports_malware_collection(
        {"resources": [malware_data]}, author, tlp_marking
    )


def _when_system_builds_stix_malware(malware_data, author, tlp_marking):
    """When the System builds STIX malware entity."""
    bundle_builder = MalwareBundleBuilder(
        malware=malware_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        confidence_level=75,
    )

    return bundle_builder._create_malware()


def _when_importer_queries_malware_entities(importer):
    """When the importer queries malware entities."""
    return {
        "limit": 50,
        "offset": 0,
        "sort": "last_updated|asc",
        "fql_filter": "last_updated:>1640995200",
    }


def _then_system_creates_malware_entities(bundle, expected_malware):
    """Then the System creates Malware entities with all attributes."""
    malware_entities = [obj for obj in bundle.objects if obj.type == "malware"]
    assert len(malware_entities) == 1

    malware_entity = malware_entities[0]
    assert malware_entity["name"] == expected_malware["name"]
    assert malware_entity["is_family"] == True


def _then_system_creates_attack_patterns(bundle):
    """Then the System creates AttackPattern entities."""
    attack_patterns = [obj for obj in bundle.objects if obj.type == "attack-pattern"]
    assert len(attack_patterns) > 0


def _then_system_creates_uses_relationships(bundle):
    """Then the System creates uses relationships to AttackPatterns."""
    relationships = [obj for obj in bundle.objects if obj.type == "relationship"]
    uses_relationships = [
        rel for rel in relationships if rel["relationship_type"] == "uses"
    ]
    assert len(uses_relationships) > 0


def _then_stix_malware_has_correct_attributes(malware_entity, expected_data):
    """Then the STIX Malware has proper attributes."""
    assert malware_entity["name"] == expected_data["name"]
    assert malware_entity["is_family"] == True
    assert malware_entity.get("description") == expected_data["description"]


def _then_system_uses_correct_api_parameters(query_params):
    """Then the System uses correct API parameters."""
    assert "limit" in query_params
    assert "sort" in query_params
    assert "fql_filter" in query_params
    assert "last_updated" in query_params["fql_filter"]


def _then_system_creates_malware_without_relationships(bundle, malware_data):
    """Then the System creates malware without MITRE relationships."""
    malware_entities = [obj for obj in bundle.objects if obj.type == "malware"]
    assert len(malware_entities) == 1
    assert malware_entities[0]["name"] == malware_data["name"]

    attack_patterns = [obj for obj in bundle.objects if obj.type == "attack-pattern"]
    assert len(attack_patterns) == 0

    relationships = [obj for obj in bundle.objects if obj.type == "relationship"]
    uses_relationships = [
        rel for rel in relationships if rel["relationship_type"] == "uses"
    ]
    assert len(uses_relationships) == 0


def _then_system_handles_iso_timestamps_correctly(bundle, malware_data):
    """Then the System handles ISO timestamps correctly without errors."""
    malware_entities = [obj for obj in bundle.objects if obj.type == "malware"]
    assert len(malware_entities) == 1
    assert malware_entities[0]["name"] == malware_data["name"]
