# -*- coding: utf-8 -*-
"""Test for ingesting CrowdStrike 'next_stage_of' malware relationships.

Feature: Ingest the 'next_stage_of' field from CrowdStrike malware and create 'uses' relationships in OpenCTI
    As a Threat Intel Analyst
    I want to ingest the 'next_stage_of' field from CrowdStrike malware
    So that 'uses' relationships are created in OpenCTI
"""

import json
from unittest.mock import Mock

import pytest
from crowdstrike_feeds_connector.malware.builder import MalwareBundleBuilder
from crowdstrike_feeds_services.utils import create_organization
from crowdstrike_feeds_services.utils.constants import DEFAULT_TLP_MARKING_DEFINITION

# =====================
# Fixtures
# =====================


@pytest.fixture
def fake_malware_data():
    """Load fake malware data from JSON file."""
    import os

    faker_path = os.path.join(
        os.path.dirname(__file__), "..", "faker", "api_malware.json"
    )
    with open(faker_path, "r") as f:
        data = json.load(f)
    return data["resources"][0]


@pytest.fixture
def author_identity():
    """Fixture for author identity."""
    return create_organization("CrowdStrike")


@pytest.fixture
def tlp_marking():
    """Fixture for TLP marking."""
    return DEFAULT_TLP_MARKING_DEFINITION


@pytest.fixture
def mock_helper():
    """Fixture for mock OpenCTI helper."""
    return Mock()


# =====================
# Test Cases
# =====================


@pytest.mark.order(0)
def test_ingest_malware_with_next_stage_of_relationship(
    fake_malware_data, author_identity, tlp_marking
):
    """
    Feature: Ingest 'next_stage_of' malware coming from CrowdStrike and create 'uses' relationship with the previous stage malware.
        As a Threat Intel Analyst
        I want to ingest the 'next_stage_of' field from CrowdStrike malware
        So that 'uses' relationships are created in OpenCTI

    Scenario: Ingest malware data with 'next_stage_of' field
    """
    # Given a malware object with 'next_stage_of' from CrowdStrike
    malware_data = _given_malware_with_next_stage_of(fake_malware_data)

    # When the malware object is ingested into the system
    bundle = _when_malware_is_ingested(malware_data, author_identity, tlp_marking)

    # Then the 'next_stage_of' field should result in a previous stage malware and a 'uses' relationship
    _then_uses_relationship_created(bundle, malware_data)


# =====================
# GWT Gherkin-style functions
# =====================


def _given_malware_with_next_stage_of(malware_data: dict) -> dict:
    """Given a malware object with 'next_stage_of' from CrowdStrike."""
    assert "next_stage_of" in malware_data  # noqa: S101
    assert len(malware_data["next_stage_of"]) > 0  # noqa: S101
    assert "name" in malware_data["next_stage_of"][0]  # noqa: S101
    return malware_data


def _when_malware_is_ingested(malware_data: dict, author, tlp_marking):
    """When the malware object is ingested into the system."""
    bundle_builder = MalwareBundleBuilder(
        malware=malware_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        confidence_level=75,
        attack_patterns=[],
    )

    bundle = bundle_builder.build()
    return bundle


def _then_uses_relationship_created(bundle, malware_data: dict) -> None:
    """Then the 'next_stage_of' field should result in a previous stage malware and a 'uses' relationship."""
    # Find all malware entities
    malware_entities = [
        obj for obj in bundle.objects if getattr(obj, "type", None) == "malware"
    ]
    # There should be at least two: the main malware and its previous stage
    assert len(malware_entities) >= 2  # noqa: S101

    # Find the main malware and the previous stage malware by name
    main_name = malware_data["name"]
    prev_stage_name = malware_data["next_stage_of"][0]["name"]
    main_malware = next((m for m in malware_entities if m["name"] == main_name), None)
    prev_stage_malware = next(
        (m for m in malware_entities if m["name"] == prev_stage_name), None
    )
    assert main_malware is not None  # noqa: S101
    assert prev_stage_malware is not None  # noqa: S101

    # Find the 'uses' relationship
    relationships = [
        obj for obj in bundle.objects if getattr(obj, "type", None) == "relationship"
    ]
    uses_rels = [
        r for r in relationships if getattr(r, "relationship_type", None) == "uses"
    ]
    assert len(uses_rels) >= 1  # noqa: S101

    # Check that the relationship links the previous stage malware to the main malware
    found = False
    for rel in uses_rels:
        if (
            rel.source_ref == prev_stage_malware.id
            and rel.target_ref == main_malware.id
        ):
            found = True
            break
    assert (
        found
    ), "No 'uses' relationship found between previous stage and main malware"  # noqa: S101
