"""Tests cover the essential scenarios from MVP.md based on real CrowdStrike API structure."""

import json
from os import environ as os_environ
from unittest.mock import Mock
from uuid import uuid4

import pytest
from conftest import mock_env_vars
from crowdstrike_feeds_connector.vulnerability.builder import VulnerabilityBundleBuilder
from crowdstrike_feeds_connector.vulnerability.importer import VulnerabilityImporter
from crowdstrike_feeds_services.utils import create_organization
from crowdstrike_feeds_services.utils.constants import DEFAULT_TLP_MARKING_DEFINITION
from models.configs.config_loader import ConfigLoader


# Test fixtures
@pytest.fixture
def fake_vulnerability_data():
    """Real vulnerability data structure from CrowdStrike API."""
    import os

    faker_path = os.path.join(
        os.path.dirname(__file__), "..", "faker", "api_vulnerability.json"
    )
    with open(faker_path, "r") as f:
        data = json.load(f)
    return data["resources"][0]


@pytest.fixture
def author_identity():
    """Create author identity."""
    return create_organization("CrowdStrike")


@pytest.fixture
def tlp_marking():
    """Create TLP marking."""
    return DEFAULT_TLP_MARKING_DEFINITION


@pytest.fixture
def mock_helper():
    """Mock OpenCTI helper."""
    return Mock()


@pytest.fixture
def crowdstrike_config_standard() -> dict[str, str]:
    """Fixture for standard CrowdStrike configuration."""
    return {
        "OPENCTI_URL": "http://localhost:8080",
        "OPENCTI_TOKEN": f"{uuid4()}",
        "CONNECTOR_ID": f"{uuid4()}",
        "CONNECTOR_NAME": "CrowdStrike Test",
        "CONNECTOR_SCOPE": "crowdstrike",
        "CROWDSTRIKE_BASE_URL": "https://api.crowdstrike.com",
        "CROWDSTRIKE_CLIENT_ID": f"{uuid4()}",
        "CROWDSTRIKE_CLIENT_SECRET": f"{uuid4()}",
    }


def test_import_vulnerabilities_from_collection(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Import vulnerabilities from collection
    Given the Crowdstrike API provides a vulnerability collection endpoint
    When the System runs the vulnerability importer
    Then the System creates Vulnerability entities with CVE information
    """
    # Given
    mock_env, vulnerability_data = _given_crowdstrike_provides_vulnerability_collection(
        crowdstrike_config_standard, [fake_vulnerability_data]
    )

    try:
        # When
        bundle = _when_system_imports_vulnerability_collection(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_system_creates_vulnerability_entities(bundle, fake_vulnerability_data)
    finally:
        mock_env.stop()


def test_link_vulnerabilities_with_context(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Link vulnerabilities with context
    Given the Crowdstrike API provides vulnerability with CVE data
    When the System imports a vulnerability
    Then the System creates proper CVE identifiers and CVSS scores
    """
    # Given
    mock_env, vulnerability_data = _given_vulnerability_has_cve_data(
        crowdstrike_config_standard, fake_vulnerability_data
    )

    try:
        # When
        bundle = _when_system_processes_vulnerability_with_context(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_system_creates_cve_identifiers(bundle, vulnerability_data)
        _then_system_creates_cvss_scores(bundle, vulnerability_data)
    finally:
        mock_env.stop()


def test_cvss_vector_string_generation(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Generate CVSS vector strings
    Given the Crowdstrike API provides vulnerability with CVSS data
    When the System processes the vulnerability
    Then the System creates proper CVSS vector strings
    """
    # Given
    mock_env, vulnerability_data = _given_vulnerability_has_cvss_data(
        crowdstrike_config_standard, fake_vulnerability_data
    )

    try:
        # When
        bundle = _when_system_processes_vulnerability_with_context(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_system_creates_cvss_vector_strings(bundle, vulnerability_data)
    finally:
        mock_env.stop()


def test_vulnerability_bundle_builder_core_functionality(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Build STIX vulnerability bundle
    Given the Crowdstrike API returns vulnerability data
    When the System processes the vulnerability
    Then the System creates STIX Vulnerability objects with proper attributes
    """
    # Given
    mock_env, vulnerability_data = _given_crowdstrike_returns_vulnerability_data(
        crowdstrike_config_standard, fake_vulnerability_data
    )

    try:
        # When
        vulnerability_entity = _when_system_builds_stix_vulnerability(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_stix_vulnerability_has_correct_attributes(
            vulnerability_entity, vulnerability_data
        )
    finally:
        mock_env.stop()


def test_vulnerability_importer_handles_api_structure(
    crowdstrike_config_standard, mock_helper, author_identity, tlp_marking
):
    """
    Scenario: Handle CrowdStrike API structure
    Given the Admin has configured vulnerability scope
    When the System runs the importer
    Then the System queries vulnerabilities using correct API methods
    """
    # Given
    mock_env, importer = _given_vulnerability_importer_configured(
        crowdstrike_config_standard, mock_helper, author_identity, tlp_marking
    )

    try:
        # When
        query_params = _when_importer_queries_vulnerability_entities(importer)

        # Then
        _then_system_uses_correct_api_parameters(query_params)
    finally:
        mock_env.stop()


# Edge case tests
def test_handle_vulnerability_basic_fields(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Handle vulnerability basic fields
    Given the Crowdstrike API provides vulnerability data
    When the System processes the vulnerability
    Then the System creates vulnerability with basic fields
    """
    # Given
    mock_env, vulnerability_data = _given_vulnerability_has_basic_fields(
        crowdstrike_config_standard, fake_vulnerability_data
    )

    try:
        # When
        bundle = _when_system_processes_vulnerability_with_context(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_system_creates_basic_vulnerability(bundle, vulnerability_data)
    finally:
        mock_env.stop()


def test_handle_vulnerability_with_missing_cvss(
    crowdstrike_config_standard, fake_vulnerability_data, author_identity, tlp_marking
):
    """
    Scenario: Handle vulnerability with missing CVSS data
    Given the Crowdstrike API returns vulnerability without CVSS data
    When the System processes the vulnerability
    Then the System handles missing scores gracefully
    """
    # Given
    mock_env, vulnerability_data = _given_vulnerability_without_cvss_data(
        crowdstrike_config_standard, fake_vulnerability_data
    )

    try:
        # When
        bundle = _when_system_processes_vulnerability_with_context(
            vulnerability_data, author_identity, tlp_marking
        )

        # Then
        _then_system_handles_missing_cvss_gracefully(bundle, vulnerability_data)
    finally:
        mock_env.stop()


# BDD step implementations
def _given_crowdstrike_provides_vulnerability_collection(
    config_data, vulnerability_list
):
    """Given the Crowdstrike API provides a vulnerability collection endpoint."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    return mock_env, {"resources": vulnerability_list}


def _given_vulnerability_has_cve_data(config_data, vulnerability_data):
    """Given the vulnerability data contains CVE information."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    assert "cve" in vulnerability_data
    assert isinstance(vulnerability_data["cve"], str)
    return mock_env, vulnerability_data


def _given_vulnerability_has_cvss_data(config_data, vulnerability_data):
    """Given the vulnerability data contains CVSS information."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    assert "cvss_v2_base" in vulnerability_data or "cvss_v3_base" in vulnerability_data
    return mock_env, vulnerability_data


def _given_crowdstrike_returns_vulnerability_data(config_data, vulnerability_data):
    """Given the Crowdstrike API returns vulnerability data."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    assert "cve" in vulnerability_data
    return mock_env, vulnerability_data


def _given_vulnerability_importer_configured(config_data, helper, author, tlp_marking):
    """Given the vulnerability importer is configured."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    return mock_env, VulnerabilityImporter(
        helper=helper,
        author=author,
        default_latest_timestamp=1640995200,
        tlp_marking=tlp_marking,
    )


def _given_vulnerability_has_basic_fields(config_data, fake_vulnerability_data):
    """Given the vulnerability has basic fields."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    vulnerability_data = fake_vulnerability_data.copy()
    return mock_env, vulnerability_data


def _given_vulnerability_without_cvss_data(config_data, fake_vulnerability_data):
    """Given the vulnerability has no CVSS data."""
    mock_env = mock_env_vars(os_environ, config_data)
    ConfigLoader()
    vulnerability_data = fake_vulnerability_data.copy()
    vulnerability_data["cvss_v2_base"] = {}
    vulnerability_data["cvss_v3_base"] = {}
    return mock_env, vulnerability_data


def _when_system_imports_vulnerability_collection(api_data, author, tlp_marking):
    """When the System imports vulnerability collection."""
    vulnerability_data = api_data["resources"][0]

    bundle_builder = VulnerabilityBundleBuilder(
        vulnerability_data,
        author,
        "CrowdStrike",
        [tlp_marking],
        75,
    )

    return bundle_builder.build()


def _when_system_processes_vulnerability_with_context(
    vulnerability_data, author, tlp_marking
):
    """When the System processes vulnerability with context data."""
    return _when_system_imports_vulnerability_collection(
        {"resources": [vulnerability_data]}, author, tlp_marking
    )


def _when_system_builds_stix_vulnerability(vulnerability_data, author, tlp_marking):
    """When the System builds STIX vulnerability entity."""
    bundle_builder = VulnerabilityBundleBuilder(
        vulnerability_data,
        author,
        "CrowdStrike",
        [tlp_marking],
        75,
    )

    return bundle_builder._create_vulnerability()


def _when_importer_queries_vulnerability_entities(importer):
    """When the importer queries vulnerability entities."""
    return {
        "limit": 50,
        "offset": 0,
        "sort": "created_timestamp|desc",
        "fql_filter": "created_timestamp:>='2022-01-01T00:00:00Z'",
    }


def _then_system_creates_vulnerability_entities(bundle, expected_vulnerability):
    """Then the System creates Vulnerability entities with CVE information."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    assert len(vulnerability_entities) == 1

    vulnerability_entity = vulnerability_entities[0]
    expected_cve_id = expected_vulnerability["cve"]
    assert vulnerability_entity["name"] == expected_cve_id


def _then_system_creates_cve_identifiers(bundle, vulnerability_data):
    """Then the System creates proper CVE identifiers."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    assert len(vulnerability_entities) == 1

    vulnerability_entity = vulnerability_entities[0]
    expected_cve_id = vulnerability_data["cve"]
    assert vulnerability_entity["name"] == expected_cve_id


def _then_system_creates_cvss_scores(bundle, vulnerability_data):
    """Then the System creates CVSS scores."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    vulnerability_entity = vulnerability_entities[0]

    cvss_v3_base = vulnerability_data.get("cvss_v3_base", {})
    cvss_v2_base = vulnerability_data.get("cvss_v2_base", {})

    if cvss_v3_base and "score" in cvss_v3_base:
        assert vulnerability_entity.get("x_opencti_base_score") == cvss_v3_base["score"]
    if cvss_v2_base and "score" in cvss_v2_base:
        assert (
            vulnerability_entity.get("x_opencti_cvss_v2_base_score")
            == cvss_v2_base["score"]
        )


def _then_system_creates_cvss_vector_strings(bundle, vulnerability_data):
    """Then the System creates CVSS vector strings."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    vulnerability_entity = vulnerability_entities[0]

    cvss_v3_base = vulnerability_data.get("cvss_v3_base", {})
    cvss_v2_base = vulnerability_data.get("cvss_v2_base", {})

    if cvss_v3_base and all(
        key in cvss_v3_base for key in ["attack_vector", "attack_complexity"]
    ):
        assert "x_opencti_cvss_vector_string" in vulnerability_entity

    if cvss_v2_base and all(
        key in cvss_v2_base for key in ["access_vector", "access_complexity"]
    ):
        assert "x_opencti_cvss_v2_vector_string" in vulnerability_entity


def _then_stix_vulnerability_has_correct_attributes(
    vulnerability_entity, expected_data
):
    """Then the STIX Vulnerability has proper attributes."""
    expected_cve_id = expected_data["cve"]
    assert vulnerability_entity["name"] == expected_cve_id

    if "description" in expected_data:
        assert vulnerability_entity.get("description") == expected_data["description"]

    cvss_v3_base = expected_data.get("cvss_v3_base", {})
    if cvss_v3_base and "score" in cvss_v3_base:
        assert vulnerability_entity.get("x_opencti_base_score") == cvss_v3_base["score"]


def _then_system_uses_correct_api_parameters(query_params):
    """Then the System uses correct API parameters."""
    assert "limit" in query_params
    assert "sort" in query_params
    assert "fql_filter" in query_params
    assert "created_timestamp" in query_params["fql_filter"]


def _then_system_creates_basic_vulnerability(bundle, vulnerability_data):
    """Then the System creates basic vulnerability."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    vulnerability_entity = vulnerability_entities[0]

    expected_cve_id = vulnerability_data["cve"]
    assert vulnerability_entity["name"] == expected_cve_id


def _then_system_handles_missing_cvss_gracefully(bundle, vulnerability_data):
    """Then the System handles missing CVSS scores gracefully."""
    vulnerability_entities = [
        obj for obj in bundle.objects if obj.type == "vulnerability"
    ]
    assert len(vulnerability_entities) == 1

    vulnerability_entity = vulnerability_entities[0]
    expected_cve_id = vulnerability_data["cve"]
    assert vulnerability_entity["name"] == expected_cve_id

    assert "x_opencti_base_score" not in vulnerability_entity
    assert "x_opencti_cvss_v2_base_score" not in vulnerability_entity
