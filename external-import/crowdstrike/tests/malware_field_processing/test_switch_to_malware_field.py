"""Module to test switching to malware field from report data."""

import json
from os import environ as os_environ
from pathlib import Path
from typing import Any
from uuid import uuid4

import pytest
from conftest import mock_env_vars
from crowdstrike_feeds_connector.report.builder import ReportBundleBuilder
from models.configs.config_loader import ConfigLoader
from stix2 import TLP_AMBER, Bundle, Identity, MarkingDefinition

# =====================
# Fixtures
# =====================


@pytest.fixture
def fake_report_data() -> dict:
    """Load fake report data from JSON file."""
    faker_dir = Path(__file__).parent.parent / "faker"
    with open(faker_dir / "api_report.json", "r") as f:
        return json.load(f)


@pytest.fixture
def fake_report_without_malware_field() -> dict:
    """Create a report without malware field for testing."""
    faker_dir = Path(__file__).parent.parent / "faker"
    with open(faker_dir / "api_report.json", "r") as f:
        report = json.load(f)

    report.pop("malware", None)
    report["tags"] = [
        {"id": 2000005, "slug": "ransomware", "value": "Ransomware"},
        {"id": 2000013, "slug": "trojan", "value": "Trojan"},
        {"id": 2000014, "slug": "apt", "value": "APT"},
    ]

    return report


@pytest.fixture
def author_identity() -> Identity:
    """Fixture for author identity."""
    return Identity(  # pylint: disable=W9101  # it's a test no real ingest
        name="CrowdStrike",
        identity_class="organization",
    )


@pytest.fixture
def tlp_marking() -> MarkingDefinition:
    """Fixture for TLP marking."""
    return TLP_AMBER


@pytest.fixture
def crowdstrike_config_standard() -> dict[str, str]:
    """Fixture for standard CrowdStrike configuration."""
    return {
        "OPENCTI_URL": "http://localhost:8080",
        "OPENCTI_TOKEN": f"{uuid4()}",
        "CONNECTOR_ID": f"{uuid4()}",
        "CONNECTOR_NAME": "CrowdStrike Test",
        "CONNECTOR_SCOPE": "crowdstrike",
        "CROWDSTRIKE_BASE_URL": "https://api.crowdstrike.com",
        "CROWDSTRIKE_CLIENT_ID": f"{uuid4()}",
        "CROWDSTRIKE_CLIENT_SECRET": f"{uuid4()}",
    }


@pytest.fixture
def mock_related_indicators() -> list:
    """Fixture for mock related indicators."""
    return []


# =====================
# Test Cases
# =====================


# Scenario: Parse malware field from report
@pytest.mark.order(0)
def test_parse_malware_field_from_report(
    crowdstrike_config_standard: dict[str, str],
    fake_report_data: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Feature: Switch to Malware Field
      As the System
      I want to use the existing malware field from report data
      Because the field already exists but is not being used

    Scenario: Parse malware field from report
    """
    # Given the report data already contains a malware field
    mock_env, config, report_with_malware = _given_report_data_contains_malware_field(
        crowdstrike_config_standard, fake_report_data
    )

    try:
        # When the System processes a report
        bundle = _when_system_processes_report(
            config=config,
            report_data=report_with_malware,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then the System extracts malware from report["malware"]
        _then_system_extracts_malware_from_report_field(bundle, report_with_malware)

        # And the System stops parsing tags for malware
        _then_system_stops_parsing_tags_for_malware(bundle, report_with_malware)
    finally:
        mock_env.stop()


# Scenario: Handle reports without malware field
@pytest.mark.order(1)
def test_handle_reports_without_malware_field(
    crowdstrike_config_standard: dict[str, str],
    fake_report_without_malware_field: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Feature: Switch to Malware Field
      As the System
      I want to use the existing malware field from report data
      Because the field already exists but is not being used

    Scenario: Handle missing malware field gracefully
    """
    # Given the report data does not contain a malware field
    mock_env, config, report_without_malware = _given_report_missing_malware_field(
        crowdstrike_config_standard, fake_report_without_malware_field
    )

    try:
        # When the System processes a report without malware field
        bundle = _when_system_processes_report_without_malware_field(
            config=config,
            report_data=report_without_malware,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then the System should not create malware entities
        _then_system_creates_no_malware_entities(bundle)

        # And the System should not attempt tag parsing
        _then_system_does_not_parse_tags(bundle, report_without_malware)
    finally:
        mock_env.stop()


# =====================
# GWT Gherkin-style functions
# =====================


def _given_report_data_contains_malware_field(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given the report data already contains a malware field."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" in report_data  # noqa: S101
    assert isinstance(report_data["malware"], list)  # noqa: S101
    assert len(report_data["malware"]) > 0  # noqa: S101

    for malware_item in report_data["malware"]:
        assert "family_name" in malware_item  # noqa: S101

    return mock_env, config, report_data


def _when_system_processes_report(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System processes a report."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_system_extracts_malware_from_report_field(
    bundle: Bundle, report_data: dict
) -> None:
    """Then the System extracts malware from report['malware']."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    malware_in_field = report_data.get("malware", [])
    assert len(malware_entities) == len(malware_in_field)  # noqa: S101

    field_malware_names = [m.get("family_name") for m in malware_in_field]
    bundle_malware_names = [m.name for m in malware_entities if hasattr(m, "name")]

    for name in field_malware_names:
        assert name in bundle_malware_names  # noqa: S101


def _then_system_stops_parsing_tags_for_malware(
    bundle: Bundle, report_data: dict
) -> None:
    """And the System stops parsing tags for malware."""
    tags = report_data.get("tags", [])

    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    malware_in_field = report_data.get("malware", [])
    assert len(malware_entities) == len(malware_in_field)  # noqa: S101

    if tags:
        field_malware_names = [
            m.get("family_name", "").lower() for m in malware_in_field
        ]
        bundle_malware_names = [
            m.name.lower() for m in malware_entities if hasattr(m, "name")
        ]

        for tag in tags:
            tag_value = tag.get("value", "").lower()
            if tag_value not in field_malware_names:
                assert tag_value not in bundle_malware_names  # noqa: S101


def _given_report_missing_malware_field(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given the report data does not contain a malware field."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" not in report_data  # noqa: S101

    assert "tags" in report_data  # noqa: S101

    return mock_env, config, report_data


def _when_system_processes_report_without_malware_field(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System processes a report without malware field."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        # Empty list since no malware field
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_system_creates_no_malware_entities(bundle: Bundle) -> None:
    """Then the System should not create malware entities."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    assert len(malware_entities) == 0  # noqa: S101


def _then_system_does_not_parse_tags(bundle: Bundle, report_data: dict) -> None:
    """And the System should not attempt tag parsing."""
    tags = report_data.get("tags", [])

    if tags:
        malware_entities = [
            obj
            for obj in bundle.objects
            if hasattr(obj, "type") and obj.type == "malware"
        ]

        assert len(malware_entities) == 0  # noqa: S101

        bundle_malware_names = [
            m.name.lower() for m in malware_entities if hasattr(m, "name")
        ]
        for tag in tags:
            tag_value = tag.get("value", "").lower()
            assert tag_value not in bundle_malware_names  # noqa: S101
