"""Module to test the updated malware processing using direct field instead of tag guessing."""

import json
from os import environ as os_environ
from pathlib import Path
from typing import Any
from uuid import uuid4

import pytest
from conftest import mock_env_vars
from crowdstrike_feeds_connector.report.builder import ReportBundleBuilder
from models.configs.config_loader import ConfigLoader
from stix2 import TLP_AMBER, Bundle, Identity, Malware, MarkingDefinition

# =====================
# Fixtures
# =====================


@pytest.fixture
def fake_report_with_malware() -> dict:
    """Load fake report data with malware field."""
    faker_dir = Path(__file__).parent.parent / "faker"
    with open(faker_dir / "api_report.json", "r") as f:
        report = json.load(f)

    if "malware" not in report or not report["malware"]:
        report["malware"] = [
            {
                "family_name": "DarkHydrus",
                "id": "mal_12345",
                "description": "DarkHydrus malware family",
            },
            {
                "family_name": "Emotet",
                "id": "mal_67890",
                "description": "Emotet malware family",
            },
        ]
    return report


@pytest.fixture
def author_identity() -> Identity:
    """Fixture for author identity."""
    return Identity(  # pylint: disable=W9101  # it's a test no real ingest
        name="CrowdStrike",
        identity_class="organization",
    )


@pytest.fixture
def tlp_marking() -> MarkingDefinition:
    """Fixture for TLP marking."""
    return TLP_AMBER


@pytest.fixture
def crowdstrike_config() -> dict[str, str]:
    """Fixture for standard CrowdStrike configuration."""
    return {
        "OPENCTI_URL": "http://localhost:8080",
        "OPENCTI_TOKEN": f"{uuid4()}",
        "CONNECTOR_ID": f"{uuid4()}",
        "CONNECTOR_NAME": "CrowdStrike Test",
        "CONNECTOR_SCOPE": "crowdstrike",
        "CROWDSTRIKE_BASE_URL": "https://api.crowdstrike.com",
        "CROWDSTRIKE_CLIENT_ID": f"{uuid4()}",
        "CROWDSTRIKE_CLIENT_SECRET": f"{uuid4()}",
    }


@pytest.fixture
def mock_related_indicators() -> list:
    """Fixture for mock related indicators."""
    return []


# =====================
# Test Cases
# =====================


# Feature: Direct Malware Field Processing
@pytest.mark.order(0)
def test_create_malware_from_existing_field(
    crowdstrike_config: dict[str, str],
    fake_report_with_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Feature: Direct Malware Field Processing
      As the System
      I want to process malware from the existing malware field
      Because the Threat Intel Analyst needs accurate malware family information

    Scenario: Create malware from existing field
    """
    # Given the report object already has a malware field
    mock_env, config, report = _given_report_object_has_malware_field(
        crowdstrike_config, fake_report_with_malware
    )

    try:
        # When the System processes the report
        bundle = _when_system_processes_the_report(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then the System creates malware entities from report["malware"]
        _then_system_creates_malware_entities_from_field(bundle, report)

        # And the Threat Intel Analyst sees properly modeled malware families
        _then_analyst_sees_properly_modeled_malware_families(bundle, report)
    finally:
        mock_env.stop()


@pytest.mark.order(1)
def test_update_create_report_bundle_to_pass_malware_field(
    crowdstrike_config: dict[str, str],
    fake_report_with_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Scenario: Update _create_report_bundle() to pass malware field instead of guessed_malwares
    """
    # Given _create_report_bundle needs to pass malware data
    mock_env, config, report = _given_create_report_bundle_needs_malware_data(
        crowdstrike_config, fake_report_with_malware
    )

    try:
        # When the method is updated to use malware field
        bundle = _when_method_updated_to_use_malware_field(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then it passes report["malware"] instead of guessed_malwares
        _then_it_passes_report_malware_not_guessed(bundle, report)

        # And the builder receives malwares_from_field parameter
        _then_builder_receives_malwares_from_field(bundle, report)
    finally:
        mock_env.stop()


@pytest.mark.order(2)
def test_update_create_malwares_in_builder(
    crowdstrike_config: dict[str, str],
    fake_report_with_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Scenario: Update _create_malwares() in builder to use the malware field directly
    """
    # Given the builder has _create_malwares method
    mock_env, config, report = _given_builder_has_create_malwares_method(
        crowdstrike_config, fake_report_with_malware
    )

    try:
        # When _create_malwares is updated to use malware field
        bundle = _when_create_malwares_updated_to_use_field(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then it processes malwares_from_field parameter
        _then_it_processes_malwares_from_field_parameter(bundle, report)

        # And it creates proper Malware STIX objects
        _then_it_creates_proper_malware_stix_objects(bundle, report)
    finally:
        mock_env.stop()


@pytest.mark.order(3)
def test_create_malware_entities_with_is_family_flag(
    crowdstrike_config: dict[str, str],
    fake_report_with_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Scenario: Create malware entities with proper is_family flag
    """
    # Given malware in the report are families not instances
    mock_env, config, report = _given_malware_are_families_not_instances(
        crowdstrike_config, fake_report_with_malware
    )

    try:
        # When the System creates malware entities
        bundle = _when_system_creates_malware_entities(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then each malware has is_family set to true
        _then_each_malware_has_is_family_true(bundle)

        # And the malware type is properly set
        _then_malware_type_is_properly_set(bundle)
    finally:
        mock_env.stop()


@pytest.mark.order(4)
def test_ensure_malware_relationships_maintained(
    crowdstrike_config: dict[str, str],
    fake_report_with_malware: dict,
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Scenario: Ensure malware relationships are maintained
    """
    # Given malware entities need to be related to the report
    mock_env, config, report = _given_malware_needs_relationships_to_report(
        crowdstrike_config, fake_report_with_malware
    )

    try:
        # When the System creates the bundle with malware
        bundle = _when_system_creates_bundle_with_malware(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then relationships exist between report and malware
        _then_relationships_exist_between_report_and_malware(bundle, report)

        # And the relationships use correct relationship type
        _then_relationships_use_correct_type(bundle)
    finally:
        mock_env.stop()


@pytest.mark.order(5)
def test_no_malware_created_when_field_empty(
    crowdstrike_config: dict[str, str],
    author_identity: Identity,
    tlp_marking: MarkingDefinition,
    mock_related_indicators: list,
) -> None:
    """
    Scenario: No malware created when field is empty or missing
    """
    # Given the report has an empty malware field
    mock_env, config, report = _given_report_has_empty_malware_field(crowdstrike_config)

    try:
        # When the System processes the report
        bundle = _when_system_processes_report_with_empty_malware(
            config=config,
            report_data=report,
            author=author_identity,
            tlp_marking=tlp_marking,
            related_indicators=mock_related_indicators,
        )

        # Then no malware entities are created
        _then_no_malware_entities_are_created(bundle)

        # And the bundle is still valid
        _then_bundle_is_still_valid(bundle)
    finally:
        mock_env.stop()


# =====================
# GWT Gherkin-style functions
# =====================


def _given_report_object_has_malware_field(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given the report object already has a malware field."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" in report_data  # noqa: S101
    assert len(report_data["malware"]) > 0  # noqa: S101

    return mock_env, config, report_data


def _when_system_processes_the_report(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System processes the report."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_system_creates_malware_entities_from_field(
    bundle: Bundle, report_data: dict
) -> None:
    """Then the System creates malware entities from report['malware']."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    malware_in_field = report_data.get("malware", [])
    assert len(malware_entities) == len(malware_in_field)  # noqa: S101

    field_names = [m.get("family_name") for m in malware_in_field]
    entity_names = [m.name for m in malware_entities if hasattr(m, "name")]

    for name in field_names:
        assert name in entity_names  # noqa: S101


def _then_analyst_sees_properly_modeled_malware_families(
    bundle: Bundle, report_data: dict
) -> None:
    """And the Threat Intel Analyst sees properly modeled malware families."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    for malware in malware_entities:
        assert hasattr(malware, "name")  # noqa: S101
        assert hasattr(malware, "is_family")  # noqa: S101
        assert malware.is_family  # noqa: S101

        assert isinstance(malware, Malware)  # noqa: S101


def _given_create_report_bundle_needs_malware_data(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given _create_report_bundle needs to pass malware data."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" in report_data  # noqa: S101

    return mock_env, config, report_data


def _when_method_updated_to_use_malware_field(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the method is updated to use malware field."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_it_passes_report_malware_not_guessed(
    bundle: Bundle, report_data: dict
) -> None:
    """Then it passes report['malware'] instead of guessed_malwares."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    malware_in_field = report_data.get("malware", [])
    assert len(malware_entities) == len(malware_in_field)  # noqa: S101


def _then_builder_receives_malwares_from_field(
    bundle: Bundle, report_data: dict
) -> None:
    """And the builder receives malwares_from_field parameter."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    assert len(malware_entities) > 0  # noqa: S101


def _given_builder_has_create_malwares_method(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given the builder has _create_malwares method."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" in report_data  # noqa: S101
    assert len(report_data["malware"]) > 0  # noqa: S101

    return mock_env, config, report_data


def _when_create_malwares_updated_to_use_field(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When _create_malwares is updated to use malware field."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_it_processes_malwares_from_field_parameter(
    bundle: Bundle, report_data: dict
) -> None:
    """Then it processes malwares_from_field parameter."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    malware_in_field = report_data.get("malware", [])
    assert len(malware_entities) == len(malware_in_field)  # noqa: S101


def _then_it_creates_proper_malware_stix_objects(
    bundle: Bundle, report_data: dict
) -> None:
    """And it creates proper Malware STIX objects."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    for malware in malware_entities:
        assert isinstance(malware, Malware)  # noqa: S101
        assert hasattr(malware, "name")  # noqa: S101
        assert hasattr(malware, "is_family")  # noqa: S101
        assert hasattr(malware, "id")  # noqa: S101
        assert malware.id.startswith("malware--")  # noqa: S101


def _given_malware_are_families_not_instances(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given malware in the report are families not instances."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    for malware_item in report_data.get("malware", []):
        assert "family_name" in malware_item  # noqa: S101

    return mock_env, config, report_data


def _when_system_creates_malware_entities(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System creates malware entities."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_each_malware_has_is_family_true(bundle: Bundle) -> None:
    """Then each malware has is_family set to true."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    for malware in malware_entities:
        assert hasattr(malware, "is_family")  # noqa: S101
        assert malware.is_family is True  # noqa: S101


def _then_malware_type_is_properly_set(bundle: Bundle) -> None:
    """And the malware type is properly set."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    for malware in malware_entities:
        assert malware.type == "malware"  # noqa: S101
        if hasattr(malware, "malware_types"):
            assert isinstance(malware.malware_types, list)  # noqa: S101


def _given_malware_needs_relationships_to_report(
    config_data: dict[str, str], report_data: dict
) -> tuple[Any, ConfigLoader, dict]:
    """Given malware entities need to be related to the report."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    assert "malware" in report_data  # noqa: S101
    assert len(report_data["malware"]) > 0  # noqa: S101

    return mock_env, config, report_data


def _when_system_creates_bundle_with_malware(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System creates the bundle with malware."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_relationships_exist_between_report_and_malware(
    bundle: Bundle, report_data: dict
) -> None:
    """Then relationships exist between report and malware."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    report_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "report"
    ]

    assert len(report_entities) > 0  # noqa: S101

    if len(malware_entities) > 0:
        malware_ids = [m.id for m in malware_entities]
        report = report_entities[0]

        if hasattr(report, "object_refs"):
            malware_in_report = any(
                malware_id in report.object_refs for malware_id in malware_ids
            )
            assert malware_in_report  # noqa: S101
        else:
            relationships = [
                obj
                for obj in bundle.objects
                if hasattr(obj, "type") and obj.type == "relationship"
            ]

            relevant_relationships = [
                r
                for r in relationships
                if hasattr(r, "source_ref")
                and hasattr(r, "target_ref")
                and (r.source_ref == report.id or r.target_ref == report.id)
                and (r.source_ref in malware_ids or r.target_ref in malware_ids)
            ]

            assert len(relevant_relationships) > 0  # noqa: S101


def _then_relationships_use_correct_type(bundle: Bundle) -> None:
    """And the relationships use correct relationship type."""
    relationships = [
        obj
        for obj in bundle.objects
        if hasattr(obj, "type") and obj.type == "relationship"
    ]

    for relationship in relationships:
        if hasattr(relationship, "relationship_type"):
            valid_types = ["uses", "indicates", "related-to", "derived-from", "targets"]
            assert relationship.relationship_type in valid_types  # noqa: S101


def _given_report_has_empty_malware_field(
    config_data: dict[str, str],
) -> tuple[Any, ConfigLoader, dict]:
    """Given the report has an empty malware field."""
    mock_env = mock_env_vars(os_environ, config_data)
    config = ConfigLoader()

    report = {
        "id": 12345,
        "name": "Test Report",
        "description": "A report with no malware",
        "created_date": 1609459200,
        "last_modified_date": 1609459200,
        "malware": [],
        "tags": [{"id": 1, "slug": "test", "value": "Test"}],
        "actors": [],
        "target_industries": [],
        "target_countries": [],
        "url": "https://example.com/report/12345",
    }

    return mock_env, config, report


def _when_system_processes_report_with_empty_malware(
    config: ConfigLoader,
    report_data: dict,
    author: Identity,
    tlp_marking: MarkingDefinition,
    related_indicators: list,
) -> Bundle:
    """When the System processes the report with empty malware."""
    malware_from_field = report_data.get("malware", [])

    builder = ReportBundleBuilder(
        report=report_data,
        author=author,
        source_name="CrowdStrike",
        object_markings=[tlp_marking],
        report_status=0,
        report_type="threat-report",
        confidence_level=80,
        malwares_from_field=malware_from_field,
        related_indicators=related_indicators,
    )

    bundle = builder.build()
    return bundle


def _then_no_malware_entities_are_created(bundle: Bundle) -> None:
    """Then no malware entities are created."""
    malware_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "malware"
    ]

    assert len(malware_entities) == 0  # noqa: S101


def _then_bundle_is_still_valid(bundle: Bundle) -> None:
    """And the bundle is still valid."""
    assert isinstance(bundle, Bundle)  # noqa: S101
    assert hasattr(bundle, "objects")  # noqa: S101
    assert len(bundle.objects) > 0  # noqa: S101

    report_entities = [
        obj for obj in bundle.objects if hasattr(obj, "type") and obj.type == "report"
    ]
    assert len(report_entities) > 0  # noqa: S101
