"""OpenCTI CrowdStrike vulnerability importer module."""

from datetime import datetime
from typing import Any, Dict, Generator, List, Optional

from crowdstrike_feeds_services.client.vulnerabilities import VulnerabilitiesAPI
from crowdstrike_feeds_services.utils import (
    datetime_to_timestamp,
    flexible_timestamp_to_datetime,
    paginate,
    timestamp_to_datetime,
)
from pycti.connector.opencti_connector_helper import (  # type: ignore  # noqa: E501
    OpenCTIConnectorHelper,
)
from stix2 import Bundle, Identity, MarkingDefinition  # type: ignore

from ..importer import BaseImporter
from .builder import VulnerabilityBundleBuilder


class VulnerabilityImporter(BaseImporter):
    """CrowdStrike vulnerability importer."""

    _NAME = "Vulnerability"

    _LATEST_VULNERABILITY_TIMESTAMP = "latest_vulnerability_timestamp"

    def __init__(
        self,
        helper: OpenCTIConnectorHelper,
        author: Identity,
        default_latest_timestamp: int,
        tlp_marking: MarkingDefinition,
    ) -> None:
        """Initialize CrowdStrike vulnerability importer."""
        super().__init__(helper, author, tlp_marking)
        self.vulnerabilities_api_cs = VulnerabilitiesAPI(helper)
        self.default_latest_timestamp = default_latest_timestamp

    def run(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Run importer."""
        self._info("Running vulnerability importer with state: {0}...", state)

        fetch_timestamp = state.get(
            self._LATEST_VULNERABILITY_TIMESTAMP, self.default_latest_timestamp
        )

        new_state = state.copy()

        latest_vulnerability_updated_timestamp = None

        for vulnerability_batch in self._fetch_vulnerabilities(fetch_timestamp):
            if not vulnerability_batch:
                break

            latest_vulnerability_updated_datetime = self._process_vulnerabilities(
                vulnerability_batch
            )

            if latest_vulnerability_updated_datetime is not None:
                latest_vulnerability_updated_timestamp = datetime_to_timestamp(
                    latest_vulnerability_updated_datetime
                )

                new_state[self._LATEST_VULNERABILITY_TIMESTAMP] = (
                    latest_vulnerability_updated_timestamp
                )
                self._set_state(new_state)

        latest_vulnerability_timestamp = (
            latest_vulnerability_updated_timestamp or fetch_timestamp
        )

        self._info(
            "Vulnerability importer completed, latest fetch {0}.",
            timestamp_to_datetime(latest_vulnerability_timestamp),
        )

        return {self._LATEST_VULNERABILITY_TIMESTAMP: latest_vulnerability_timestamp}

    def _fetch_vulnerabilities(
        self, start_timestamp: int
    ) -> Generator[List, None, None]:
        """Fetch vulnerabilities using two-step API approach."""
        limit = 50
        sort = "updated_timestamp|asc"
        fql_filter = f"updated_timestamp:>{start_timestamp}"

        paginated_query = paginate(self._query_vulnerability_ids)

        for vulnerability_ids_batch in paginated_query(
            limit=limit, sort=sort, fql_filter=fql_filter
        ):
            if not vulnerability_ids_batch:
                break

            detailed_vulnerabilities = self._get_vulnerability_details(
                vulnerability_ids_batch
            )

            if detailed_vulnerabilities:
                yield detailed_vulnerabilities

    def _query_vulnerability_ids(
        self,
        limit: int = 50,
        offset: int = 0,
        sort: Optional[str] = None,
        fql_filter: Optional[str] = None,
    ):
        """Query vulnerability IDs (first API call)."""
        self._info(
            "Query vulnerability IDs limit: {0}, offset: {1}, sort: {2}, filter: {3}",
            limit,
            offset,
            sort,
            fql_filter,
        )

        response = self.vulnerabilities_api_cs.query_vulnerabilities(
            limit=limit, offset=offset, sort=sort, filter=fql_filter
        )

        if not response:
            return {"resources": [], "errors": [], "meta": {"pagination": None}}

        vulnerability_ids = response.get("resources", [])
        self._info("Retrieved {0} vulnerability IDs", len(vulnerability_ids))

        return response

    def _get_vulnerability_details(self, vulnerability_ids: List[str]) -> List:
        """Get detailed vulnerability data (second API call)."""
        if not vulnerability_ids:
            return []

        try:
            response = self.vulnerabilities_api_cs.get_vulnerabilities(
                vulnerability_ids
            )
            detailed_vulnerabilities = response.get("resources", [])

            self._info(
                "Retrieved detailed data for {0} vulnerabilities",
                len(detailed_vulnerabilities),
            )

            return detailed_vulnerabilities

        except Exception as err:
            self._error(
                "Failed to get detailed vulnerability data for IDs: {0}, error: {1}",
                vulnerability_ids,
                err,
            )
            return []

    def _process_vulnerabilities(self, vulnerability_list: List) -> Optional[datetime]:
        """Process a batch of vulnerabilities."""
        vulnerability_count = len(vulnerability_list)
        self._info("Processing {0} vulnerability entities...", vulnerability_count)

        latest_updated_datetime = None

        for vulnerability in vulnerability_list:
            try:
                self._process_single_vulnerability(vulnerability)
            except Exception as err:
                cve_id = vulnerability.get("cve", "unknown")
                self._error(
                    "Failed to process vulnerability {0}, error: {1}",
                    cve_id,
                    err,
                )
                continue

            updated_timestamp = vulnerability.get("updated_timestamp")

            if updated_timestamp is None:
                cve_id = vulnerability.get("cve", "unknown")
                self._error(
                    "Missing timestamp for vulnerability {0}",
                    cve_id,
                )
                continue

            updated_datetime = flexible_timestamp_to_datetime(updated_timestamp)
            if updated_datetime and (
                latest_updated_datetime is None
                or updated_datetime > latest_updated_datetime
            ):
                latest_updated_datetime = updated_datetime

        self._info(
            "Processing vulnerabilities completed (imported: {0}, latest: {1})",
            vulnerability_count,
            latest_updated_datetime,
        )

        return latest_updated_datetime

    def _process_single_vulnerability(self, vulnerability) -> None:
        """Process a single vulnerability."""
        cve_id = vulnerability.get("cve", "unknown")

        self._info("Processing vulnerability {0}...", cve_id)

        vulnerability_bundle = self._create_vulnerability_bundle(vulnerability)
        self._send_bundle(vulnerability_bundle)

    def _create_vulnerability_bundle(self, vulnerability) -> Bundle:
        """Create a vulnerability bundle."""
        author = self.author
        source_name = self._source_name()
        object_marking_refs = [self.tlp_marking]
        confidence_level = self._confidence_level()

        bundle_builder = VulnerabilityBundleBuilder(
            vulnerability,
            author,
            source_name,
            object_marking_refs,
            confidence_level,
        )
        return bundle_builder.build()
