"""OpenCTI CrowdStrike malware builder module."""

from typing import Any, List, Optional

from crowdstrike_feeds_services.utils import (
    create_external_reference,
    create_kill_chain_phase,
    create_malware,
    create_sector,
    create_targets_relationships,
    create_uses_relationships,
    create_variant_of_relationships,
    flexible_timestamp_to_datetime,
    remove_html_tags,
)
from crowdstrike_feeds_services.utils.constants import (
    CS_CAPABILITY_TO_MALWARE_TYPE,
    CS_KILL_CHAIN_TO_LOCKHEED_MARTIN_CYBER_KILL_CHAIN,
)
from stix2 import Identity  # type: ignore
from stix2 import (
    AttackPattern,
    Bundle,
    ExternalReference,
    KillChainPhase,
    Malware,
    MarkingDefinition,
    Relationship,
)
from stix2.v21 import _DomainObject  # type: ignore


class MalwareBundleBuilder:
    """Malware bundle builder."""

    def __init__(
        self,
        malware: dict,
        author: Identity,
        source_name: str,
        object_markings: List[MarkingDefinition],
        confidence_level: int,
        attack_patterns: Optional[List] = None,
    ) -> None:
        """Initialize malware bundle builder."""
        self.malware = malware
        self.author = author
        self.source_name = source_name
        self.object_markings = object_markings
        self.confidence_level = confidence_level
        self.attack_patterns = attack_patterns or []

        created_ts = self.malware["created_timestamp"]
        self.created_timestamp = flexible_timestamp_to_datetime(created_ts)

        last_updated = self.malware["last_updated"]
        self.modified_timestamp = flexible_timestamp_to_datetime(last_updated)

    def _create_external_references(self) -> List[ExternalReference]:
        external_references = []

        malware_slug = self.malware.get("slug")
        if malware_slug:
            malware_url = f"https://falcon.us-2.crowdstrike.com/intelligence-v2/finished-intelligence/malware/{malware_slug}"
            external_reference = create_external_reference(
                self.source_name, str(self.malware["id"]), malware_url
            )
            external_references.append(external_reference)

        return external_references

    def _create_malware(self) -> Malware:
        """Create the main Malware entity."""
        description = self._get_description()
        external_references = self._create_external_references()
        kill_chain_phases = self._get_kill_chain_phases()
        aliases = self._get_aliases()
        malware_types = self._get_malware_types()

        return create_malware(
            name=self.malware["name"],
            created_by=self.author,
            is_family=True,
            aliases=aliases,
            malware_types=malware_types,
            description=description,
            kill_chain_phases=kill_chain_phases,
            created=self.created_timestamp,
            modified=self.modified_timestamp,
            confidence=self.confidence_level,
            external_references=external_references,
            object_markings=self.object_markings,
        )

    def _get_aliases(self) -> List[str]:
        """Get malware aliases."""
        aliases = self.malware.get("community_identifiers", [])

        return aliases

    def _get_malware_types(self) -> List[str]:
        capabilities = self.malware.get("capabilities", [])

        malware_types = []
        for capability in capabilities:
            malware_type = CS_CAPABILITY_TO_MALWARE_TYPE.get(capability.lower())
            if malware_type:
                malware_types.append(malware_type)

        return malware_types

    def _get_description(self) -> Optional[str]:
        """Get malware description, cleaning HTML if necessary."""
        description = self.malware.get("description")

        if description:
            cleaned_description = remove_html_tags(description)
            return cleaned_description

        return None

    def _get_kill_chain_phases(self) -> List[KillChainPhase]:
        """Extract kill chain phases from malware data."""
        kill_chain_phases = []

        for kill_chain in self.malware.get("kill_chain", []):
            lh_kill_chain = CS_KILL_CHAIN_TO_LOCKHEED_MARTIN_CYBER_KILL_CHAIN.get(
                kill_chain
            )
            if lh_kill_chain:
                kill_chain_phase = create_kill_chain_phase(
                    "lockheed-martin-cyber-kill-chain", lh_kill_chain
                )
                kill_chain_phases.append(kill_chain_phase)

        return kill_chain_phases

    def _create_targeted_sectors(self) -> List[Identity]:
        """Create sector entities from target_industries if available."""
        target_industries = self.malware.get("target_industries", [])
        if not target_industries:
            return []

        sectors = []
        for industry in target_industries:
            name = industry.get("name")
            if name and name.strip():
                sector = create_sector(name, created_by=self.author)
                sectors.append(sector)

        return sectors

    def _create_variant_malware(self) -> List[Malware]:
        """Create variant malware entities if available."""
        variant_of = self.malware.get("variant_of", [])
        if not variant_of:
            return []

        variant_malware = []
        for variant in variant_of:
            name = variant.get("name")
            if name and name.strip():
                malware = create_malware(name, created_by=self.author)
                variant_malware.append(malware)

        return variant_malware

    def _create_previous_stage_malware(self) -> List[Malware]:
        """Create previous stage malware entities if available."""
        next_stage_of = self.malware.get("next_stage_of", [])
        if not next_stage_of:
            return []

        previous_stage_malware = []
        for previous_stage in next_stage_of:
            name = previous_stage.get("name")
            if name and name.strip():
                malware = create_malware(name, created_by=self.author)
                previous_stage_malware.append(malware)

        return previous_stage_malware

    def _get_attack_patterns(self) -> List[AttackPattern]:
        """Get AttackPatterns data."""
        return self.attack_patterns

    def _create_uses_relationships(
        self, sources: List[_DomainObject], targets: List[_DomainObject]
    ) -> List[Relationship]:
        """Create 'uses' relationships between Malware and AttackPatterns."""
        return create_uses_relationships(
            self.author,
            sources,
            targets,
            self.confidence_level,
            self.object_markings,
            start_time=self.created_timestamp,
        )

    def _create_targets_relationships(
        self, sources: List[_DomainObject], targets: List[_DomainObject]
    ) -> List[Relationship]:
        """Create 'targets' relationships between Malware and Sectors."""
        return create_targets_relationships(
            self.author,
            sources,
            targets,
            self.confidence_level,
            self.object_markings,
            start_time=self.created_timestamp,
        )

    def _create_variant_of_relationships(
        self, sources: List[_DomainObject], targets: List[_DomainObject]
    ) -> List[Relationship]:
        """Create 'variant-of' relationships between Malware and other Malware."""
        return create_variant_of_relationships(
            self.author,
            sources,
            targets,
            self.confidence_level,
            self.object_markings,
        )

    def build(self) -> Bundle:
        """Build malware bundle."""
        # Create bundle with author
        bundle_objects: List[Any] = [self.author]

        # Add object marking definitions to bundle
        bundle_objects.extend(self.object_markings)

        # Create main malware entity and add to bundle
        malware_entity = self._create_malware()
        bundle_objects.append(malware_entity)

        # Create attack patterns from MITRE data and add to bundle
        attack_patterns = self._get_attack_patterns()
        bundle_objects.extend(attack_patterns)

        # Create uses relationships between malware and attack patterns
        if attack_patterns:
            malware_uses_attack_patterns = self._create_uses_relationships(
                [malware_entity],
                attack_patterns,  # type: ignore
            )
            bundle_objects.extend(malware_uses_attack_patterns)

        # Create target sectors and add to bundle
        target_sectors = self._create_targeted_sectors()
        bundle_objects.extend(target_sectors)

        # Create targets relationships between malware and sectors
        if target_sectors:
            malware_targets_sectors = self._create_targets_relationships(
                [malware_entity],
                target_sectors,  # type: ignore
            )
            bundle_objects.extend(malware_targets_sectors)

        # Create variant malware
        variant_malware = self._create_variant_malware()
        bundle_objects.extend(variant_malware)

        # Create variant-of relationships between malware and variants
        if variant_malware:
            malware_variant_of_malware = self._create_variant_of_relationships(
                variant_malware,  # type: ignore
                [malware_entity],
            )
            bundle_objects.extend(malware_variant_of_malware)

        # Create previous stage malware
        previous_stage_malware = self._create_previous_stage_malware()
        bundle_objects.extend(previous_stage_malware)

        # Create uses relationships between previous stage malware and current malware
        if previous_stage_malware:
            malware_uses_malware = self._create_uses_relationships(
                previous_stage_malware,  # type: ignore
                [malware_entity],
            )
            bundle_objects.extend(malware_uses_malware)

        return Bundle(objects=bundle_objects, allow_custom=True)
