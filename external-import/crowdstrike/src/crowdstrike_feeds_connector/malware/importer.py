"""OpenCTI CrowdStrike malware importer module."""

from datetime import datetime
from typing import Any, Dict, Generator, List, Optional

from crowdstrike_feeds_services.client.malware import MalwareAPI
from crowdstrike_feeds_services.utils import (
    create_attack_pattern,
    datetime_to_timestamp,
    flexible_timestamp_to_datetime,
    paginate,
    timestamp_to_datetime,
)
from pycti.connector.opencti_connector_helper import (  # type: ignore  # noqa: E501
    OpenCTIConnectorHelper,
)
from stix2 import Bundle, Identity, MarkingDefinition  # type: ignore

from ..importer import BaseImporter
from .builder import MalwareBundleBuilder


class MalwareImporter(BaseImporter):
    """CrowdStrike malware importer."""

    _NAME = "Malware"

    _LATEST_MALWARE_TIMESTAMP = "latest_malware_timestamp"

    def __init__(
        self,
        helper: OpenCTIConnectorHelper,
        author: Identity,
        default_latest_timestamp: int,
        tlp_marking: MarkingDefinition,
    ) -> None:
        """Initialize CrowdStrike malware importer."""
        super().__init__(helper, author, tlp_marking)
        self.malware_api_cs = MalwareAPI(helper)
        self.default_latest_timestamp = default_latest_timestamp

    def run(self, state: Dict[str, Any]) -> Dict[str, Any]:
        """Run importer."""
        self._info("Running malware importer with state: {0}...", state)

        fetch_timestamp = state.get(
            self._LATEST_MALWARE_TIMESTAMP, self.default_latest_timestamp
        )
        fetch_datetime = timestamp_to_datetime(fetch_timestamp)

        new_state = state.copy()

        latest_malware_updated_timestamp = None

        for malware_batch in self._fetch_malware(fetch_datetime):
            if not malware_batch:
                break

            latest_malware_updated_datetime = self._process_malware(malware_batch)

            if latest_malware_updated_datetime is not None:
                latest_malware_updated_timestamp = datetime_to_timestamp(
                    latest_malware_updated_datetime
                )

                new_state[self._LATEST_MALWARE_TIMESTAMP] = (
                    latest_malware_updated_timestamp
                )
                self._set_state(new_state)

        latest_malware_timestamp = latest_malware_updated_timestamp or fetch_timestamp

        self._info(
            "Malware importer completed, latest fetch {0}.",
            timestamp_to_datetime(latest_malware_timestamp),
        )

        return {self._LATEST_MALWARE_TIMESTAMP: latest_malware_timestamp}

    def _fetch_malware(self, start_datetime: datetime) -> Generator[List, None, None]:
        limit = 50
        sort = "last_updated|asc"
        fql_filter = f"last_updated:>'{start_datetime.isoformat()}'"

        paginated_query = paginate(self._query_malware_entities)

        return paginated_query(limit=limit, sort=sort, fql_filter=fql_filter)

    def _query_malware_entities(
        self,
        limit: int = 50,
        offset: int = 0,
        sort: Optional[str] = None,
        fql_filter: Optional[str] = None,
    ):
        self._info(
            "Query malware limit: {0}, offset: {1}, sort: {2}, filter: {3}",
            limit,
            offset,
            sort,
            fql_filter,
        )

        malware = self.malware_api_cs.query_malware_entities(
            limit=limit, offset=offset, sort=sort, filter=fql_filter
        )

        return malware

    def _process_malware(self, malware_list: List) -> Optional[datetime]:
        malware_count = len(malware_list)
        self._info("Processing {0} malware entities...", malware_count)

        latest_updated_datetime = None

        for malware in malware_list:
            self._process_single_malware(malware)

            last_updated = malware["last_updated"]
            if last_updated is None:
                self._error(
                    "Missing last_updated date for malware {0} ({1})",
                    malware["name"],
                    malware["id"],
                )
                continue

            if (
                latest_updated_datetime is None
                or last_updated > latest_updated_datetime
            ):
                latest_updated_datetime = last_updated

        self._info(
            "Processing malware completed (imported: {0}, latest: {1})",
            malware_count,
            latest_updated_datetime,
        )

        return flexible_timestamp_to_datetime(latest_updated_datetime)

    def _process_single_malware(self, malware) -> None:
        self._info("Processing malware {0} ({1})...", malware["name"], malware["id"])

        malware_bundle = self._create_malware_bundle(malware)

        self._send_bundle(malware_bundle)

    def _create_malware_bundle(self, malware) -> Bundle:
        author = self.author
        source_name = self._source_name()
        object_marking_refs = [self.tlp_marking]
        confidence_level = self._confidence_level()

        attack_patterns = self._get_and_create_attack_patterns(malware)

        bundle_builder = MalwareBundleBuilder(
            malware,
            author,
            source_name,
            object_marking_refs,
            confidence_level,
            attack_patterns,
        )
        return bundle_builder.build()

    def _get_and_create_attack_patterns(self, malware) -> List:
        """Get MITRE ATT&CK TTPs and create AttackPattern entities."""
        try:
            malware_id = malware["id"]
            malware_name = malware["name"]

            self._info(
                "Processing MITRE ATT&CK TTPs for malware: {0} (ID: {1})",
                malware_name,
                malware_id,
            )

            mitre_attacks = malware.get("mitre", [])

            if not mitre_attacks:
                self._info("No MITRE ATT&CK TTPs found for malware: {0}", malware_name)
                return []

            self._info(
                "Retrieved {0} TTPs for malware: {1}", len(mitre_attacks), malware_name
            )

            attack_patterns = []
            for attack in mitre_attacks:
                technique_id = attack.get("technique_id")
                technique_name = attack.get("technique_name")

                if technique_id and technique_name:
                    attack_pattern = create_attack_pattern(
                        name=technique_name,
                        mitre_id=technique_id,
                        created_by=self.author,
                        object_markings=[self.tlp_marking],
                    )
                    attack_patterns.append(attack_pattern)

            self._info(
                "Created {0} AttackPattern entities for malware: {1}",
                len(attack_patterns),
                malware_name,
            )
            return attack_patterns

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] Failed to retrieve and process TTPs for malware.",
                {
                    "error": err,
                    "malware_id": malware.get("id"),
                    "malware_name": malware.get("name"),
                },
            )
            return []
