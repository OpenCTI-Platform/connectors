import datetime
import io
import json
import sys
import time

import magic
import pyzipper
import requests
import stix2
from connector.settings import ConnectorSettings
from pycti import OpenCTIConnectorHelper


class MalwareBazaarRecentAdditions:
    """
    Process recent additions to Malware Bazaar
    """

    def __init__(self, config: ConnectorSettings, helper: OpenCTIConnectorHelper):
        self.config = config
        self.helper = helper
        self.identity = self.helper.api.identity.create(
            type="Organization",
            name="MalwareBazaar",
            description="For more info, see https://bazaar.abuse.ch/about/",
        )
        self.api_url = self.config.malwarebazaar_recent_additions.api_url
        self.api_key = (
            self.config.malwarebazaar_recent_additions.api_key.get_secret_value()
        )
        self.cooldown_seconds = (
            self.config.malwarebazaar_recent_additions.cooldown_seconds
        )
        self.labels_color = self.config.malwarebazaar_recent_additions.labels_color
        self.include_tags = self.config.malwarebazaar_recent_additions.include_tags
        self.include_reporters = (
            self.config.malwarebazaar_recent_additions.include_reporters
        )
        labels = self.config.malwarebazaar_recent_additions.labels
        self.label_ids = []
        if labels:
            for label in labels:
                created_label = self.helper.api.label.read_or_create_unchecked(
                    value=label, color=self.labels_color
                )
                if created_label is not None:
                    self.label_ids.append(created_label["id"])

    def process(self):
        """MalwareBazaar Recent Additions main process."""
        self.helper.log_info("Running MalwareBazaar Recent Additions processing...")

        try:
            self.update_state()
            recent_additions_list = self.get_recent_additions()
            for recent_additions_dict in recent_additions_list:
                self.helper.log_info(f"Processing: {recent_additions_dict}")
                sha256 = recent_additions_dict["sha256_hash"]
                reporter = recent_additions_dict["reporter"]
                file_name = recent_additions_dict["file_name"]
                tags = (
                    recent_additions_dict["tags"]
                    if recent_additions_dict["tags"]
                    else []
                )
                if self.include_reporters and reporter not in self.include_reporters:
                    self.helper.log_info(
                        f"Skipping {sha256} as it was from a reporter not in the included list: {reporter}"
                    )
                    continue
                if self.include_tags and not any(
                    (x in tags for x in self.include_tags)
                ):
                    self.helper.log_info(
                        f"Skipping {sha256} as it did not contain a tag in the included list."
                    )
                    continue
                if self.artifact_exists_opencti(sha256):
                    self.helper.log_info(
                        f'Skipping Artifact with "{sha256}" as it already exists in OpenCTI.'
                    )
                    continue
                try:
                    file_contents = self.download_unzip(sha256)
                except Exception:
                    self.helper.log_error(f"Error downloading and unzipping {sha256}.")
                    continue
                response = self.upload_artifact_opencti(
                    file_name,
                    file_contents,
                    f"Uploaded to MalwareBazaar by Twitter user: {reporter}.",
                )
                external_reference = self.helper.api.external_reference.create(
                    source_name="MalwareBazaar Recent Additions",
                    url=f"https://bazaar.abuse.ch/sample/{sha256}/",
                    description="MalwareBazaar Recent Additions",
                )
                self.helper.api.stix_cyber_observable.add_external_reference(
                    id=response["id"],
                    external_reference_id=external_reference["id"],
                )
                for label_id in self.label_ids:
                    self.helper.api.stix_cyber_observable.add_label(
                        id=response["id"], label_id=label_id
                    )
                for tag in tags:
                    label = self.helper.api.label.read_or_create_unchecked(
                        value=tag, color=self.labels_color
                    )
                    if label is not None:
                        self.helper.api.stix_cyber_observable.add_label(
                            id=response["id"], label_id=label["id"]
                        )
                tags_indicator = tags
                tags.insert(0, "malware-bazaar")
                indicator_id = self.create_stix_indicator(sha256, tags_indicator)
                self.create_relationship(response["id"], indicator_id)

            self.helper.log_info("Processing completed successfully")

        except (KeyboardInterrupt, SystemExit):
            self.helper.log_info("Connector stop")
            sys.exit(0)
        except requests.exceptions.HTTPError as err:
            if "403" in str(err):
                msg = "403 Forbidden: Invalid API key. Please verify that your API credentials are correct"
                self.helper.connector_logger.error(msg)
            else:
                self.helper.log_error(f"HTTP error: {err}")
        except Exception as e:
            self.helper.log_error(f"Error in process: {e}")

    def run(self) -> None:
        """
        Start the connector, schedule its runs and trigger the first run.
        It allows you to schedule the process to run at a certain interval.
        This specific scheduler from the `OpenCTIConnectorHelper` will also check the queue size of a connector.
        If `CONNECTOR_QUEUE_THRESHOLD` is set, and if the connector's queue size exceeds the queue threshold,
        the connector's main process will not run until the queue is ingested and reduced sufficiently,
        allowing it to restart during the next scheduler check. (default is 500MB)

        Example:
            - If `CONNECTOR_DURATION_PERIOD=PT5M`, then the connector is running every 5 minutes.
        """
        self.helper.log_info("Starting MalwareBazaar Recent Additions Connector")

        self.helper.schedule_process(
            message_callback=self.process,
            duration_period=self.config.connector.duration_period.total_seconds(),
        )

    def get_recent_additions(self):
        """
        Get recent additions to MalwareBazaar.

        See https://bazaar.abuse.ch/api/#latest_additions

        returns: a dict containing the recent additions in the last
                 60 minutes to MalwareBazaar.
        """
        headers = {"Auth-Key": self.api_key}
        data = {"query": "get_recent", "selector": "time"}
        resp = requests.post(self.api_url, data=data, headers=headers)
        resp.raise_for_status()
        recent_additions_list = resp.json()
        if "data" in recent_additions_list:
            return recent_additions_list["data"]
        else:
            self.helper.log_error(
                "Key 'data' not found in the response from MalwareBazaar API."
            )
            return []

    def artifact_exists_opencti(self, sha256):
        """
        Determine whether or not an Artifact already exists in OpenCTI.

        sha256: a str representing the sha256 of the artifact's file contents
        returns: a bool indicating the aforementioned
        """
        custom_attributes = """
            id
            entity_type
        """
        response = self.helper.api.stix_cyber_observable.read(
            filters={
                "mode": "and",
                "filters": [{"key": "hashes.SHA-256", "values": [sha256]}],
                "filterGroups": [],
            },
            customAttributes=custom_attributes,
        )
        if response:
            return True
        return False

    def upload_artifact_opencti(self, file_name, file_contents, description):
        """
        Upload a file to OpenCTI.

        file_name: a str representing the name of the file
        file_contents: a bytes object representing the file contents
        description: a str representing the description for the upload

        returns: response of upload
        """
        mime_type = magic.from_buffer(file_contents, mime=True)
        kwargs = {
            "file_name": file_name,
            "data": file_contents,
            "mime_type": mime_type,
            "x_opencti_description": description,
            "objectMarking": stix2.TLP_WHITE["id"],
        }
        return self.helper.api.stix_cyber_observable.upload_artifact(**kwargs)

    def download_unzip(self, sha256):
        """
        Download and unzip a sample from MalwareBazaar.

        sha256: a str representing the sample's sha256.
        returns: a bytes object containing the contents of the file
        """
        headers = {"Auth-Key": self.api_key}
        data = {"query": "get_file", "sha256_hash": sha256}
        resp = requests.post(self.api_url, data=data, headers=headers)
        zip_contents = resp.content
        zip_obj = io.BytesIO(zip_contents)
        zip_file = pyzipper.AESZipFile(zip_obj)
        zip_file.setpassword(b"infected")
        file_name = zip_file.namelist()[0]
        return zip_file.read(file_name)

    def update_state(self):
        timestamp = int(time.time())
        interval = self.cooldown_seconds
        new_state = {"last_run": timestamp}
        current_state = self.helper.get_state()
        self.helper.log_info("Actual state: " + json.dumps(current_state, indent=4))
        if current_state is None:
            self.helper.set_state(new_state)
            self.helper.log_info("Initial state: " + json.dumps(new_state))
        else:
            if "last_run" in current_state:
                last_run = current_state["last_run"]
                if timestamp - last_run < interval:
                    self.helper.log_info("Waiting 300 seconds...")
                    return
            current_state["last_run"] = timestamp
            self.helper.set_state(current_state)
            self.helper.log_info("State update: " + json.dumps(current_state))

    def create_stix_indicator(self, sha256, tags="malware-bazaar"):
        """
        Create a STIX indicator for the given sha256.

        sha256: a str representing the sha256 of the artifact

        returns: the created indicator
        """
        pattern = f"[file:hashes.'SHA-256' = '{sha256}']"
        valid_from = (
            datetime.datetime.now(datetime.timezone.utc)
            .isoformat(timespec="milliseconds")
            .replace("+00:00", "Z")
        )
        indicator = self.helper.api.indicator.create(
            name=f"{sha256}",
            description=f"Indicator for hash SHA256 {sha256}",
            pattern=pattern,
            pattern_type="stix",
            valid_from=valid_from,
            x_opencti_main_observable_type="Artifact",
            objectLabel=tags,
            objectMarking=stix2.TLP_WHITE.id,
        )
        if indicator:
            self.helper.log_info(f"Indicator with {sha256} created in OpenCTI.")
            indicator_id = indicator["id"]
            return indicator_id
        else:
            self.helper.log_error("Error creating indicator in OpenCTI.")

    def create_relationship(self, artifact_id, indicator_id):
        """
        Create a relationship between an indicator and an artifact.
        The indicator is based-on the artifact (observable).

        :param artifact_id: ID of the artifact
        :param indicator_id: ID of the indicator
        :return: None
        """
        now = (
            datetime.datetime.now(datetime.timezone.utc)
            .isoformat(timespec="milliseconds")
            .replace("+00:00", "Z")
        )
        relation = self.helper.api.stix_core_relationship.create(
            fromType="Indicator",
            fromId=indicator_id,
            toType="Artifact",
            toId=artifact_id,
            relationship_type="based-on",
            description="Indicator based on this artifact.",
            first_seen=now,
            last_seen=now,
            objectMarking=stix2.TLP_WHITE.id,
        )
        if relation:
            self.helper.log_info(f"Relation {relation['id']} created in OpenCTI.")
        else:
            self.helper.log_error("Error creating relation in OpenCTI.")
