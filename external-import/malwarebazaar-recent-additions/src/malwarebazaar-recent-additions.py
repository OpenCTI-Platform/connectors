"""
MalwareBazaar is a platform from abuse.ch and Spamhaus, dedicated to sharing malware samples with the infosec
community, antivirus vendors, and threat intelligence providers.

This connector will communicate with the Malware Bazaar API and pull data into OpenCTI.
"""

import base64
import datetime
import hashlib
import io
import json
import os
import sys
import time

import magic
import pyzipper
import requests
import stix2
import yaml
from pycti import OpenCTIApiClient, OpenCTIConnectorHelper, get_config_variable


class MalwareBazaarRecentAdditions:
    """
    Process recent additions to Malware Bazaar
    """

    def __init__(self):
        """
        Init Malware Bazaar Connector
        """
        # Instantiate the connector helper from config
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path, encoding="utf-8"), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        self.helper = OpenCTIConnectorHelper(config)
        self.identity = self.helper.api.identity.create(
            type="Organization",
            name="MalwareBazaar",
            description="For more info, see https://bazaar.abuse.ch/about/",
        )

        self.api_url = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_API_URL",
            ["malwarebazaar_recent_additions", "api_url"],
            config,
        )

        self.cooldown_seconds = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_COOLDOWN_SECONDS",
            ["malwarebazaar_recent_additions", "cooldown_seconds"],
            config,
        )
        self.cooldown_seconds = int(self.cooldown_seconds)

        self.labels_color = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_LABELS_COLOR",
            ["malwarebazaar_recent_additions", "labels_color"],
            config,
        )

        self.url_base = get_config_variable(
            "OPENCTI_URL",
            ["opencti", "url"],
            config,
        )

        self.api_key_opencti = get_config_variable(
            "OPENCTI_TOKEN",
            ["opencti", "token"],
            config,
        )

        self.include_tags = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_INCLUDE_TAGS",
            ["malwarebazaar_recent_additions", "include_tags"],
            config,
        )
        if self.include_tags:
            self.include_tags = self.include_tags.split(",")

        self.include_reporters = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_INCLUDE_REPORTERS",
            ["malwarebazaar_recent_additions", "include_reporters"],
            config,
        )
        if self.include_reporters:
            self.include_reporters = self.include_reporters.split(",")

        labels = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_LABELS",
            ["malwarebazaar_recent_additions", "labels"],
            config,
        )
        self.label_ids = []

        # Create default labels
        if labels:
            labels = labels.split(",")
            for label in labels:
                created_label = self.helper.api.label.read_or_create_unchecked(
                    value=label, color=self.labels_color
                )
                if created_label is not None:
                    self.label_ids.append(created_label["id"])

        self.disable_malware_sample = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_DISABLE_MALWARE_SAMPLE",
            ["malwarebazaar_recent_additions", "disable_malware_sample"],
            config,
        )
        self.disable_malware_sample = bool(self.disable_malware_sample)

        self.score = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_SCORE",
            ["malwarebazaar_recent_additions", "score"],
            config,
        )
        self.score = int(self.score)

        self.create_indicator = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_CREATE_INDICATOR",
            ["malwarebazaar_recent_additions", "create_indicator"],
            config,
        )
        self.create_indicator = bool(self.create_indicator)

        self.update_existing_data = get_config_variable(
            "MALWAREBAZAAR_RECENT_ADDITIONS_UPDATE_EXISTING",
            ["malwarebazaar_recent_additions", "update_existing_data"],
            config,
        )
        self.update_existing_data = bool(self.update_existing_data)

    def run(self):
        """
        Run Malware Bazaar connector in a loop
        """
        self.helper.log_info("Starting MalwareBazaar Recent Additions Connector")
        while True:
            try:
                self.update_state()
                recent_additions_list = self.get_recent_additions()
                for recent_additions_dict in recent_additions_list:
                    self.helper.log_info(f"Processing: {recent_additions_dict}")
                    sha256 = recent_additions_dict["sha256_hash"]
                    sha1 = recent_additions_dict["sha1_hash"]
                    md5 = recent_additions_dict["md5_hash"]
                    reporter = recent_additions_dict["reporter"]
                    file_name = recent_additions_dict["file_name"]
                    tags = (
                        recent_additions_dict["tags"]
                        if recent_additions_dict["tags"]
                        else []
                    )

                    # If the artifact has an excluded tag, skip processing
                    if self.include_reporters:
                        if reporter not in self.include_reporters:
                            self.helper.log_info(
                                f"Skipping {sha256} as it was from a reporter not in the included list: {reporter}"
                            )
                            continue

                    if self.include_tags:
                        if not any(x in tags for x in self.include_tags):
                            self.helper.log_info(
                                f"Skipping {sha256} as it did not contain a tag in the included list."
                            )
                            continue

                    # If the artifact already exists in OpenCTI skip it
                    if self.artifact_exists_opencti(sha256):
                        self.helper.log_info(
                            f'Skipping Artifact with "{sha256}" as it already exists in OpenCTI.'
                        )
                        continue

                    # Download the artifact and unzip with default "infected" password
                    try:
                        # "sha512_computed" is based on the "real" malware sample regardless of the
                        # "disable_malware_sample" setting.
                        # "file_contents" will either be the "real" malware sample or a benign replacement based on the
                        # "disable_malware_sample" setting.
                        file_data = self.download_unzip(sha256)
                        file_contents = file_data["file_contents"]
                        sha512 = file_data["sha512_computed"]
                        mime_type = file_data["mime_type"]

                        # Using the Observable Create API to create an Artifact with the proper Hash values and
                        # either the real malware sample or the replaced benign sample, based on the
                        # "disable_malware_sample" setting.
                        response = self.helper.api.stix_cyber_observable.create(
                            type="Artifact",
                            update=self.update_existing_data,
                            createIndicator=self.create_indicator,
                            x_opencti_additional_names=sha256,
                            objectMarking=stix2.TLP_WHITE["id"],
                            observableData={
                                "type": "Artifact",
                                "mime_type": mime_type,
                                "x_opencti_additional_names": [file_name],
                                "hashes": {
                                    "sha-1": sha1,
                                    "sha-256": sha256,
                                    "sha-512": sha512,
                                    "md5": md5,
                                },
                                "x_opencti_score": self.score,
                                "x_opencti_description": f"Uploaded to MalwareBazaar by Twitter user: {reporter}.",
                                "payload_bin": base64.b64encode(file_contents),
                            },
                        )
                    # W0703: Catching too general exception Exception (broad-except)
                    except (
                        Exception
                    ) as nested_exception_local:  # pylint: disable=broad-except
                        self.helper.log_error(
                            f"Error downloading and unzipping {sha256}. {nested_exception_local}"
                        )
                        continue

                    # Create external reference to MalwareBazaar report
                    external_reference = self.helper.api.external_reference.create(
                        source_name="MalwareBazaar Recent Additions",
                        url=f"https://bazaar.abuse.ch/sample/{sha256}/",
                        description="MalwareBazaar Recent Additions",
                    )
                    self.helper.api.stix_cyber_observable.add_external_reference(
                        id=response["id"],
                        external_reference_id=external_reference["id"],
                    )

                    # Attach all default labels if any
                    for label_id in self.label_ids:
                        self.helper.api.stix_cyber_observable.add_label(
                            id=response["id"], label_id=label_id
                        )

                    # Attach all tags as labels if any
                    for tag in tags:
                        label = self.helper.api.label.read_or_create_unchecked(
                            value=tag,
                            color=self.labels_color,
                        )
                        if label is not None:
                            self.helper.api.stix_cyber_observable.add_label(
                                id=response["id"], label_id=label["id"]
                            )

                    # Creation of the STIX indicator and relationship
                    tags_indicator = tags
                    tags.insert(0, "malware-bazaar")
                    indicator_id = self.create_stix_indicator(sha256, tags_indicator)
                    self.relation_ship(
                        self.url_base,
                        self.api_key_opencti,
                        response["id"],
                        indicator_id,
                    )

            except (KeyboardInterrupt, SystemExit):
                self.helper.log_info("Connector stop")
                sys.exit(0)

            # W0703: Catching too general exception Exception (broad-except)
            except Exception as broad_exception_local:  # pylint: disable=broad-except
                self.helper.log_error(str(broad_exception_local))

            if self.helper.connect_run_and_terminate:
                self.helper.log_info("Connector stop")
                self.helper.force_ping()
                sys.exit(0)

            self.helper.log_info(
                f"Re-checking for new additions in {self.cooldown_seconds} seconds..."
            )
            time.sleep(self.cooldown_seconds)

    def get_recent_additions(self):
        """
        Get recent additions to MalwareBazaar.

        See https://bazaar.abuse.ch/api/#latest_additions

        returns: a dict containing the recent additions in the last
                 60 minutes to MalwareBazaar.
        """

        data = {"query": "get_recent", "selector": "time"}
        resp = requests.post(self.api_url, data=data)

        # Handle the response data
        recent_additions_list = resp.json()
        if "data" in recent_additions_list:
            return recent_additions_list["data"]
        else:
            self.helper.log_error(
                "Key 'data' not found in the response from MalwareBazaar API."
            )
            return []

    def download_unzip(self, sha256):
        """
        Download and unzip a sample from MalwareBazaar.

        sha256: a str representing the sample's sha256.
        returns: Dict containing:
                                'file_contents': a bytes object containing the contents of the file
                                'sha512_computed': sha512 computed value of real malware sample,
                                'mime_type': mime_type for real malware sample

        Rate Limited to restrict the number of file downloads on our file download API to 2,000 per IP address/day.
        https://bazaar.abuse.ch/faq/#api-limit

        """
        # Generic bytes data replacement of malware controlled by disable_malware_sample config setting
        data_string = "This would normally be Malware, but we have disabled the saving of the real malware."
        # Store password in a variable
        static_password = "infected"

        #
        # Process the Malware Sample like normal from the API. We need the file regardless of the disable_malware_sample
        # in order to calculate the SHA512 value. The SHA512 is not provided via the API, but OpenCTI needs it.
        # After calculation, if disable_malware_sample=true, then the file will be replaced with a benign sample, but
        # keep the accurate SHA512
        #
        # Note: There is an API rate-limit set for download by Malware Bazaar
        #       See the policy here - https://bazaar.abuse.ch/faq/#api-limit
        #

        data = {"query": "get_file", "sha256_hash": sha256}
        resp = requests.post(self.api_url, data=data)
        zip_contents = resp.content
        zip_obj = io.BytesIO(zip_contents)
        zip_file = pyzipper.AESZipFile(zip_obj)
        zip_file.setpassword(
            static_password.encode()
        )  # stored in a variable above, as it it used multiple times.
        file_name = zip_file.namelist()[0]
        return_bytes = zip_file.read(file_name)
        # Get known hash before it is possibly replaced with Generic Bytes Data string based on
        # 'disable_malware_sample' settings
        sha512_computed = hashlib.sha512(  # pylint: disable=unexpected-keyword-arg
            return_bytes, usedforsecurity=False
        ).hexdigest()
        mime_type = magic.from_buffer(return_bytes, mime=True)

        # Replace actual malware sample file with generic/benign text
        if self.disable_malware_sample:
            # Generic bytes data replacement of malware controlled by disable_malware_sample config setting
            data_string = "This would normally be Malware, but you have disabled the saving of the real malware."
            compression_method = pyzipper.ZIP_DEFLATED
            zip_buffer = io.BytesIO()
            with pyzipper.AESZipFile(
                zip_buffer,
                "w",
                compression=compression_method,
                encryption=pyzipper.WZ_AES,
            ) as zf_tmp:
                zf_tmp.setpassword(
                    static_password.encode()
                )  # stored in a variable above, as it it used multiple times.
                zf_tmp.setencryption(pyzipper.WZ_AES, nbits=128)
                zf_tmp.writestr(
                    file_name, data_string.encode("utf-8")
                )  # Encode string to bytes
            zip_file_benign = pyzipper.AESZipFile(zip_buffer)
            zip_file_benign.setpassword(static_password.encode())
            return_bytes = zip_file_benign.read(file_name)

        return {
            "file_contents": return_bytes,
            "sha512_computed": sha512_computed,
            "mime_type": mime_type,
        }

    def artifact_exists_opencti(self, sha256):
        """
        Determine whether or not an Artifact already exists in OpenCTI.

        sha256: a str representing the sha256 of the artifact's file contents
        returns: a bool indicating the aforementioned
        """

        custom_attributes = """
            id
            entity_type
        """
        response = self.helper.api.stix_cyber_observable.read(
            filters={
                "mode": "and",
                "filters": [{"key": "hashes.SHA-256", "values": [sha256]}],
                "filterGroups": [],
            },
            customAttributes=custom_attributes,
        )

        if response:
            return True
        return False

    def update_state(self):
        """
        Update connector cycle state
        """
        timestamp = int(time.time())
        interval = self.cooldown_seconds
        new_state = {"last_run": timestamp}

        current_state = self.helper.get_state()
        self.helper.log_info("Actual state: " + json.dumps(current_state, indent=4))

        if current_state is None:
            self.helper.set_state(new_state)
            self.helper.log_info("Initial state: " + json.dumps(new_state))
        else:
            if "last_run" in current_state:
                last_run = current_state["last_run"]
                if timestamp - last_run < interval:
                    self.helper.log_info("Waiting 300 seconds...")
                    return

            current_state["last_run"] = timestamp
            self.helper.set_state(current_state)
            self.helper.log_info("State update: " + json.dumps(current_state))

    def create_stix_indicator(self, sha256, tags="malware-bazaar"):
        """
        Create a STIX indicator for the given sha256.

        sha256: a str representing the sha256 of the artifact

        returns: the created indicator
        """
        url = self.url_base
        token = self.api_key_opencti

        api_client = OpenCTIApiClient(url, token)

        pattern = f"[file:hashes.'SHA-256' = '{sha256}']"
        valid_from = (
            datetime.datetime.now(datetime.timezone.utc)
            .isoformat(timespec="milliseconds")
            .replace("+00:00", "Z")
        )

        indicator = api_client.indicator.create(
            name=f"{sha256}",
            description=f"Indicator for hash SHA256 {sha256}",
            pattern=pattern,
            pattern_type="stix",
            valid_from=valid_from,
            x_opencti_main_observable_type="Artifact",
            objectLabel=tags,
            objectMarking=stix2.TLP_WHITE["id"],
        )

        indicator_id = None
        if indicator:
            self.helper.log_info(f"Indicator with {sha256} created in OpenCTI.")
            indicator_id = indicator["id"]
        else:
            self.helper.log_error("Error creating indicator in OpenCTI.")

        return indicator_id

    def relation_ship(self, url, token, artifact_id, indicator_id):
        """
        Create Artifact and Indicator Relationship
        """
        api_client = OpenCTIApiClient(url, token)

        relation = api_client.stix_core_relationship.create(
            fromType="Artifact",
            fromId=artifact_id,
            toType="Indicator",
            toId=indicator_id,
            objectMarking=stix2.TLP_WHITE["id"],
            relationship_type="related-to",
            description="Relationship between artifact and indicator.",
            first_seen=datetime.datetime.now(datetime.timezone.utc)
            .isoformat(timespec="milliseconds")
            .replace("+00:00", "Z"),
            last_seen=datetime.datetime.now(datetime.timezone.utc)
            .isoformat(timespec="milliseconds")
            .replace("+00:00", "Z"),
        )

        if relation:
            self.helper.log_info(f"Relation {relation['id']} created in OpenCTI.")
        else:
            self.helper.log_info("Error creating relation in OpenCTI.")


if __name__ == "__main__":
    try:
        malwarebazaar_recent_additions = MalwareBazaarRecentAdditions()
        malwarebazaar_recent_additions.run()
    # W0703: Catching too general exception Exception (broad-except)
    except Exception as broad_exception:  # pylint: disable=broad-except
        print(broad_exception)
        time.sleep(10)
        sys.exit(0)
