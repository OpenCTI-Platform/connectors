import stix2
from pycti import OpenCTIConnectorHelper
from vulncheck_sdk.models.api_exploit_v3_result import ApiExploitV3Result
from vulncheck_sdk.models.api_normalized_exploit_v3_entry import (
    ApiNormalizedExploitV3Entry,
)

import vclib.util.works as works
from vclib.util.config import (
    SCOPE_MALWARE,
    SCOPE_VULNERABILITY,
    compare_config_to_target_scope,
)


def _create_vuln(
    converter_to_stix, entity: ApiExploitV3Result, logger
) -> stix2.Vulnerability:
    logger.debug(
        "[EXPLOITS] Creating vulnerability",
        {"vulnerability": entity.id},
    )
    if entity.epss is not None:
        return converter_to_stix.create_vulnerability(
            cve=entity.id,
            custom_properties={
                "x_opencti_cisa_kev": entity.in_kev,
                "x_opencti_epss_score": entity.epss.epss_score,
                "x_opencti_epss_percentile": entity.epss.epss_percentile,
            },
        )
    else:
        return converter_to_stix.create_vulnerability(
            cve=entity.id,
            custom_properties={
                "x_opencti_cisa_kev": entity.in_kev,
            },
        )


def _create_malware(
    converter_to_stix,
    logger,
    exploit: ApiNormalizedExploitV3Entry,
) -> stix2.Malware:
    logger.debug(
        "[EXPLOITS] Creating malware object from exploit",
        {"exploit_url": exploit.url},
    )
    return converter_to_stix.create_malware(
        name=exploit.url,
        description=f"{exploit.url}\n\n{exploit.name}",
        is_family=False,
        first_seen=exploit.date_added,
    )


def _create_rel_exploits(
    malware: stix2.Malware,
    vulnerability: stix2.Vulnerability,
    converter_to_stix,
    logger,
) -> stix2.Relationship:
    logger.debug(
        '[EXPLOITS] Creating "exploits" relationship',
    )
    return converter_to_stix.create_relationship(
        source_id=malware["id"],
        relationship_type="exploits",
        target_id=vulnerability["id"],
    )


def _extract_stix_from_exploits(
    converter_to_stix,
    entities: list[ApiExploitV3Result],
    target_scope: list[str],
    logger,
) -> list:
    result = []
    logger.info("[EXPLOITS] Parsing data into STIX objects")

    for entity in entities:
        vuln = None

        if SCOPE_VULNERABILITY in target_scope:
            vuln = _create_vuln(
                converter_to_stix=converter_to_stix, entity=entity, logger=logger
            )
            result.append(vuln)

        if SCOPE_MALWARE and entity.exploits is not None:
            for exploit in entity.exploits:
                malware = _create_malware(
                    exploit=exploit,
                    converter_to_stix=converter_to_stix,
                    logger=logger,
                )
                result.append(malware)
                if vuln is not None:
                    result.append(
                        _create_rel_exploits(
                            malware=malware,
                            vulnerability=vuln,
                            converter_to_stix=converter_to_stix,
                            logger=logger,
                        )
                    )

    return result


def collect_exploits(
    config, helper: OpenCTIConnectorHelper, client, converter_to_stix, logger, _: dict
) -> None:
    source_name = "Exploits"

    target_scope = [SCOPE_VULNERABILITY, SCOPE_MALWARE]
    target_scope = compare_config_to_target_scope(
        config=config,
        target_scope=target_scope,
        name=source_name.upper(),
        logger=logger,
    )

    if target_scope == []:
        logger.info("[EXPLOITS] Exploits is out of scope, skipping")
        return

    logger.info("[EXPLOITS] Starting collection")
    entities = client.get_exploits()

    # Initiate new work
    work_id = works.start_work(helper=helper, logger=logger, work_name=source_name)

    stix_objects = _extract_stix_from_exploits(
        converter_to_stix=converter_to_stix,
        entities=entities,
        target_scope=target_scope,
        logger=logger,
    )

    works.finish_work(
        helper=helper,
        logger=logger,
        stix_objects=stix_objects,
        work_id=work_id,
        work_name=source_name,
    )
    logger.info("[EXPLOITS] Data Source Completed!")
