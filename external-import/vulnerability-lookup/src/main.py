"""
OpenCTI External Import Connector: CIRCL CVE Search API
Stephen Green: https://github.com/XGREENi3
Thomas Murray Cyber
"""
import os
import yaml
import requests
import time
import stix2
import uuid
from datetime import datetime, timedelta, timezone
from pycti import OpenCTIConnectorHelper, get_config_variable
import traceback


class CIRCLConnector:
    def __init__(self):
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )

        self.helper = OpenCTIConnectorHelper({
            "opencti": {
                "url": get_config_variable("OPENCTI_URL", ["opencti", "url"], config),
                "token": get_config_variable("OPENCTI_TOKEN", ["opencti", "token"], config),
            },
            "connector": config.get("connector", {}),
        })

        self.api_url = get_config_variable("CIRCL_API_URL", ["api_url"], config, default="https://vulnerability.circl.lu/api")
        self.kev_list_url = get_config_variable("CIRCL_KEV_LIST_URL", ["kev_list_url"], config, default="https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json")
        self.polling_interval = int(get_config_variable("CONNECTOR_RUN_INTERVAL", ["polling_interval"], config, default=240))
        self.vendor_filters = get_config_variable("CIRCL_VENDOR_FILTERS", ["vendor_filters"], config, default=[])
        if isinstance(self.vendor_filters, str):
            self.vendor_filters = [v.strip() for v in self.vendor_filters.split(",")]

        self.use_vendor_filtering = get_config_variable("CIRCL_USE_VENDOR_FILTERING", ["use_vendor_filtering"], config, True)
        if isinstance(self.use_vendor_filtering, str):
            self.use_vendor_filtering = self.use_vendor_filtering.lower() in ["true", "1", "yes"]

        self.confidence_level = int(get_config_variable("CONNECTOR_CONFIDENCE_LEVEL", ["confidence_level"], config, 50))
        self.marking_definition = get_config_variable("CONNECTOR_MARKING_DEFINITION", ["marking_definition"], config, None)

        self.kev_cves = self.fetch_kev_list()
        self.processed_cves = set()

        self.current_state = self.helper.get_state()
        self.last_run = self.current_state.get("last_run") if self.current_state else None
        self.next_run = None
        self.software_cache = {}

    def fetch_kev_list(self):
        try:
            response = requests.get(self.kev_list_url)
            if response.status_code == 200:
                kev_data = response.json()
                return {entry["cveID"] for entry in kev_data.get("vulnerabilities", []) if "cveID" in entry}
        except Exception as e:
            self.helper.log_error(f"Error fetching KEV list: {e}")
        return set()

    def fetch_cve_details(self, cve_id):
        try:
            url = f"{self.api_url}/vulnerability/{cve_id}"
            response = requests.get(url)
            if response.status_code == 200:
                return response.json()
            else:
                self.helper.log_warning(f"Failed to fetch details for {cve_id}: HTTP {response.status_code}")
        except Exception as e:
            self.helper.log_error(f"Error fetching CVE details for {cve_id}: {e}")
        return None

    def create_cwe_labels(self, vuln_data, vuln_id):
        try:
            problem_types = vuln_data.get("containers", {}).get("cna", {}).get("problemTypes", [])
            for pt in problem_types:
                for desc in pt.get("descriptions", []):
                    cwe_id = desc.get("cweId")
                    if cwe_id:
                        label = self.create_label(cwe_id)
                        if label:
                            self.helper.api.stix_domain_object.add_label(
                                id=vuln_id,
                                label_id=label["id"]
                            )
                            self.helper.log_info(f"Added CWE label {cwe_id} to {vuln_id}")
        except Exception as e:
            self.helper.log_error(f"Error tagging CWE IDs on {vuln_id}: {traceback.format_exc()}")


    def format_timestamp_for_stix(self, timestamp_str):
        try:
            return datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
        except Exception:
            return datetime.now(timezone.utc)

    def update_run_state(self):
        now = datetime.now(timezone.utc)
        self.last_run = now.isoformat()
        self.next_run = (now + timedelta(minutes=self.polling_interval)).isoformat()
        self.helper.set_state({"last_run": self.last_run})
        self.helper.log_info(f"Run completed. Last run: {self.last_run}, Next run: {self.next_run}")

    def should_run(self):
        if not self.last_run:
            return True
        last_run_dt = datetime.fromisoformat(self.last_run)
        return datetime.now(timezone.utc) >= (last_run_dt + timedelta(minutes=self.polling_interval))

    def run(self):
        if not self.should_run():
            self.helper.log_info("Skipping execution, not yet time.")
            return

        try:
            now = datetime.now(timezone.utc)
            work_id = self.helper.api.work.initiate_work(
                self.helper.connect_id, f"CIRCL Vulnerability Lookup Run @ {now.strftime('%Y-%m-%d %H:%M:%S')}"
            )

            self.helper.log_info("Starting CIRCL Vulnerability Lookup connector...")
            vuln_count = self.process_recent_cves()
            sighting_count = self.process_sightings()

            message = f"Processed {vuln_count} CVEs and {sighting_count} sightings."
            self.helper.log_info(message)
            self.helper.api.work.to_processed(work_id, message)

            self.update_run_state()
        except Exception as e:
            self.helper.log_error(f"Exception in run method: {e}")

    def start(self):
        while True:
            try:
                self.run()
            except Exception as e:
                self.helper.log_error(f"Unhandled error: {str(e)}")
            time.sleep(60)

    def extract_cvss_data(self, metrics):
        for metric in metrics:
            if "cvssV3_1" in metric:
                cvss = metric["cvssV3_1"]
                result = {
                    "x_opencti_cvss_base_score": cvss.get("baseScore"),
                    "x_opencti_cvss_base_severity": cvss.get("baseSeverity"),
                    "x_opencti_cvss_vector_string": cvss.get("vectorString")
                }
                # Extract from fields if available, otherwise parse vectorString
                if not all([cvss.get("attackVector"), cvss.get("integrityImpact"), cvss.get("availabilityImpact"), cvss.get("confidentialityImpact")]) and cvss.get("vectorString"):
                    try:
                        vector_parts = dict(part.split(":") for part in cvss["vectorString"].split("/")[1:])
                        result.update({
                            "x_opencti_cvss_attack_vector": vector_parts.get("AV"),
                            "x_opencti_cvss_integrity_impact": vector_parts.get("I"),
                            "x_opencti_cvss_availability_impact": vector_parts.get("A"),
                            "x_opencti_cvss_confidentiality_impact": vector_parts.get("C")
                        })
                    except Exception:
                        pass
                else:
                    result.update({
                        "x_opencti_cvss_attack_vector": cvss.get("attackVector"),
                        "x_opencti_cvss_integrity_impact": cvss.get("integrityImpact"),
                        "x_opencti_cvss_availability_impact": cvss.get("availabilityImpact"),
                        "x_opencti_cvss_confidentiality_impact": cvss.get("confidentialityImpact")
                    })
                return result
        return {}

    def create_label(self, value):
        try:
            labels = self.helper.api.label.list(
                filters={"mode": "or", "filters": [{"key": "value", "values": [value], "operator": "eq"}], "filterGroups": []}
            )
            if labels:
                return labels[0]
            return self.helper.api.label.create(value=value)
        except Exception as e:
            self.helper.log_error(f"Failed to create or fetch label '{value}': {e}")
            return None

    def create_software_and_relationship(self, product, vendor, cpes, versions, vuln_id):
        cpes = cpes or [None]
        for cpe in cpes:
            version = None
            try:
                if cpe:
                    parts = cpe.split(":")
                    version = parts[5] if len(parts) > 5 and parts[5] != "*" else None
            except Exception:
                version = None
            if not version:
                try:
                    version = next((
                        v.get("lessThanOrEqual") or v.get("version")
                        for v in versions
                        if v.get("status") == "affected"
                    ), None)
                except Exception:
                    pass

            cache_key = f"{product}|{vendor}|{cpe or 'no-cpe'}|{version or 'no-version'}"
            if cache_key in self.software_cache:
                sw_id = self.software_cache[cache_key]
            else:
                try:
                    sw = stix2.Software(
                        id=f"software--{str(uuid.uuid4())}",
                        spec_version="2.1",
                        type="software",
                        name=product,
                        vendor=vendor,
                        version=version,
                        cpe=cpe
                    )
                    self.helper.send_stix2_bundle(stix2.Bundle(objects=[sw], allow_custom=True).serialize())
                    self.software_cache[cache_key] = sw.id
                    sw_id = sw.id
                except Exception as e:
                    self.helper.log_error(f"Error creating software observable for {product}: {traceback.format_exc()}")
                    continue

            try:
                rel = stix2.Relationship(
                    id=f"relationship--{str(uuid.uuid4())}",
                    relationship_type="has",
                    source_ref=sw_id,
                    target_ref=vuln_id,
                    confidence=self.confidence_level
                )
                self.helper.send_stix2_bundle(stix2.Bundle(objects=[rel], allow_custom=True).serialize())
                self.helper.log_info(
                    f"Linked software {product} (version: {version}) with CPE {cpe} to vulnerability {vuln_id}")
            except Exception as e:
                self.helper.log_error(f"Error creating relationship for {product}: {traceback.format_exc()}")

    def process_cve(self, vuln_data):
        try:
            cve_id = vuln_data.get("cveMetadata", {}).get("cveId")
            if not cve_id:
                return

            descriptions = vuln_data.get("containers", {}).get("cna", {}).get("descriptions", [])
            metrics = vuln_data.get("containers", {}).get("cna", {}).get("metrics", [])
            affected = vuln_data.get("containers", {}).get("cna", {}).get("affected", [])

            cvss_fields = self.extract_cvss_data(metrics)
            cve_obj = self.helper.api.vulnerability.create(
                name=cve_id,
                description=descriptions[0].get("value") if descriptions else None,
                confidence=self.confidence_level,
                created_by_ref=None,
                update=True,
                **cvss_fields
            )
            for sw in affected:
                vendor = sw.get("vendor")
                product = sw.get("product")
                versions = sw.get("versions", [])
                cpes = sw.get("cpes", [])
                self.create_software_and_relationship(product, vendor, cpes, versions, cve_obj["standard_id"])

            self.create_cwe_labels(vuln_data, cve_obj["standard_id"])
        except Exception as e:
            self.helper.log_error(f"Error processing CVE {cve_id}: {traceback.format_exc()}")

    def process_sightings(self):
        try:
            self.helper.log_info("Fetching recent sightings from CIRCL...")
            response = requests.get(f"{self.api_url}/sighting")
            if response.status_code != 200:
                self.helper.log_error(f"Failed to fetch sightings: HTTP {response.status_code}")
                return 0

            sightings = response.json().get("data", [])
            self.helper.log_info(f"Processing {len(sightings)} sightings")
            count = 0

            for s in sightings:
                cve_id = s.get("vulnerability")
                sighting_type = s.get("type")
                label = self.create_label(sighting_type.strip().capitalize())
                created = s.get("creation_timestamp")
                author = f"CIRCL: {s.get("author", {}).get("login", "unknown")}"
                source = s.get("source", "")

                if not cve_id or not sighting_type:
                    continue

                self.helper.log_info(f"Processing sighting for {cve_id} with type '{sighting_type}' from {author}")

                try:
                    results = self.helper.api.vulnerability.list(
                        filters={
                            "mode": "or",
                            "filters": [{"key": "name", "values": [cve_id], "operator": "eq"}],
                            "filterGroups": []
                        }
                    )
                    vuln = results[0] if results else None

                    if not vuln:
                        self.helper.log_info(f"CVE {cve_id} not found in OpenCTI, fetching and creating...")
                        cve_details = self.fetch_cve_details(cve_id)
                        if cve_details:
                            self.process_cve(cve_details)
                            results = self.helper.api.vulnerability.list(
                                filters={
                                    "mode": "or",
                                    "filters": [{"key": "name", "values": [cve_id], "operator": "eq"}],
                                    "filterGroups": []
                                }
                            )
                            vuln = results[0] if results else None

                    if not vuln:
                        self.helper.log_warning(f"Unable to process sighting: CVE {cve_id} still not found")
                        continue

                    identity = self.helper.api.identity.create(
                        type="Organization",
                        name=author,
                        description=f"Sighting reported by {author}"
                    )
                    self.helper.api.stix_domain_object.add_label(
                        id=vuln["standard_id"],
                        label_id=label["id"]
                    )
                    sighting = stix2.Sighting(
                        sighting_of_ref=vuln["standard_id"],
                        created_by_ref=identity["standard_id"],
                        where_sighted_refs=[identity["standard_id"]],
                        first_seen=self.format_timestamp_for_stix(created),
                        last_seen=self.format_timestamp_for_stix(created),
                        count=1,
                        description=f"{sighting_type.capitalize()} sighting from {author}.",
                        object_marking_refs=[]
                    )

                    bundle = stix2.Bundle(objects=[sighting], allow_custom=True)
                    self.helper.send_stix2_bundle(bundle.serialize())
                    self.helper.log_info(f"Created sighting for {cve_id}")
                    count += 1
                except Exception as e:
                    self.helper.log_error(f"Failed to create sighting for {cve_id}: {traceback.format_exc()}")
            return count
        except Exception as e:
            self.helper.log_error(f"Exception while processing sightings: {e}")
            return 0


    def process_recent_cves(self):
        try:
            self.helper.log_info("Fetching recent CVEs from CIRCL...")
            date_from = (datetime.now(timezone.utc) - timedelta(days=1)).date().isoformat()
            response = requests.get(f"{self.api_url}/vulnerability/recent", params={"after": date_from})
            if response.status_code != 200:
                self.helper.log_error(f"Failed to fetch recent CVEs: HTTP {response.status_code}")
                return 0

            cves = response.json().get("results", [])
            self.helper.log_info(f"Retrieved {len(cves)} recent CVEs")

            count = 0
            for cve_data in cves:
                try:
                    self.process_cve(cve_data)
                    count += 1
                except Exception as e:
                    self.helper.log_error(f"Failed to process CVE: {traceback.format_exc()}")
            return count
        except Exception as e:
            self.helper.log_error(f"Exception while processing recent CVEs: {e}")
            return 0

def main():
    try:
        connector = CIRCLConnector()
        connector.start()
    except Exception as e:
        print(f"Fatal error: {e}")
        time.sleep(10)


if __name__ == "__main__":
    main()
