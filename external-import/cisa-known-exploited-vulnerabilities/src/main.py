from pycti import OpenCTIConnectorHelper, get_config_variable
from stix2 import Bundle, Identity, Vulnerability, Infrastructure, Relationship
from typing import Dict, Optional
import certifi
import json
import urllib
import ssl
import sys
import datetime
import time
import os
import yaml


class Cisa:
    def __init__(self):
        # Instantiate the connector helper from config
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        self.helper = OpenCTIConnectorHelper(config)
        # Extra config
        self.cisa_catalog_url = get_config_variable(
            "CISA_CATALOG_URL", ["cisa", "catalog_url"], config
        )
        self.cisa_interval = get_config_variable(
            "CISA_INTERVAL", ["cisa", "interval"], config, True
        )
        self.update_existing_data = get_config_variable(
            "CONNECTOR_UPDATE_EXISTING_DATA",
            ["connector", "update_existing_data"],
            config,
        )
        self.tlp = get_config_variable(
            "CONNECTOR_TLP",
            ["connector", "tlp"],
            config,
        )
        self.confidence_level = get_config_variable(
            "CONNECTOR_CONFIDENCE_LEVEL",
            ["connector", "confidence_level"],
            config,
        )
        self.created_by_stix = None
        self.tlp_marking = None
        self.org = "Cybersecurity and Infrastructure Security Agency"
        self.opencti_url = get_config_variable(
            "OPENCTI_URL", ["opencti", "url"], config
        )
        self.opencti_token = get_config_variable(
            "OPENCTI_TOKEN", ["opencti", "token"], config
        )

    def get_interval(self):
        return int(self.cisa_interval) * 60 * 60 * 24

    def retrieve_data(self, url: str) -> Optional[str]:
        """
        Retrieve data from the given url.

        Parameters
        ----------
        url : str
            Url to retrieve.

        Returns
        -------
        str
            A string with the content or None in case of failure.
        """
        try:
            return (
                urllib.request.urlopen(
                    url,
                    context=ssl.create_default_context(cafile=certifi.where()),
                )
                .read()
                .decode("utf-8")
            )
        except (
            urllib.error.URLError,
            urllib.error.HTTPError,
            urllib.error.ContentTooShortError,
        ) as urllib_error:
            self.helper.log_error(f"Error retrieving url {url}: {urllib_error}")
        return None

    # Get Identity info
    def set_created_by_stix(self, org: str) -> Dict:
        if org is None:
            org = self.org
        self.helper.log_info(f"Checking CTI Service for {org}")
        created_by_stix = self.helper.api.identity.read(
            filters={"key": "name", "values": [f"{org}"]}
        )
        if created_by_stix is None:
            self.helper.log_info(
                f"{org} not found in CTI Service. Building new STIX Object"
            )
            org_stix = Identity(
                allow_custom="True",
                type="identity",
                entity_type="Organization",
                x_opencti_organization_type="Vendor",
                name=f"{org}",
                description="The Cybersecurity and Infrastructure Security Agency is a United States federal agency, an operational component under Department of Homeland Security oversight. Its activities are a continuation of the National Protection and Programs Directorate.",
            )
            self.created_by_stix = org_stix
        else:
            self.helper.log_info(f"{org} found in CTI Service")
            type = "identity"
            id = created_by_stix["standard_id"]
            name = created_by_stix["name"]
            description = created_by_stix["description"]
            org_stix = Identity(
                allow_custom="True",
                type=f"{type}",
                id=f"{id}",
                name=f"{name}",
                description=f"{description}",
                entity_type="Organization",
                x_opencti_organization_type="Vendor",
            )
            self.created_by_stix = org_stix
            self.helper.log_info(f"Created Identity Object for {org} from CTI data")

    def create_relationship_obj(self, source_ref: str, target_ref: str) -> Relationship:
        relationship_stix = Relationship(
            relationship_type="has", source_ref=source_ref, target_ref=target_ref
        )
        return relationship_stix

    def set_tlp_marking(self, tlp_mark):
        if tlp_mark is None:
            tlp_mark = self.tlp
        self.helper.log_info("Retrieving TLP Data from CTI Service")
        marking = self.helper.api.marking_definition.read(
            filters=[{"key": "definition", "values": [f"{tlp_mark}"]}]
        )
        self.tlp_marking = marking["standard_id"]
        self.helper.log_info(f"Marking Definition: {self.tlp_marking}")

    def build_bundle(self, data):
        self.helper.log_info("Building CISA Bundle")
        vuln = data
        bundle = {}
        stix_objects = []
        vuln_cve = vuln["cveID"]
        vendor_name = vuln["vendorProject"]
        product = vuln["product"]
        description = vuln["shortDescription"]
        vuln_date = vuln["dateAdded"]
        created = f"{vuln_date}T00:00:00.000Z"
        created_by_id = self.created_by_stix["id"]
        product_name = f"{vendor_name} {product}"
        marking_id = self.tlp_marking

        # check for existing CVE
        self.helper.log_info(f"Checking CTI Service for Vulnerability: {vuln_cve}")
        cti_vuln = self.helper.api.vulnerability.read(
            filters={"key": "name", "values": [f"{vuln_cve}"]}
        )
        self.helper.log_info(f"{vuln_cve} Found")
        if cti_vuln is None:
            stix_vuln = Vulnerability(
                type="vulnerability",
                name=f"{vuln_cve}",
                description=f"{description}",
                created_by_ref=self.created_by_stix["id"],
                created=f"{created}",
                object_marking_refs=[f"{marking_id}"],
            )
            stix_objects.append(stix_vuln)
        else:
            created_by = cti_vuln["createdBy"]["standard_id"]
            vuln_created = cti_vuln["created"]
            vuln_id = cti_vuln["standard_id"]
            stix_vuln = Vulnerability(
                type="vulnerability",
                id=f"{vuln_id}",
                name=f"{vuln_cve}",
                created_by_ref=f"{created_by}",
                created=f"{vuln_created}",
                object_marking_refs=[f"{marking_id}"],
            )
            stix_objects.append(stix_vuln)

        # Check for existing vendor
        self.helper.log_info(f"Checking CTI Service for Identity: {vendor_name}")
        cti_vendor = self.helper.api.identity.read(
            filters={"key": "name", "values": [f"{vendor_name}"]}
        )
        if cti_vendor is None:
            stix_org = Identity(
                allow_custom="True",
                type="identity",
                entity_type="Organization",
                name=f"{vendor_name}",
                description="Software Vendor",
                created=f"{created}",
                x_opencti_organization_type="vendor",
                created_by_ref=f"{created_by_id}",
                object_marking_refs=[f"{marking_id}"],
            )
            stix_objects.append(stix_org)
        else:
            self.helper.log_info(f"{vendor_name} was found in the CTI Service")
            vendor_id = cti_vendor["standard_id"]
            created = cti_vendor["created"]
            vendor_name = cti_vendor["name"]
            vendor_description = cti_vendor["description"]
            stix_org = Identity(
                allow_custom="True",
                type="identity",
                entity_type="Organization",
                x_opencti_organization_type="vendor",
                id=f"{vendor_id}",
                name=f"{vendor_name}",
                description=f"{vendor_description}",
                created=f"{created}",
                created_by_ref=f"{created_by_id}",
                object_marking_refs=[f"{marking_id}"],
            )
            stix_objects.append(stix_org)
            org_id = stix_org["id"]
            self.helper.log_info(f"STIX Object created for {vendor_name}")
        # Check for CTI Infrastructure
        product_name = f"{vendor_name} {product}"
        if vendor_name in product:
            product_name = f"{product}"
        self.helper.log_info(f"Checking CTI Service for Infrastructure: {product_name}")
        cti_infra = self.helper.api.infrastructure.read(
            filters={"key": "name", "values": [f"{product_name}"]}
        )
        if cti_infra is None:
            self.helper.log_info(
                f"No Existing Infrastructure Object exists for: {product_name}"
            )
            stix_infrastructure = Infrastructure(
                type="infrastructure",
                name=f"{product_name}",
                created=f"{created}",
                created_by_ref=f"{created_by_id}",
                object_marking_refs=[f"{marking_id}"],
            )
            infra_id = stix_infrastructure["id"]
            stix_objects.append(stix_infrastructure)
        else:
            self.helper.log_info(f"Infrastructure: {product_name} found!")
            infra_id = cti_infra["standard_id"]
            self.helper.log_info(f"Infrastructure ID: {infra_id}")
            stix_infrastructure = Infrastructure(
                type="infrastructure",
                id=f"{infra_id}",
                name=f"{product_name}",
                created=f"{created}",
                created_by_ref=f"{created_by_id}",
                object_marking_refs=[f"{marking_id}"],
            )
            stix_objects.append(stix_infrastructure)
        infra_vuln_relationship = Relationship(
            relationship_type="has",
            source_ref=f"{infra_id}",
            start_time=f"{created}",
            target_ref=f"{vuln_id}",
            confidence="100",
            object_marking_refs=[f"{marking_id}"],
        )
        stix_objects.append(infra_vuln_relationship)
        infra_vendor_relationship = Relationship(
            relationship_type="related-to",
            description="maintains",
            start_time=f"{created}",
            source_ref=f"{org_id}",
            target_ref=f"{infra_id}",
            confidence="100",
            object_marking_refs=[f"{marking_id}"],
        )
        stix_objects.append(infra_vendor_relationship)
        bundle = Bundle(
            self.created_by_stix,
            stix_vuln,
            stix_org,
            stix_infrastructure,
            infra_vuln_relationship,
            allow_custom="True",
        ).serialize()
        self.helper.log_info("CISA Bundle Complete")
        return bundle

    def process_data(self):
        try:
            # Get the current timestamp and check
            timestamp = int(time.time())
            current_state = self.helper.get_state()
            if current_state is not None and "last_run" in current_state:
                last_run = current_state["last_run"]
                self.helper.log_info(
                    "Connector last run: "
                    + datetime.datetime.utcfromtimestamp(last_run).strftime(
                        "%Y-%m-%d %H:%M:%S"
                    )
                )
            else:
                last_run = None
                self.helper.log_info("Connector has never run")
            # If the last_run is more than interval-1 day
            if last_run is None or (
                (timestamp - last_run) > ((int(self.cisa_interval) - 1) * 60 * 60 * 24)
            ):
                self.helper.log_info("Connector will run!")

                now = datetime.datetime.utcfromtimestamp(timestamp)
                friendly_name = "CISA run @ " + now.strftime("%Y-%m-%d %H:%M:%S")
                work_id = self.helper.api.work.initiate_work(
                    self.helper.connect_id, friendly_name
                )
                if self.cisa_catalog_url is not None and len(self.cisa_catalog_url) > 0:
                    cisa_data = self.retrieve_data(self.cisa_catalog_url)
                    self.set_created_by_stix(org=self.org)
                    self.set_tlp_marking(tlp_mark=self.tlp)
                    cisa_data = json.loads(cisa_data)
                    for vuln in cisa_data["vulnerabilities"]:
                        bundle = self.build_bundle(vuln)
                        self.send_bundle(work_id, bundle)

                # Store the current timestamp as a last run
                message = "Connector successfully run, storing last_run as " + str(
                    timestamp
                )
                self.helper.log_info(message)
                self.helper.set_state({"last_run": timestamp})
                self.helper.api.work.to_processed(work_id, message)
                self.helper.log_info(
                    "Last_run stored, next run in: "
                    + str(round(self.get_interval() / 60 / 60 / 24, 2))
                    + " days"
                )
            else:
                new_interval = self.get_interval() - (timestamp - last_run)
                self.helper.log_info(
                    "Connector will not run, next run in: "
                    + str(round(new_interval / 60 / 60 / 24, 2))
                    + " days"
                )
        except (KeyboardInterrupt, SystemExit):
            self.helper.log_info("Connector stop")
            sys.exit(0)
        except Exception as e:
            self.helper.log_error(str(e))

    def run(self):
        self.helper.log_info("Fetching CISA Known Exploited Vulnerabilities...")
        get_run_and_terminate = getattr(self.helper, "get_run_and_terminate", None)
        if callable(get_run_and_terminate) and self.helper.get_run_and_terminate():
            self.process_data()
            self.helper.force_ping()
        else:
            while True:
                self.process_data()
                time.sleep(60)

    def send_bundle(self, work_id: str, serialized_bundle: str) -> None:
        try:
            self.helper.send_stix2_bundle(
                serialized_bundle,
                entities_types=self.helper.connect_scope,
                update=self.update_existing_data,
                work_id=work_id,
            )
        except Exception as e:
            self.helper.log_error(f"Error while sending bundle: {e}")


if __name__ == "__main__":
    try:
        connector = Cisa()
        connector.run()
    except Exception as e:
        print(e)
        time.sleep(10)
        exit(0)
