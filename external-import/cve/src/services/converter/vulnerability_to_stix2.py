import datetime
from typing import Generator

import stix2
from pycti import (  # type: ignore
    Identity,
    OpenCTIConnectorHelper,
    StixCoreRelationship,
    Vulnerability,
)
from src import ConfigLoader
from src.services.client import CVEVulnerability  # type: ignore
from src.services.utils import APP_VERSION  # type: ignore


class CVEConverter:
    def __init__(self, helper: OpenCTIConnectorHelper, config: ConfigLoader):
        self.config = config
        self.helper = helper
        self.client_api = CVEVulnerability(
            api_key=self.config.cve.api_key.get_secret_value(),
            helper=self.helper,
            header=f"OpenCTI-cve/{APP_VERSION}",
        )
        self.author = self._create_author()

    def send_bundle(self, cve_params: dict, work_id: str) -> None:
        """
        Send bundle to API
        :param cve_params: Dict of params
        :param work_id: work id in string
        :return:
        """
        vulnerability_object_generator = self.vulnerabilities_to_stix2(cve_params)
        for vulnerabilities_objects in vulnerability_object_generator:
            if len(vulnerabilities_objects) != 0:
                vulnerabilities_objects.append(self.author)
                vulnerabilities_bundle = self._to_stix_bundle(vulnerabilities_objects)
                vulnerabilities_to_json = self._to_json_bundle(vulnerabilities_bundle)

                # Retrieve the author object for the info message
                info_msg = (
                    f"[CONVERTER] Sending bundle to server with {len(vulnerabilities_bundle)} objects, "
                    f"concerning {len(vulnerabilities_objects) - 1} vulnerabilities"
                )
                self.helper.connector_logger.info(info_msg)

                self.helper.send_stix2_bundle(
                    vulnerabilities_to_json,
                    work_id=work_id,
                )

    def vulnerabilities_to_stix2(self, cve_params: dict) -> Generator[list, None, None]:
        """
        Retrieve all CVEs from NVD to convert into STIX2 format
        :param cve_params: Dict of params
        :return: Generator of lists of data converted into STIX2
        """
        vulnerabilities_generator = self.client_api.get_vulnerabilities(cve_params)

        for vulnerabilities in vulnerabilities_generator:
            vulnerabilities_stix2 = [
                self._vulnerability_to_stix2(vulnerability)
                for vulnerability in vulnerabilities
            ]
            yield vulnerabilities_stix2

    def _vulnerability_to_stix2(self, vulnerability) -> stix2.Vulnerability:
        # Getting different fields
        name = vulnerability["cve"]["id"]
        description = vulnerability["cve"]["descriptions"][0]["value"]
        created_date = datetime.datetime.strptime(
            vulnerability["cve"]["published"], "%Y-%m-%dT%H:%M:%S.%f"
        )
        modified_date = datetime.datetime.strptime(
            vulnerability["cve"]["lastModified"], "%Y-%m-%dT%H:%M:%S.%f"
        )

        # Create external references
        external_reference = stix2.ExternalReference(
            source_name="NIST NVD", url=f"https://nvd.nist.gov/vuln/detail/{name}"
        )
        external_references = [external_reference]

        if "references" in vulnerability["cve"]:
            for reference in vulnerability["cve"]["references"]:
                external_reference = stix2.ExternalReference(
                    source_name=reference["source"], url=reference["url"]
                )
                external_references.append(external_reference)

        cvss_properties = {}

        # Getting CVSS 3.1 metrics
        if "cvssMetricV31" in vulnerability["cve"]["metrics"]:
            selected_cvss_entry = None
            cvss31_entries = vulnerability["cve"]["metrics"]["cvssMetricV31"]

            # Some CVEs have Primary (from NVD) and Secondary (vendor) scores.
            # Try to find the Primary CVSS rating from NVD, otherwise default to a Secondary one.
            if len(cvss31_entries) > 1:
                for index, value in enumerate(cvss31_entries):
                    if value["type"] == "Primary":
                        selected_cvss_entry = index
                    elif value["type"] == "Secondary" and selected_cvss_entry == None:
                        # Only set the index if a primary source hasn't already been found
                        selected_cvss_entry = index

            # Default to first score if no primary or secondary scores were found
            if selected_cvss_entry == None:
                selected_cvss_entry = 0

            cvss31_metrics = cvss31_entries[selected_cvss_entry]["cvssData"]
            cvss31_mapping = {
                "x_opencti_base_score": "baseScore",
                "x_opencti_base_severity": "baseSeverity",
                "x_opencti_attack_vector": "attackVector",
                "x_opencti_cvss_attack_complexity": "attackComplexity",
                "x_opencti_cvss_privileges_required": "privilegesRequired",
                "x_opencti_cvss_user_interaction": "userInteraction",
                "x_opencti_cvss_scope": "scope",
                "x_opencti_confidentiality_impact": "confidentialityImpact",
                "x_opencti_integrity_impact": "integrityImpact",
                "x_opencti_availability_impact": "availabilityImpact",
            }

            cvss_properties.update(
                {
                    opencti_key: cvss31_metrics[metric]
                    for opencti_key, metric in cvss31_mapping.items()
                    if metric in cvss31_metrics
                }
            )

        # Get CVSS v2 metrics
        if "cvssMetricV2" in vulnerability["cve"]["metrics"]:
            cvss2_entries = vulnerability["cve"]["metrics"]["cvssMetricV2"]
            cvss2_metrics = cvss2_entries[0]["cvssData"]
            cvss2_mapping = {
                "x_opencti_cvss_v2_base_score": "baseScore",
                "x_opencti_cvss_v2_access_vector": "accessVector",
                "x_opencti_cvss_v2_access_complexity": "accessComplexity",
                "x_opencti_cvss_v2_authentication": "authentication",
                "x_opencti_cvss_v2_confidentiality_impact": "confidentialityImpact",
                "x_opencti_cvss_v2_integrity_impact": "integrityImpact",
                "x_opencti_cvss_v2_availability_impact": "availabilityImpact",
            }

            cvss_properties.update(
                {
                    opencti_key: cvss2_metrics[metric]
                    for opencti_key, metric in cvss2_mapping.items()
                    if metric in cvss2_metrics
                }
            )

        # Get CVSS v4.0 metrics
        if "cvssMetricV40" in vulnerability["cve"]["metrics"]:
            cvss40_entries = vulnerability["cve"]["metrics"]["cvssMetricV40"]
            cvss40_metrics = cvss40_entries[0]["cvssData"]
            cvss40_mapping = {
                "x_opencti_cvss_v4_base_score": "baseScore",
                "x_opencti_cvss_v4_base_severity": "baseSeverity",
                "x_opencti_cvss_v4_attack_vector": "attackVector",
                "x_opencti_cvss_v4_attack_complexity": "attackComplexity",
                "x_opencti_cvss_v4_attack_requirements": "attackRequirements",
                "x_opencti_cvss_v4_privileges_required": "privilegesRequired",
                "x_opencti_cvss_v4_user_interaction": "userInteraction",
                "x_opencti_cvss_v4_confidentiality_impact_v": "vulnConfidentialityImpact",
                "x_opencti_cvss_v4_confidentiality_impact_s": "subConfidentialityImpact",
                "x_opencti_cvss_v4_integrity_impact_v": "vulnIntegrityImpact",
                "x_opencti_cvss_v4_integrity_impact_s": "subIntegrityImpact",
                "x_opencti_cvss_v4_availability_impact_v": "vulnAvailabilityImpact",
                "x_opencti_cvss_v4_availability_impact_s": "subAvailabilityImpact",
            }

            cvss_properties.update(
                {
                    opencti_key: cvss40_metrics[metric]
                    for opencti_key, metric in cvss40_mapping.items()
                    if metric in cvss40_metrics
                }
            )

        # Add CWEs if included
        cwes = []
        if "weaknesses" in vulnerability["cve"]:
            for weakness in vulnerability["cve"]["weaknesses"]:
                cwe_value = weakness["description"][0]["value"]
                if cwe_value.startswith("CWE"):
                    cwes.append(cwe_value)

            # Deduplicate the CWE list and add as vuln value
            cvss_properties["x_opencti_cwe"] = list(set(cwes))

        # Creating the vulnerability with the extracted fields
        vulnerability_to_stix2 = stix2.Vulnerability(
            id=Vulnerability.generate_id(name),
            name=name,
            created=created_date,
            modified=modified_date,
            description=description,
            created_by_ref=self.author,
            confidence=(
                100 if description is not None and len(description) > 0 else 60
            ),
            external_references=external_references,
            custom_properties=cvss_properties,
        )

        return vulnerability_to_stix2

    def _create_relationship(self, from_id: str, to_id: str, relation):
        """
        :param from_id: From id in string
        :param to_id: To id in string
        :param relation:
        :return: Relationship STIX object
        """
        return stix2.Relationship(
            id=StixCoreRelationship.generate_id(relation, from_id, to_id),
            relationship_type=relation,
            source_ref=from_id,
            target_ref=to_id,
            created_by_ref=self.author.id,
        )

    @staticmethod
    def _create_author():
        """
        :return: CVEs' default author
        """
        return stix2.Identity(
            id=Identity.generate_id("The MITRE Corporation", "organization"),
            name="The MITRE Corporation",
            identity_class="organization",
        )

    @staticmethod
    def _to_stix_bundle(stix_objects):
        """
        :return: STIX objects as a Bundle
        """
        return stix2.Bundle(objects=stix_objects, allow_custom=True)

    @staticmethod
    def _to_json_bundle(stix_bundle):
        """
        :return: STIX bundle as JSON format
        """
        return stix_bundle.serialize()
