import asyncio
import sys

from aiohttp import ClientConnectionError, ClientResponseError
from connector.models import (
    ConfigLoader,
    SecurityIncidentResponse,
    TaskResponse,
)
from connector.services import (
    ConverterToStix,
    DateTimeFormat,
    ServiceNowClient,
    Utils,
)
from pycti import OpenCTIConnectorHelper
from pydantic import ValidationError
from tenacity import RetryError


class ConnectorServicenow:
    """
    Specifications of the external import connector

    This class encapsulates the main actions, expected to be run by any external import connector.
    Note that the attributes defined below will be complemented per each connector type.
    This type of connector aim to fetch external data to create STIX bundle and send it in a RabbitMQ queue.
    The STIX bundle in the queue will be processed by the workers.
    This type of connector uses the basic methods of the helper.

    ---

    Attributes
        - `config (ConfigConnector())`:
            Initialize the connector with necessary configuration environment variables

        - `helper (OpenCTIConnectorHelper(config))`:
            This is the helper to use.
            ALL connectors have to instantiate the connector helper with configurations.
            Doing this will do a lot of operations behind the scene.

        - `converter_to_stix (ConnectorConverter(helper))`:
            Provide methods for converting various types of input data into STIX 2.1 objects.

    ---

    Best practices
        - `self.helper.api.work.initiate_work(...)` is used to initiate a new work
        - `self.helper.schedule_iso()` is used to encapsulate the main process in a scheduler
        - `self.helper.connector_logger.[info/debug/warning/error]` is used when logging a message
        - `self.helper.stix2_create_bundle(stix_objects)` is used when creating a bundle
        - `self.helper.send_stix2_bundle(stix_objects_bundle)` is used to send the bundle to RabbitMQ
        - `self.helper.set_state()` is used to set state

    """

    def __init__(self, config: ConfigLoader, helper: OpenCTIConnectorHelper):
        """Initialize the Connector with necessary configurations"""

        # Load configuration file and connection helper
        self.config = config
        self.helper = helper
        self.client = ServiceNowClient(self.helper, self.config)
        self.converter_to_stix = ConverterToStix(self.helper, self.config)
        self.utils = Utils()
        self.last_run_start_datetime = None
        self.last_run_end_datetime_with_ingested_data = None

    def _initiate_work(self) -> str:
        """Starts a work process.
        Sends a request to the API with the initiate_work method to initialize the work.

        Returns:
            str: The work ID generated by the API when initiating the work.
        """
        now_utc_isoformat = self.utils.get_now(DateTimeFormat.ISO)
        self.helper.connector_logger.info(
            "[CONNECTOR] Starting work...",
            {
                "now_utc_isoformat": now_utc_isoformat,
            },
        )

        # Friendly name will be displayed on OpenCTI platform
        friendly_name = f"ServiceNow - run @ {now_utc_isoformat}"
        return self.helper.api.work.initiate_work(
            self.config.connector.id, friendly_name
        )

    def _send_intelligence(self, work_id: str, prepared_objects: list) -> int:
        """This method prepares and sends unique STIX objects to OpenCTI.
        This method takes a list of objects prepared by the models, extracts their STIX representations, creates a
        serialized STIX bundle, and It then sends this bundle to OpenCTI.
        If prepared objects exist, the method ensures that only unique objects with an 'id' attribute are included.
        After sending the STIX objects, it keeps inform of the number of bundles sent.

        Args:
            work_id (str): The unique identifier for the work process associated with the STIX objects.
            prepared_objects (list): A list of objects containing STIX representations to be sent to OpenCTI.

        Returns:
            int : Return the length bundle sent
        """
        if prepared_objects is not None and len(prepared_objects) != 0:
            get_stix_representation_objects = [
                obj.stix2_representation for obj in prepared_objects
            ]

            stix_objects_bundle = self.helper.stix2_create_bundle(
                get_stix_representation_objects
            )
            bundle_sent = self.helper.send_stix2_bundle(
                stix_objects_bundle,
                work_id=work_id,
                cleanup_inconsistent_bundle=True,
            )

            length_bundle_sent = len(bundle_sent)
            self.helper.connector_logger.info(
                "[CONNECTOR] Sending STIX objects to OpenCTI...",
                {"length_bundle_sent": length_bundle_sent},
            )
            return length_bundle_sent

    def _complete_work(self, work_id: str) -> None:
        """Marks the work process as complete.
        This method logs the completion of the work for a specific work ID.
        Sends a request to the API with the to_processed method to complete the work.

        Args:
            work_id (str): The unique identifier of the work collection to mark as complete.

        Returns:
            None
        """
        self.helper.connector_logger.info(
            "[CONNECTOR] Complete work...",
            {
                "work_id": work_id,
            },
        )
        message = "ServiceNow - Finished work"
        self.helper.api.work.to_processed(work_id, message)

    def _classify_results(self, results: list, task_names: list | str = None) -> list:

        classified_results = []

        new_results = (
            results[0].get("result", [])
            if results
            and isinstance(results, list)
            and isinstance(results[0], dict)
            and "result" in results[0]
            else results
        )

        for index, result in enumerate(new_results):
            task_name = (
                task_names[index] if isinstance(task_names, list) else task_names
            )

            if isinstance(result, RetryError):
                inner_exception = result.last_attempt.exception()
                inner_exception_name = type(inner_exception).__name__

                if isinstance(inner_exception, ClientResponseError):
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] A HTTP error occurred during data recovery, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                            "status": inner_exception.status,
                            "url": inner_exception.request_info.url,
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
                elif isinstance(inner_exception, ClientConnectionError):
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] A connection error occurred during data recovery, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
                else:
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] An unexpected error occurred during the recovery of all data, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
            else:
                classified_results.append(result)

        return classified_results

    async def _collect_intelligence(self) -> list | None:
        """Collect intelligence from the source and convert into STIX object
        Returns:
            List of STIX objects or None
        """
        try:

            self.helper.connector_logger.info(
                "[CONNECTOR] Start the collection of information from ServiceNow.",
            )

            prerequisites_futures = {
                "get_state_to_exclude": self.client.get_state_to_exclude(),
                "get_severity_to_exclude": self.client.get_severity_to_exclude(),
                "get_priority_to_exclude": self.client.get_priority_to_exclude(),
            }
            collected_prerequisites_futures = await asyncio.gather(
                *prerequisites_futures.values(), return_exceptions=True
            )

            prerequisites_futures_names = list(prerequisites_futures.keys())
            result_prerequisites_futures = self._classify_results(
                collected_prerequisites_futures, prerequisites_futures_names
            )

            get_state_to_exclude, get_severity_to_exclude, get_priority_to_exclude = (
                result_prerequisites_futures
                if result_prerequisites_futures
                else (None, None, None)
            )

            main_futures = {
                "get_security_incidents": self.client.get_security_incidents(
                    get_state_to_exclude,
                    get_severity_to_exclude,
                    get_priority_to_exclude,
                    self.last_run_start_datetime,
                )
            }

            collected_security_incidents = await asyncio.gather(
                *main_futures.values(), return_exceptions=True
            )
            result_main_futures = self._classify_results(
                collected_security_incidents, "get_security_incidents"
            )

            if not result_main_futures:
                self.helper.connector_logger.info(
                    "[CONNECTOR] No security incidents found.",
                )
                return

            security_incident_tasks = [
                (
                    security_incident,
                    asyncio.create_task(
                        self.client.get_tasks(security_incident.get("sys_id"))
                    ),
                    # Todo get_observables
                )
                for security_incident in result_main_futures
            ]

            security_incidents_results = []

            for si_incident, si_task in security_incident_tasks:
                collected_tasks = await asyncio.gather(si_task, return_exceptions=True)
                security_incident_id = si_incident.get("sys_id")

                result_tasks_related_to_sir = self._classify_results(
                    collected_tasks, security_incident_id
                )

                security_incidents_combined = {"get_security_incident": si_incident}
                if result_tasks_related_to_sir:
                    security_incidents_combined["get_tasks"] = (
                        result_tasks_related_to_sir
                    )

                security_incidents_results.append(security_incidents_combined)

            self.helper.connector_logger.info(
                "[CONNECTOR] Complete the collection of information from ServiceNow."
            )
            return security_incidents_results

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred while collecting intelligence.",
                {"error": err},
            )
            raise

    def _valid_intelligence(self, collected_intelligence: list):
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts validating intelligence from ServiceNow..."
            )

            validated_intelligence = []

            intelligence_models = {
                "get_security_incident": SecurityIncidentResponse,
                "get_tasks": TaskResponse,
            }

            for intelligence in collected_intelligence:
                validated_per_collection_name = {}
                for intelligence_name, intelligence_value in intelligence.items():

                    if intelligence_name not in intelligence_models:
                        continue

                    intelligence_model = intelligence_models.get(intelligence_name)

                    if isinstance(intelligence_value, dict):
                        try:
                            validated_per_collection_name[intelligence_name] = (
                                intelligence_model.model_validate(intelligence_value)
                            )
                        except ValidationError as err:
                            self.helper.connector_logger.warning(
                                "[VALIDATION] A validation error has occurred on an incident security. "
                                "This entity will be ignored along with all associated entities.",
                                {
                                    "collection_name": intelligence_name,
                                    "entity_number": intelligence_value.get("number"),
                                    "entity_sys_id": intelligence_value.get("sys_id"),
                                    "error": err,
                                },
                            )
                            break
                    if isinstance(intelligence_value, list):
                        validated_list = []
                        for item in intelligence_value:
                            try:
                                validated = intelligence_model.model_validate(item)
                                validated_list.append(validated)
                            except ValidationError as err:
                                self.helper.connector_logger.warning(
                                    "[VALIDATION] A validation error has occurred on a entity linked to an security incident. "
                                    "This entity will be ignored.",
                                    {
                                        "collection_name": intelligence_name,
                                        "entity_number": item.get("number"),
                                        "entity_sys_id": item.get("sys_id"),
                                        "error": err,
                                    },
                                )
                                continue
                        validated_per_collection_name[intelligence_name] = (
                            validated_list
                        )
                if validated_per_collection_name:
                    validated_intelligence.append(validated_per_collection_name)
            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the validation of information from ServiceNow."
            )
            return validated_intelligence

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence validation.",
                {"error": err},
            )
            raise

    def _transform_intelligence(self, validated_intelligence):
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts transforming intelligence to STIX 2.1 format..."
            )
            stix_objects = []

            for item in validated_intelligence:
                security_incident_object = item.get("get_security_incident")
                case_incident_object_refs = []
                all_external_references = []

                mitre_mapping = {
                    # MITRE Technique / MITRE Tactic
                    # Example: ["T1110 (Brute Force)"] -> [mitre_id (mitre_name)]
                    "mitre_technique": lambda args: self.converter_to_stix.make_attack_pattern(
                        *args
                    ),
                    "mitre_tactic": lambda args: self.converter_to_stix.make_attack_pattern(
                        *args
                    ),
                    # MITRE Group / MITRE Malware / MITRE Tool
                    # Example: ["G0102 (Wizard Spider)"] -> [mitre_name (mitre_alias)]
                    "mitre_group": lambda args: self.converter_to_stix.make_intrusion_set(
                        *args
                    ),
                    "mitre_malware": lambda args: self.converter_to_stix.make_malware(
                        *args
                    ),
                    "mitre_tool": lambda args: self.converter_to_stix.make_tool(*args),
                }

                # Make External Reference for custom case incident response and all entities Mitre
                external_reference_sir = self.converter_to_stix.make_external_reference(
                    security_incident_object.number,
                    "sn_si_incident",
                    security_incident_object.sys_id,
                )
                all_external_references.append(external_reference_sir)

                for key, make_mitre_object in mitre_mapping.items():
                    has_values = getattr(security_incident_object, key, None)

                    if isinstance(has_values, list) and has_values:
                        for mitre in has_values:
                            mitre_part_1, mitre_part_2 = mitre.split(" ", 1)
                            # Removal of parentheses for the second part
                            clean_mitre_part_2 = mitre_part_2.strip("()")

                            mitre_object = make_mitre_object(
                                (
                                    mitre_part_1,
                                    clean_mitre_part_2,
                                    [external_reference_sir],
                                )
                            )
                            stix_objects.append(mitre_object)
                            case_incident_object_refs.append(mitre_object)

                # Todo Make Observables object -> Observable

                # Transform comment in markdown for security_incident
                new_description = self.utils.transform_description_to_markdown(
                    self.config.servicenow.comment_to_exclude,
                    security_incident_object.description,
                    security_incident_object.comments_and_work_notes,
                )
                security_incident_object.comments_and_work_notes = new_description

                # Normalises severity for OpenCTI by finding the first match among known levels
                severity_matched = next(
                    (
                        item
                        for item in ["low", "medium", "high", "critical"]
                        if item in security_incident_object.severity.lower()
                    ),
                    None,
                )
                security_incident_object.severity = severity_matched
                if severity_matched is None:
                    self.helper.connector_logger.warning(
                        "[WARNING] Severity has not been correctly identified and will be ignored.",
                        {
                            "security_incident_id": security_incident_object.sys_id,
                            "severity_in_security_incident": security_incident_object.severity,
                        },
                    )

                # Make Security Incident Response object -> CustomObjectCaseIncident
                custom_case_incident = self.converter_to_stix.make_custom_case_incident(
                    security_incident_object,
                    case_incident_object_refs,
                    [external_reference_sir],
                )

                # Make Tasks object -> CustomObjectTask
                all_tasks_object = item.get("get_tasks")
                if all_tasks_object:
                    for task in all_tasks_object:

                        # Make External Reference Task for custom case incident parent
                        external_reference_task = (
                            self.converter_to_stix.make_external_reference(
                                task.number,
                                "task",
                                task.sys_id,
                            )
                        )
                        all_external_references.append(external_reference_task)

                        # Transform comment in markdown
                        new_description_task = (
                            self.utils.transform_description_to_markdown(
                                self.config.servicenow.comment_to_exclude,
                                task.description,
                                task.comments_and_work_notes,
                            )
                        )
                        task.comments_and_work_notes = new_description_task
                        all_labels = [*task.sys_tags, *task.security_tags]

                        custom_task = self.converter_to_stix.make_custom_task(
                            task, custom_case_incident, all_labels
                        )
                        stix_objects.append(custom_task)

                # Add all_external_references to the external ref of the parent security incident
                final_custom_case_incident = (
                    self.converter_to_stix.make_custom_case_incident(
                        security_incident_object,
                        case_incident_object_refs,
                        all_external_references,
                    )
                )
                stix_objects.append(final_custom_case_incident)

            if stix_objects:
                # Make Author object
                author = self.converter_to_stix.make_author()
                stix_objects.append(author)

                # Make Markings object
                markings = self.converter_to_stix.make_tlp_marking(
                    level=self.config.servicenow.tlp_level
                )
                stix_objects.append(markings)

            len_stix_objects = len(stix_objects)
            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the transforming intelligence to STIX 2.1 format.",
                {"len_stix_objects": len_stix_objects},
            )
            return stix_objects

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence transformation.",
                {"error": err},
            )
            raise

    def _prepare_intelligence(self, collected_intelligence: list):
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts preparing data for ServiceNow..."
            )

            validated_intelligence = self._valid_intelligence(collected_intelligence)
            transformed_intelligence = self._transform_intelligence(
                validated_intelligence
            )

            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the preparing of intelligence from ServiceNow"
            )
            return transformed_intelligence

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence preparation.",
                {"error": err},
            )
            raise

    def process_message(self) -> None:
        """The main process used by the connector to collect intelligence.
        This method launches the connector, processes the current state,
        collects intelligence data and updates the state of the last successful execution.

        Returns:
            None
        """
        try:
            # Initialization to get the current start utc iso format.
            current_start_utc_isoformat = self.utils.get_now(DateTimeFormat.ISO)

            # Get the current state
            current_state = self.helper.get_state()
            self.last_run_start_datetime = (
                current_state.get("last_run_start_datetime") if current_state else None
            )
            self.last_run_end_datetime_with_ingested_data = (
                current_state.get("last_run_end_datetime_with_ingested_data")
                if current_state
                else None
            )

            self.helper.connector_logger.info(
                "[CONNECTOR] Starting connector...",
                {
                    "connector_name": self.config.connector.name,
                    "connector_start_time": current_start_utc_isoformat,
                    "last_run_start_datetime": (
                        self.last_run_start_datetime
                        if self.last_run_start_datetime
                        else "Connector has never run"
                    ),
                    "last_run_end_datetime_with_ingested_data": (
                        self.last_run_end_datetime_with_ingested_data
                        if self.last_run_end_datetime_with_ingested_data
                        else "Connector has never ingested data"
                    ),
                },
            )

            work_id = self._initiate_work()
            collected_intelligence = asyncio.run(self._collect_intelligence())

            if collected_intelligence:
                # Start preparing data for OpenCTI - Converted to stix format
                prepared_intelligence = self._prepare_intelligence(
                    collected_intelligence
                )
                self._send_intelligence(work_id, prepared_intelligence)
                self.last_run_end_datetime_with_ingested_data = self.utils.get_now(
                    DateTimeFormat.ISO
                )

            # Store the current start utc isoformat as a last run of the connector.
            self.helper.connector_logger.info(
                "[CONNECTOR] Getting current state and update it with last run of the connector.",
                {
                    "current_state": self.last_run_start_datetime,
                    "new_last_run_start_datetime": current_start_utc_isoformat,
                },
            )
            if self.last_run_start_datetime:
                current_state["last_run_start_datetime"] = current_start_utc_isoformat
            else:
                current_state = {"last_run_start_datetime": current_start_utc_isoformat}

            if self.last_run_end_datetime_with_ingested_data:
                current_state["last_run_end_datetime_with_ingested_data"] = (
                    self.last_run_end_datetime_with_ingested_data
                )

            self.helper.set_state(current_state)
            self._complete_work(work_id)

        except (KeyboardInterrupt, SystemExit):
            self.helper.connector_logger.info(
                "[CONNECTOR] Connector stopped...",
                {"connector_name": self.config.connector.name},
            )
            sys.exit(0)
        except Exception as err:
            self.helper.connector_logger.error(str(err))

    def run(self) -> None:
        """Run the main process encapsulated in a scheduler
        It allows you to schedule the process to run at a certain intervals
        This specific scheduler from the pycti connector helper will also check the queue size of a connector
        If `CONNECTOR_QUEUE_THRESHOLD` is set, if the connector's queue size exceeds the queue threshold,
        the connector's main process will not run until the queue is ingested and reduced sufficiently,
        allowing it to restart during the next scheduler check. (default is 500MB)
        It requires the `duration_period` connector variable in ISO-8601 standard format
        Example: `CONNECTOR_DURATION_PERIOD=PT5M` => Will run the process every 5 minutes
        If `duration_period` is set to 0 then it will function as a run and terminate
        Returns:
            None
        """
        self.helper.schedule_process(
            message_callback=self.process_message,
            duration_period=self.config.connector.duration_period.total_seconds(),
        )
