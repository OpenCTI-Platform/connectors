import asyncio
import sys

from aiohttp import ClientConnectionError, ClientResponseError
from pycti import OpenCTIConnectorHelper
from pydantic import ValidationError
from src.connector.models import (
    ConfigLoader,
    ObservableResponse,
    SecurityIncidentResponse,
    TaskResponse,
)
from src.connector.services import (
    ConverterToStix,
    DateTimeFormat,
    ServiceNowClient,
    Utils,
)
from tenacity import RetryError


class ConnectorServicenow:
    """
    Specifications of the external import connector

    This class encapsulates the main actions, expected to be run by any external import connector.
    Note that the attributes defined below will be complemented per each connector type.
    This type of connector aim to fetch external data to create STIX bundle and send it in a RabbitMQ queue.
    The STIX bundle in the queue will be processed by the workers.
    This type of connector uses the basic methods of the helper.

    ---

    Attributes
        - `config (ConfigConnector())`:
            Initialize the connector with necessary configuration environment variables

        - `helper (OpenCTIConnectorHelper(config))`:
            This is the helper to use.
            ALL connectors have to instantiate the connector helper with configurations.
            Doing this will do a lot of operations behind the scene.

        - `converter_to_stix (ConnectorConverter(helper))`:
            Provide methods for converting various types of input data into STIX 2.1 objects.

    ---

    Best practices
        - `self.helper.api.work.initiate_work(...)` is used to initiate a new work
        - `self.helper.schedule_iso()` is used to encapsulate the main process in a scheduler
        - `self.helper.connector_logger.[info/debug/warning/error]` is used when logging a message
        - `self.helper.stix2_create_bundle(stix_objects)` is used when creating a bundle
        - `self.helper.send_stix2_bundle(stix_objects_bundle)` is used to send the bundle to RabbitMQ
        - `self.helper.set_state()` is used to set state

    """

    def __init__(self, config: ConfigLoader, helper: OpenCTIConnectorHelper):
        """Initialize the Connector with necessary configurations"""

        # Load configuration file and connection helper
        self.config = config
        self.helper = helper
        self.client = ServiceNowClient(self.helper, self.config)
        self.converter_to_stix = ConverterToStix(self.helper, self.config)
        self.utils = Utils()
        self.last_run_start_datetime = None
        self.last_run_end_datetime_with_ingested_data = None
        self.work_id = None

    def _initiate_work(self):
        """Starts a work process.
        From now on, a work will only be created once it has been confirmed that the connector has new data to ingest.
        Sends a request to the API with the initiate_work method to initialize the work.

        Returns:
            str: The work ID generated by the API when initiating the work.
        """
        now_utc_isoformat = self.utils.get_now(DateTimeFormat.ISO)
        self.helper.connector_logger.info(
            "[CONNECTOR] Starting work...",
            {
                "now_utc_isoformat": now_utc_isoformat,
            },
        )

        # Friendly name will be displayed on OpenCTI platform
        friendly_name = f"ServiceNow - run @ {now_utc_isoformat}"
        self.work_id = self.helper.api.work.initiate_work(
            self.config.connector.id, friendly_name
        )

    def _send_intelligence(self, prepared_objects: list) -> int:
        """This method prepares and sends unique STIX objects to OpenCTI.
        This method takes a list of objects prepared by the models, extracts their STIX representations, creates a
        serialized STIX bundle, and It then sends this bundle to OpenCTI.
        If prepared objects exist, the method ensures that only unique objects with an 'id' attribute are included.
        After sending the STIX objects, it keeps inform of the number of bundles sent.

        Args:
            prepared_objects (list): A list of objects containing STIX representations to be sent to OpenCTI.

        Returns:
            int : Return the length bundle sent
        """
        if prepared_objects is not None and len(prepared_objects) != 0:
            get_stix_representation_objects = [
                obj.stix2_representation for obj in prepared_objects
            ]

            stix_objects_bundle = self.helper.stix2_create_bundle(
                get_stix_representation_objects
            )
            bundle_sent = self.helper.send_stix2_bundle(
                stix_objects_bundle,
                work_id=self.work_id,
                cleanup_inconsistent_bundle=True,
            )

            length_bundle_sent = len(bundle_sent)
            self.helper.connector_logger.info(
                "[CONNECTOR] Sending STIX objects to OpenCTI...",
                {"length_bundle_sent": length_bundle_sent},
            )
            return length_bundle_sent

    def _complete_work(self) -> None:
        """Marks the work process as complete.
        This method logs the completion of the work for a specific work ID.
        Sends a request to the API with the to_processed method to complete the work.

        Returns:
            None
        """
        self.helper.connector_logger.info(
            "[CONNECTOR] Complete work...",
            {
                "work_id": self.work_id,
            },
        )
        message = "ServiceNow - Finished work"
        self.helper.api.work.to_processed(
            work_id=self.work_id,
            message=message,
        )
        self.work_id = None

    def _handling_errors_tenacity(
        self, results: list, task_names: list | str = None
    ) -> list:

        classified_results = []

        new_results = (
            results[0].get("result", [])
            if results
            and isinstance(results, list)
            and isinstance(results[0], dict)
            and "result" in results[0]
            else results
        )

        for index, result in enumerate(new_results):
            task_name = (
                task_names[index] if isinstance(task_names, list) else task_names
            )

            if isinstance(result, RetryError):
                inner_exception = result.last_attempt.exception()
                inner_exception_name = type(inner_exception).__name__

                if isinstance(inner_exception, ClientResponseError):
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] A HTTP error occurred during data recovery, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                            "status": inner_exception.status,
                            "url": inner_exception.request_info.url,
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
                elif isinstance(inner_exception, ClientConnectionError):
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] A connection error occurred during data recovery, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
                else:
                    self.helper.connector_logger.warning(
                        "[CONNECTOR-API] An unexpected error occurred during the recovery of all data, "
                        "the entity where filtering will be ignored",
                        {
                            "task_name": task_name,
                            "error_name": inner_exception_name,
                            "error": str(inner_exception),
                        },
                    )
                    if isinstance(task_names, list):
                        classified_results.append(None)
            else:
                classified_results.append(result)

        return classified_results

    async def _handling_collection_sir(self, result_security_incidents) -> list:

        # For each security incident response, we need to make two separate api calls, one to retrieve the tasks
        # and the other to retrieve the observables.
        security_incident_futures = [
            (
                security_incident,
                asyncio.create_task(
                    self.client.get_tasks(security_incident.get("sys_id"))
                ),
                asyncio.create_task(
                    self.client.get_observables(security_incident.get("sys_id"))
                ),
            )
            for security_incident in result_security_incidents
        ]

        security_incidents_results = []

        for sir_incident, sir_task, sir_observable in security_incident_futures:
            security_incidents_combined = {"get_security_incident": sir_incident}
            security_incident_id = sir_incident.get("sys_id")
            security_incident_number = sir_incident.get("number")

            sir_collected_tasks, sir_collected_observables = await asyncio.gather(
                sir_task, sir_observable, return_exceptions=True
            )

            # Observables related to the Security Incident Response (SIR)
            result_observables_related_to_sir = self._handling_errors_tenacity(
                [sir_collected_observables], security_incident_id
            )
            if result_observables_related_to_sir:
                security_incidents_combined.get("get_security_incident")[
                    "get_observables"
                ] = result_observables_related_to_sir

            # Tasks related to the Security Incident Response (SIR)
            result_tasks_related_to_sir = self._handling_errors_tenacity(
                [sir_collected_tasks], security_incident_id
            )

            self.helper.connector_logger.info(
                "[SIR-COLLECTION] All SIR information is collected...",
                {
                    "sir_sys_id": security_incident_id,
                    "sir_number": security_incident_number,
                    "total_observables_related_to_sir": len(
                        result_observables_related_to_sir
                    ),
                    "total_tasks_related_to_sir": len(result_tasks_related_to_sir),
                },
            )

            # For each task, we need to use an api call to retrieve all its linked observables.
            if result_tasks_related_to_sir:
                tasks_futures = [
                    (
                        task,
                        asyncio.create_task(
                            self.client.get_observables(task.get("sys_id"))
                        ),
                    )
                    for task in result_tasks_related_to_sir
                ]

                tasks_results = []
                for sit_task, sit_observable in tasks_futures:
                    task_id = sit_task.get("sys_id")
                    task_number = sit_task.get("number")

                    sit_collected_observables = await asyncio.gather(
                        sit_observable, return_exceptions=True
                    )

                    # Observables related to the Task (SIT)
                    result_observables_related_to_task = self._handling_errors_tenacity(
                        sit_collected_observables, task_id
                    )

                    self.helper.connector_logger.info(
                        "[SIT-COLLECTION] All SIT information is collected...",
                        {
                            "sit_sys_id": task_id,
                            "sit_number": task_number,
                            "total_observables_related_to_sit": len(
                                result_observables_related_to_task
                            ),
                        },
                    )
                    if result_observables_related_to_task:
                        sit_task["get_observables"] = result_observables_related_to_task

                    tasks_results.append(sit_task)

                security_incidents_combined.get("get_security_incident")[
                    "get_tasks"
                ] = tasks_results

            security_incidents_results.append(security_incidents_combined)
        return security_incidents_results

    async def _collect_intelligence(self) -> list | None:
        """This method recovers all raw data without any modification or validation, although filtering can be
        performed and dictionary preparation is carried out to facilitate validation of the information received.

        Returns:
            List | None
        """
        try:

            self.helper.connector_logger.info(
                "[CONNECTOR] Start the collection of information from ServiceNow.",
            )

            # Prerequisites for filtering security incident responses
            prerequisites_futures = {
                "get_state_to_exclude": self.client.get_state_to_exclude(),
                "get_severity_to_exclude": self.client.get_severity_to_exclude(),
                "get_priority_to_exclude": self.client.get_priority_to_exclude(),
            }
            collected_prerequisites_futures = await asyncio.gather(
                *prerequisites_futures.values(), return_exceptions=True
            )

            prerequisites_futures_names = list(prerequisites_futures.keys())
            result_prerequisites_futures = self._handling_errors_tenacity(
                collected_prerequisites_futures, prerequisites_futures_names
            )

            get_state_to_exclude, get_severity_to_exclude, get_priority_to_exclude = (
                result_prerequisites_futures
                if result_prerequisites_futures
                else (None, None, None)
            )

            main_futures = {
                "get_security_incidents": self.client.get_security_incidents(
                    get_state_to_exclude,
                    get_severity_to_exclude,
                    get_priority_to_exclude,
                    self.last_run_start_datetime,
                ),
            }

            collected_security_incidents = await asyncio.gather(
                *main_futures.values(), return_exceptions=True
            )
            result_security_incidents = self._handling_errors_tenacity(
                collected_security_incidents, "get_security_incidents"
            )

            if not result_security_incidents:
                self.helper.connector_logger.info(
                    "[CONNECTOR] No security incidents response found.",
                )
                return

            # Enrich security incidents response by retrieving their related tasks and observables.
            enriched_security_incidents = await self._handling_collection_sir(
                result_security_incidents
            )

            self.helper.connector_logger.info(
                "[CONNECTOR] The collection of information from ServiceNow is completed.",
                {"total_sir_processed": len(enriched_security_incidents)},
            )

            return enriched_security_incidents

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred while collecting intelligence.",
                {"error": err},
            )
            raise

    def _model_validation_entities(
        self,
        parent_data: dict,
        parent_name: str,
        models_name: type[TaskResponse | ObservableResponse | SecurityIncidentResponse],
        child_method_name: str | None = None,
    ) -> dict | None:

        if not isinstance(parent_data, dict):
            return None

        if child_method_name:
            data_raw_children = parent_data.get(child_method_name) or []
            validated_list_child = []
            for data_raw_child in data_raw_children:
                try:
                    validated_child = models_name.model_validate(data_raw_child)
                    validated_child_sys_id = getattr(validated_child, "sys_id", None)
                    self.helper.connector_logger.debug(
                        "[MODEL-VALIDATE] Data for the child entity have been successfully validated.",
                        {
                            "entity_parent_name": parent_name,
                            "entity_child_name": child_method_name,
                            "validated_child_sys_id": validated_child_sys_id,
                        },
                    )
                    validated_list_child.append(validated_child)
                except ValidationError as err:
                    message = (
                        f"[VALIDATION-WARNING] A validation error has occurred on a entity linked to an "
                        f"'{parent_name}'. This entity will be ignored."
                    )
                    self.helper.connector_logger.warning(
                        message,
                        {
                            "collection_parent_name": parent_name,
                            "parent_entity_number": parent_data.get("number"),
                            "parent_entity_sys_id": parent_data.get("sys_id"),
                            "collection_child_name": child_method_name,
                            "error": err,
                        },
                    )
                    continue
            return (
                {child_method_name: validated_list_child}
                if validated_list_child
                else None
            )
        else:
            try:
                validated_parent = models_name.model_validate(parent_data)
                validated_parent_sys_id = getattr(validated_parent, "sys_id", None)

                self.helper.connector_logger.debug(
                    "[MODEL-VALIDATE] No entity children linked to the entity parent need to be validated.",
                    {
                        "entity_parent_name": parent_name,
                        "entity_parent_sys_id": validated_parent_sys_id,
                    },
                )

                return {parent_name: validated_parent} if validated_parent else None
            except ValidationError as err:
                message = f"[VALIDATION-WARNING] A validation error has occurred on an '{parent_name}'. "
                "This entity will be ignored."
                self.helper.connector_logger.warning(
                    message,
                    {
                        "collection_parent_name": parent_name,
                        "parent_entity_number": parent_data.get("number"),
                        "parent_entity_sys_id": parent_data.get("sys_id"),
                        "collection_child_name": child_method_name,
                        "error": err,
                    },
                )
                return None

    def _validate_children(
        self,
        parent_name: str,
        parent_data: dict,
        model_map: dict,
        hierarchy_map: dict,
    ) -> None:
        for child_name in hierarchy_map.get(parent_name, []):
            child_entities = parent_data.get(child_name)
            if not child_entities:
                continue

            if child_name in hierarchy_map:
                for child_entity in child_entities:
                    for sub_child in hierarchy_map[child_name]:
                        validated = self._model_validation_entities(
                            child_entity, child_name, model_map[sub_child], sub_child
                        )
                        child_entity[sub_child] = (
                            validated[sub_child] if validated else None
                        )

            validated = self._model_validation_entities(
                parent_data, parent_name, model_map[child_name], child_name
            )
            # Here we replace in the parent the child's raw dict with the child's validated model.
            parent_data[child_name] = validated[child_name] if validated else None

    def _valid_intelligence(self, collected_intelligence: list[dict]) -> list[dict]:
        """This method enables data collected previously to be validated via pydantic. A parent/child hierarchy system
        has been set up with recurcive validation: for example, a security incident may have tasks and observables, but
        the tasks may also have observables (see diagram).

        get_security_incident
        ├── get_tasks
        │   └── get_observables
        └── get_observables

        Args:
            collected_intelligence (list[dict]) Raw data recovery from ServiceNow.
        Returns:
            list[dict]
        """
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts validating intelligence from ServiceNow..."
            )

            # All models
            intelligence_models = {
                "get_security_incident": SecurityIncidentResponse,
                "get_tasks": TaskResponse,
                "get_observables": ObservableResponse,
            }

            # Parent (dict) / Children (list)
            intelligence_hierarchy = {
                "get_security_incident": ["get_tasks", "get_observables"],
                "get_tasks": ["get_observables"],
            }

            for intelligence in collected_intelligence or []:
                for parent_name, parent_value in intelligence.items():
                    if parent_name not in intelligence_hierarchy:
                        continue

                    self._validate_children(
                        parent_name,
                        parent_value,
                        intelligence_models,
                        intelligence_hierarchy,
                    )

                    validated_parent = self._model_validation_entities(
                        parent_value, parent_name, intelligence_models[parent_name]
                    )

                    if validated_parent is None:
                        self.helper.connector_logger.warning(
                            "[WARNING] Validation failed. The entity will be ignored.",
                            {
                                "parent_name": parent_name,
                                "parent_value": parent_value,
                            },
                        )
                        continue

                    validated_parent_name = validated_parent.get(parent_name)
                    self.helper.connector_logger.debug(
                        "[MODEL-VALIDATE] Data for the parent entity have been successfully validated.",
                        {
                            "entity_parent_name": parent_name,
                            "entity_parent_sys_id": validated_parent_name.sys_id,
                        },
                    )

                    # Here we replace the parent's raw dictionary with its validated model with all its linked children.
                    intelligence[parent_name] = (
                        validated_parent[parent_name] if validated_parent else None
                    )

            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the validation of information from ServiceNow."
            )
            return collected_intelligence

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence validation.",
                {"error": err},
            )
            raise

    def _handling_observables(
        self, observables: list[ObservableResponse], entity_number: str = None
    ) -> list:
        """This method manages all observables to be created in stix format, for security incidents and tasks.

        Args:
            observables (list[ObservableResponse]):
            entity_number (str) : Entity identifier by "number" from ServiceNow (SIR - SIT)

        Returns:
            list of observables
        """

        observables_make_mapping = {
            "Domain-Name": lambda *arg: self.converter_to_stix.make_domain_name(*arg),
            "IPv4-Addr": lambda *arg: self.converter_to_stix.make_ipv4(*arg),
            "IPv6-Addr": lambda *arg: self.converter_to_stix.make_ipv6(*arg),
            "Url": lambda *arg: self.converter_to_stix.make_url(*arg),
            "Email-Addr": lambda *arg: self.converter_to_stix.make_email_address(*arg),
            "Email-Message--Body": lambda *arg: self.converter_to_stix.make_email_message(
                *arg
            ),
            "Email-Message--Message_id": lambda *arg: self.converter_to_stix.make_email_message(
                *arg
            ),
            "Email-Message--Subject": lambda *arg: self.converter_to_stix.make_email_message(
                *arg
            ),
            "MD5": lambda *arg: self.converter_to_stix.make_file(*arg),
            "SHA-1": lambda *arg: self.converter_to_stix.make_file(*arg),
            "SHA-256": lambda *arg: self.converter_to_stix.make_file(*arg),
            "SHA-512": lambda *arg: self.converter_to_stix.make_file(*arg),
            "StixFile": lambda *arg: self.converter_to_stix.make_file(*arg),
            "Directory": lambda *arg: self.converter_to_stix.make_directory(*arg),
            "Hostname": lambda *arg: self.converter_to_stix.make_hostname(*arg),
            "Mutex": lambda *arg: self.converter_to_stix.make_mutex(*arg),
            "Autonomous-System": lambda *arg: self.converter_to_stix.make_asn(*arg),
            "Phone-Number": lambda *arg: self.converter_to_stix.make_phone_number(*arg),
            "Windows-Registry-Key": lambda *arg: self.converter_to_stix.make_windows_registry_key(
                *arg
            ),
            "User-Account": lambda *arg: self.converter_to_stix.make_user_account(*arg),
            "CVE-Number": lambda *arg: self.converter_to_stix.make_vulnerability(*arg),
            "Organization-Name": lambda *arg: self.converter_to_stix.make_organization_name(
                *arg
            ),
        }

        all_observables = []
        for observable in observables:
            observable_type = getattr(observable, "type", None)
            observable_sys_id = getattr(observable, "sys_id", None)
            observable_value = getattr(observable, "value", None)

            if observable and observable_type in observables_make_mapping:

                # Prepare all the labels for the observable.
                prepared_labels_observable = self._handling_labels(
                    entity=observable,
                    observable=True,
                )

                # Make External Reference
                observable_external_reference = (
                    self.converter_to_stix.make_external_reference(
                        entity_number=observable_sys_id,
                        table_name="sn_ti_observable",
                        external_id=observable_sys_id,
                    )
                )
                # Make Observable object
                make_observable = observables_make_mapping.get(observable_type)
                observable_object = (
                    make_observable(
                        observable,
                        prepared_labels_observable,
                        observable_external_reference,
                    )
                    if make_observable
                    else None
                )
                all_observables.append(observable_object)

                self.helper.connector_logger.info(
                    "[CONNECTOR] Creating a Observable object in stix format.",
                    {
                        "entity_number": entity_number,
                        "observable_type": observable_type,
                        "observables_sys_id": observable_sys_id,
                        "observable_value": observable_value,
                    },
                )

        return all_observables

    @staticmethod
    def _handling_labels(
        entity: TaskResponse | ObservableResponse | SecurityIncidentResponse,
        observable: bool = None,
        task: bool = None,
        security_incident: bool = None,
    ) -> list[str]:
        """
        This method manages the labels for the different entities handled by the connector. A special feature is that
        it deliberately filters out “unknown” values.

        Args:
            entity (TaskResponse | ObservableResponse | SecurityIncidentResponse): The data object from which labels
            are to be extracted.
            observable (bool | None): Set to True if the entity is an ObservableResponse. Defaults to None.
            task (bool | None): Set to True if the entity is a TaskResponse. Defaults to None.
            security_incident (bool | None): Set to True if the entity is a SecurityIncidentResponse. Defaults to None.

        Returns:
            list[str]: A list of valid labels extracted from the selected fields per entities. Labels are filtered to
                       exclude null/empty values and the string "unknown".
        """
        labels_mapping = {}
        if observable:
            labels_mapping = {
                "sys_tags",
                "security_tags",
                "finding",
            }

        if task:
            labels_mapping = {
                "sys_tags",
                "security_tags",
            }

        if security_incident:
            labels_mapping = {
                "subcategory",
                "sys_tags",
                "security_tags",
                "contact_type",
                "alert_sensor",
            }

        return [
            label
            for key in labels_mapping
            for label in (getattr(entity, key, []) or [])
            if label and label.lower() != "unknown"
        ]

    def _transform_intelligence(self, validated_intelligence: list[dict]) -> list:
        """This method is designed to transform data validation into stix format, and deals mainly with the creation of
        case incident responses, tasks and observables.

        Args:
            validated_intelligence (list[dict]): A list[dict] containing the validated data, filtered using pydantic.

        Returns:
            List of entities with their stix representation.
        """
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts transforming intelligence to STIX 2.1 format..."
            )
            stix_objects = []

            for item in validated_intelligence:
                security_incident_object = item.get("get_security_incident")
                sir_number = getattr(security_incident_object, "number", None)
                sir_sys_id = getattr(security_incident_object, "sys_id", None)
                case_incident_objects = []
                all_external_references = []

                mitre_mapping = {
                    # MITRE Technique / MITRE Tactic
                    # Example: ["T1110 (Brute Force)"] -> [mitre_id (mitre_name)]
                    "mitre_technique": lambda args: self.converter_to_stix.make_attack_pattern(
                        *args
                    ),
                    "mitre_tactic": lambda args: self.converter_to_stix.make_attack_pattern(
                        *args
                    ),
                    # MITRE Group / MITRE Malware / MITRE Tool
                    # Example: ["G0102 (Wizard Spider)"] -> [mitre_name (mitre_alias)]
                    "mitre_group": lambda args: self.converter_to_stix.make_intrusion_set(
                        *args
                    ),
                    "mitre_malware": lambda args: self.converter_to_stix.make_malware(
                        *args
                    ),
                    "mitre_tool": lambda args: self.converter_to_stix.make_tool(*args),
                }

                # Make External Reference for custom case incident response and all entities Mitre
                external_reference_sir = self.converter_to_stix.make_external_reference(
                    entity_number=sir_number,
                    table_name="sn_si_incident",
                    external_id=sir_sys_id,
                )
                all_external_references.append(external_reference_sir)

                for key, make_mitre_object in mitre_mapping.items():
                    mitre_values = getattr(security_incident_object, key, None)

                    if isinstance(mitre_values, list) and mitre_values:
                        for mitre in mitre_values:
                            mitre_part_1, mitre_part_2 = mitre.split(" ", 1)
                            # Removal of parentheses for the second part
                            clean_mitre_part_2 = mitre_part_2.strip("()")

                            mitre_object = make_mitre_object(
                                (
                                    mitre_part_1,
                                    clean_mitre_part_2,
                                    [external_reference_sir],
                                )
                            )
                            stix_objects.append(mitre_object)
                            case_incident_objects.append(mitre_object)

                            self.helper.connector_logger.info(
                                "[CONNECTOR] Creating a MITRE object in stix format.",
                                {
                                    "sir_number": sir_number,
                                    "sir_sys_id": sir_sys_id,
                                    "mitre_type_servicenow": key,
                                    "mitre_type_opencti": getattr(
                                        mitre_object.stix2_representation, "type", None
                                    ),
                                    "mitre_name": getattr(mitre_object, "name", None),
                                    "mitre_external_id": getattr(
                                        mitre_object, "external_id", None
                                    ),
                                    "mitre_aliases": getattr(
                                        mitre_object, "aliases", None
                                    ),
                                },
                            )

                # Transform comment in markdown for security_incident
                new_description = self.utils.transform_description_to_markdown(
                    comment_to_exclude=self.config.servicenow.comment_to_exclude,
                    description=security_incident_object.description,
                    comments=security_incident_object.comments_and_work_notes,
                )
                security_incident_object.comments_and_work_notes = new_description

                # Normalises severity for OpenCTI by finding the first match among known levels
                severity_matched = next(
                    (
                        item
                        for item in ["low", "medium", "high", "critical"]
                        if item in security_incident_object.severity.lower()
                    ),
                    None,
                )
                security_incident_object.severity = severity_matched
                if severity_matched is None:
                    sir_severity = getattr(security_incident_object, "severity", None)
                    self.helper.connector_logger.warning(
                        "[WARNING] Severity has not been correctly identified and will be ignored.",
                        {
                            "security_incident_id": sir_sys_id,
                            "severity_in_security_incident": sir_severity,
                        },
                    )

                # Make Security Incident Response object -> CustomObjectCaseIncident
                custom_case_incident = self.converter_to_stix.make_custom_case_incident(
                    data=security_incident_object,
                    case_incident_related_objects=case_incident_objects,
                    external_references=[external_reference_sir],
                )

                # Make Observables Object
                observables_in_sir = getattr(
                    security_incident_object, "get_observables", None
                )

                if observables_in_sir:
                    observables_list_sir = self._handling_observables(
                        observables=observables_in_sir,
                        entity_number=sir_number,
                    )
                    stix_objects.extend(observables_list_sir)
                    case_incident_objects.extend(observables_list_sir)
                else:
                    self.helper.connector_logger.info(
                        "[CONNECTOR] No observables found for the security incident response (SIR)",
                        {
                            "sir_number": sir_number,
                            "sir_sys_id": sir_sys_id,
                        },
                    )

                # Make Tasks object -> CustomObjectTask
                all_tasks = getattr(security_incident_object, "get_tasks", None)
                if all_tasks:

                    task_all_objects = [custom_case_incident]
                    for task in all_tasks:
                        sit_number = getattr(task, "number", None)
                        sit_sys_id = getattr(task, "sys_id", None)

                        # Make External Reference Task for custom case incident parent
                        external_reference_task = (
                            self.converter_to_stix.make_external_reference(
                                entity_number=sit_number,
                                table_name="task",
                                external_id=sit_sys_id,
                            )
                        )
                        all_external_references.append(external_reference_task)

                        # Transform comment in markdown
                        new_description_task = (
                            self.utils.transform_description_to_markdown(
                                self.config.servicenow.comment_to_exclude,
                                task.description,
                                task.comments_and_work_notes,
                            )
                        )
                        task.comments_and_work_notes = new_description_task

                        # Prepare all the labels for the task (SIT).
                        prepared_labels_sit = self._handling_labels(
                            entity=task,
                            task=True,
                        )

                        # Make Observables Object
                        observables_in_sit = getattr(task, "get_observables", None)
                        if observables_in_sit:
                            observables_list_sit = self._handling_observables(
                                observables=observables_in_sit,
                                entity_number=sit_number,
                            )
                            stix_objects.extend(observables_list_sit)
                            task_all_objects.extend(observables_list_sit)
                            # Add task-related observables to the parent Security incident (SIR)
                            case_incident_objects.extend(observables_list_sit)
                        else:
                            self.helper.connector_logger.info(
                                "[CONNECTOR] No observables found for the task (SIT)",
                                {
                                    "sit_number": sit_number,
                                    "sit_sys_id": sit_sys_id,
                                },
                            )

                        # Make Task object
                        custom_task = self.converter_to_stix.make_custom_task(
                            data=task,
                            all_objects=task_all_objects,
                            all_labels=prepared_labels_sit,
                        )
                        stix_objects.append(custom_task)
                        self.helper.connector_logger.info(
                            "[CONNECTOR] Creating a Task (SIT) object in stix format.",
                            {
                                "sit_number": sit_number,
                                "sit_sys_id": sit_sys_id,
                            },
                        )

                # Prepare all the labels for the Security Incident Response (SIR)
                prepared_labels_sir = self._handling_labels(
                    entity=security_incident_object,
                    security_incident=True,
                )

                # Add all_external_references to the external ref of the parent security incident
                final_custom_case_incident = (
                    self.converter_to_stix.make_custom_case_incident(
                        data=security_incident_object,
                        case_incident_related_objects=case_incident_objects,
                        external_references=all_external_references,
                        labels=prepared_labels_sir,
                    )
                )
                stix_objects.append(final_custom_case_incident)
                self.helper.connector_logger.info(
                    "[CONNECTOR] Creating a Security Incident Response (SIR) object in stix format.",
                    {
                        "sir_number": sir_number,
                        "sir_sys_id": sir_sys_id,
                    },
                )

            if stix_objects:
                # Make Author object
                author = self.converter_to_stix.make_author()
                stix_objects.append(author)

                # Make Markings object
                markings = self.converter_to_stix.make_tlp_marking(
                    level=self.config.servicenow.tlp_level
                )
                stix_objects.append(markings)

            total_stix_objects = len(stix_objects)
            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the transforming all intelligence to STIX 2.1 format.",
                {"total_stix_objects": total_stix_objects},
            )
            return stix_objects

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence transformation.",
                {"error": err},
            )
            raise

    def _prepare_intelligence(self, collected_intelligence: list[dict]) -> list:
        """This is one of the global methods. It will first process the data by validating and filtering it using
        Pydantic models, then transform the validated models into a STIX compatible format.

        Args:
             collected_intelligence (list[dict]): Raw data recovery from ServiceNow.
        Returns:
            List of entities with their stix representation.
        """
        try:
            self.helper.connector_logger.info(
                "[CONNECTOR] Starts preparing data for ServiceNow..."
            )

            # Start validation of information from ServiceNow
            validated_intelligence = self._valid_intelligence(collected_intelligence)

            # Start transformation of validated information into STIX format
            transformed_intelligence = self._transform_intelligence(
                validated_intelligence
            )

            self.helper.connector_logger.info(
                "[CONNECTOR] Finalisation of the preparing of intelligence from ServiceNow"
            )
            return transformed_intelligence

        except Exception as err:
            self.helper.connector_logger.error(
                "[ERROR] An unexpected error has occurred during intelligence preparation.",
                {"error": err},
            )
            raise

    def process_message(self) -> None:
        """The main process used by the connector to collect intelligence.
        This method launches the connector, processes the current state,
        collects intelligence data and updates the state of the last successful execution.

        Returns:
            None
        """
        try:
            # Initialization to get the current start utc iso format.
            current_start_utc_isoformat = self.utils.get_now(DateTimeFormat.ISO)

            # Get the current state
            current_state = self.helper.get_state()
            self.last_run_start_datetime = (
                current_state.get("last_run_start_datetime") if current_state else None
            )
            self.last_run_end_datetime_with_ingested_data = (
                current_state.get("last_run_end_datetime_with_ingested_data")
                if current_state
                else None
            )

            self.helper.connector_logger.info(
                "[CONNECTOR] Starting connector...",
                {
                    "connector_name": self.config.connector.name,
                    "connector_start_time": current_start_utc_isoformat,
                    "last_run_start_datetime": (
                        self.last_run_start_datetime
                        if self.last_run_start_datetime
                        else "Connector has never run"
                    ),
                    "last_run_end_datetime_with_ingested_data": (
                        self.last_run_end_datetime_with_ingested_data
                        if self.last_run_end_datetime_with_ingested_data
                        else "Connector has never ingested data"
                    ),
                },
            )

            # Starting information collection from ServiceNow.
            collected_intelligence = asyncio.run(self._collect_intelligence())

            if collected_intelligence:
                # Start preparing data for OpenCTI - Converted to stix format
                prepared_intelligence = self._prepare_intelligence(
                    collected_intelligence
                )

                # Work initialization only after confirmation of the presence of data to be ingested.
                self._initiate_work()

                # Start sending information to OpenCTI.
                self._send_intelligence(prepared_intelligence)
                self.last_run_end_datetime_with_ingested_data = self.utils.get_now(
                    DateTimeFormat.ISO
                )

                # Completing the work once the bundle has been sent to OpenCTI
                self._complete_work()

            # Store the current start utc isoformat as a last run of the connector.
            self.helper.connector_logger.info(
                "[CONNECTOR] Getting current state and update it with last run of the connector.",
                {
                    "current_state": self.last_run_start_datetime,
                    "new_last_run_start_datetime": current_start_utc_isoformat,
                },
            )
            if self.last_run_start_datetime:
                current_state["last_run_start_datetime"] = current_start_utc_isoformat
            else:
                current_state = {"last_run_start_datetime": current_start_utc_isoformat}

            if self.last_run_end_datetime_with_ingested_data:
                current_state["last_run_end_datetime_with_ingested_data"] = (
                    self.last_run_end_datetime_with_ingested_data
                )

            self.helper.set_state(current_state)

        except (KeyboardInterrupt, SystemExit):
            self.helper.connector_logger.info(
                "[CONNECTOR] Connector stopped...",
                {"connector_name": "ServiceNow"},
            )
            sys.exit(0)
        except Exception as err:
            self.helper.connector_logger.error(str(err))

    def run(self) -> None:
        """Run the main process encapsulated in a scheduler.
        It allows you to schedule the process to run at a certain intervals.
        This specific scheduler from the pycti connector helper will also check the queue size of a connector
        If `CONNECTOR_QUEUE_THRESHOLD` is set, if the connector's queue size exceeds the queue threshold,
        the connector's main process will not run until the queue is ingested and reduced sufficiently,
        allowing it to restart during the next scheduler check. (default is 500MB)
        It requires the `duration_period` connector variable in ISO-8601 standard format
        Example: `CONNECTOR_DURATION_PERIOD=PT5M` => Will run the process every 5 minutes
        If `duration_period` is set to 0 then it will function as a run and terminate

        It's important to note that since Pydantic already checks that duration_period is in ISO 8601 format,
        there's no need to use schedule_iso. You can use schedule_process directly, provided you transmit
        duration_period in seconds.

        Returns:
            None
        """
        self.helper.schedule_process(
            message_callback=self.process_message,
            duration_period=self.config.connector.duration_period.total_seconds(),
        )
