"""Converts a GTI vulnerability's CPE data to STIX Software objects."""

from typing import Optional

from connector.src.custom.models.gti.gti_vulnerability_model import (
    CpeObject,
    CpeRange,
    GTIVulnerabilityData,
)
from connector.src.stix.octi.models.software_model import OctiSoftwareModel
from connector.src.utils.converters.generic_converter_config import BaseMapper
from connectors_sdk.models.octi import (  # type: ignore[import-untyped]
    OrganizationAuthor,
    TLPMarking,
)
from stix2.v21 import Software  # type: ignore


class GTIVulnerabilityToSTIXSoftware(BaseMapper):
    """Converts a GTI vulnerability's CPE data to STIX Software objects."""

    def __init__(
        self,
        vulnerability: GTIVulnerabilityData,
        organization: OrganizationAuthor,
        tlp_marking: TLPMarking,
    ):
        """Initialize the GTIVulnerabilityToSTIXSoftware object.

        Args:
            vulnerability (GTIVulnerabilityData): The GTI vulnerability data to convert.
            organization (OrganizationAuthor): The organization identity object.
            tlp_marking (TLPMarking): The TLP marking definition.

        """
        self.vulnerability = vulnerability
        self.organization = organization
        self.tlp_marking = tlp_marking

    def to_stix(self) -> list[Software]:
        """Convert the GTI vulnerability CPE data to STIX Software objects.

        Returns:
            list[Software]: The list of STIX Software objects created from CPE data.

        """
        result: list[Software] = []

        if not self.vulnerability or not self.vulnerability.attributes:
            return result

        attributes = self.vulnerability.attributes
        if not attributes.cpes:
            return result

        for cpe_range in attributes.cpes:
            software_objects = self._process_cpe_range(cpe_range)
            result.extend(software_objects)

        return result

    def _process_cpe_range(self, cpe_range: CpeRange) -> list[Software]:
        """Process a CPE range and create software objects.

        Args:
            cpe_range (CpeRange): The CPE range data to process.

        Returns:
            list[Software]: list of software objects created from the CPE range.

        """
        software_objects: list[Software] = []

        if cpe_range.start_cpe:
            software = self._create_software_from_cpe(cpe_range.start_cpe)
            if software:
                software_objects.append(software)

        if cpe_range.end_cpe and cpe_range.end_cpe != cpe_range.start_cpe:
            software = self._create_software_from_cpe(cpe_range.end_cpe)
            if software:
                software_objects.append(software)

        return software_objects

    def _create_software_from_cpe(self, cpe_object: CpeObject) -> Optional[Software]:
        """Create a Software object from CPE object data.

        Args:
            cpe_object (CpeObject): The CPE object data containing software information.

        Returns:
            Optional[Software]: The STIX Software object, or None if invalid CPE data.

        """
        if not cpe_object.product and not cpe_object.uri:
            return None

        name = cpe_object.product or self._extract_name_from_uri(cpe_object.uri)
        if not name:
            return None

        software = OctiSoftwareModel.create(
            name=name,
            organization_id=self.organization.id,
            marking_ids=[self.tlp_marking.id],
            cpe=cpe_object.uri,
            vendor=cpe_object.vendor,
            version=cpe_object.version,
            product=cpe_object.product,
            create_indicator=False,
        )

        return software.to_stix2_object()

    def _extract_name_from_uri(self, uri: Optional[str]) -> Optional[str]:
        """Extract product name from CPE URI if product name is not available.

        Args:
            uri (Optional[str]): The CPE URI string.

        Returns:
            Optional[str]: Extracted product name or None if extraction fails.

        """
        if not uri:
            return None

        try:
            parts = uri.split(":")

            if uri.startswith("cpe:2.3:") and len(parts) >= 5:
                product = parts[4]
            elif uri.startswith("cpe:/") and len(parts) >= 4:
                product = parts[3]
            else:
                return None

            if product and product != "*":
                return product
        except (IndexError, AttributeError):
            pass

        return None
