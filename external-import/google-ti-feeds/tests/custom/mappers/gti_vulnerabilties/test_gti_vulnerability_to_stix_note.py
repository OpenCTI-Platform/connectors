"""Tests for the GTIVulnerabilityToSTIXNote mapper."""

from datetime import datetime, timezone
from uuid import uuid4

import pytest
from connector.src.custom.mappers.gti_vulnerabilities.gti_vulnerability_to_stix_note import (
    GTIVulnerabilityToSTIXNote,
)
from connector.src.custom.models.gti.gti_vulnerability_model import (
    GTIVulnerabilityData,
    VulnerabilityModel,
)
from polyfactory.factories.pydantic_factory import ModelFactory
from polyfactory.fields import Use
from stix2.v21 import Identity, MarkingDefinition  # type: ignore


class VulnerabilityModelFactory(ModelFactory[VulnerabilityModel]):
    """Factory for VulnerabilityModel."""

    __model__ = VulnerabilityModel


class GTIVulnerabilityDataFactory(ModelFactory[GTIVulnerabilityData]):
    """Factory for GTIVulnerabilityData."""

    __model__ = GTIVulnerabilityData

    type = "vulnerability"
    attributes = Use(VulnerabilityModelFactory.build)


@pytest.fixture
def mock_organization():
    """Mock organization Identity object."""
    return Identity(  # pylint: disable=W9101  # it's a test no real ingest
        name="Test Organization",
        identity_class="organization",
    )


@pytest.fixture
def mock_tlp_marking():
    """Mock TLP marking definition object."""
    return MarkingDefinition(
        id=f"marking-definition--{uuid4()}",
        definition_type="statement",
        definition={"statement": "Internal Use Only"},
    )


@pytest.fixture
def vulnerability_with_workarounds() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with workaround data."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-1234",
        attributes=VulnerabilityModelFactory.build(
            name="CVE-2023-1234",
            workarounds=[
                "Apply the latest security patches immediately.",
                "Disable the vulnerable service until patch is available.",
                "Configure firewall rules to block access to the vulnerable component.",
            ],
            creation_date=1672531200,  # 2023-01-01
            last_modification_date=1672617600,  # 2023-01-02
        ),
    )


@pytest.fixture
def vulnerability_with_single_workaround() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with single workaround."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-5678",
        attributes=VulnerabilityModelFactory.build(
            name="CVE-2023-5678",
            workarounds=[
                "Update to the latest version of the software to mitigate this vulnerability.",
            ],
            creation_date=1672531200,
            last_modification_date=1672617600,
        ),
    )


@pytest.fixture
def vulnerability_without_workarounds() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability without workaround data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(workarounds=None)
    )


@pytest.fixture
def vulnerability_with_empty_workarounds() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with empty workarounds list."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(workarounds=[])
    )


@pytest.fixture
def vulnerability_without_attributes() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability without attributes."""
    return GTIVulnerabilityDataFactory.build(attributes=None)


@pytest.fixture
def vulnerability_with_empty_workarounds_strings() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with empty workaround strings."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            workarounds=[
                "Valid workaround text",
                "",
                "   ",
                "Another valid workaround",
            ]
        )
    )


@pytest.fixture
def vulnerability_with_long_workaround() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with very long workaround text."""
    long_workaround = "A" * 500  # 500 character workaround
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-9999",
        attributes=VulnerabilityModelFactory.build(
            name="CVE-2023-9999",
            workarounds=[long_workaround],
            creation_date=1672531200,
            last_modification_date=1672617600,
        ),
    )


@pytest.fixture
def vulnerability_with_unicode_workarounds() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with unicode characters in workarounds."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-UNICODE",
        attributes=VulnerabilityModelFactory.build(
            name="CVE-2023-UNICODE",
            workarounds=[
                "Apply security patch: 修复安全漏洞",
                "Configure settings with special chars: αβγδε & émojis 🔒",
            ],
            creation_date=1672531200,
            last_modification_date=1672617600,
        ),
    )


@pytest.fixture
def vulnerability_with_invalid_timestamps() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with invalid timestamps."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-INVALID",
        attributes=VulnerabilityModelFactory.build(
            name="CVE-2023-INVALID",
            workarounds=["Apply security patch"],
            creation_date=-1,  # Invalid timestamp
            last_modification_date=-1,  # Invalid timestamp
        ),
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_workarounds(
    vulnerability_with_workarounds, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with workarounds to STIX notes."""
    # GIVEN: A GTI vulnerability containing multiple workaround instructions
    # with valid text content for security mitigation guidance
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_workarounds, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Note objects should be created successfully
    # with one note per workaround instruction
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 3  # noqa: S101
    _then_stix_note_has_correct_properties(note_objects[0], mock_organization)
    _then_stix_note_has_workaround_content(
        note_objects[0], "Apply the latest security patches immediately."
    )
    _then_stix_note_has_workaround_labels(note_objects[0])


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_single_workaround(
    vulnerability_with_single_workaround, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with single workaround."""
    # GIVEN: A GTI vulnerability containing a single workaround instruction
    # with detailed mitigation guidance for the vulnerability
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_single_workaround, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: A single STIX Note object should be created
    # with proper workaround content and metadata
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 1  # noqa: S101
    _then_stix_note_has_correct_properties(note_objects[0], mock_organization)
    _then_stix_note_has_workaround_content(
        note_objects[0],
        "Update to the latest version of the software to mitigate this vulnerability.",
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_without_workarounds(
    vulnerability_without_workarounds, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability without workarounds."""
    # GIVEN: A GTI vulnerability with no workaround data defined
    # indicating no mitigation guidance is available
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_without_workarounds, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since no workaround information is available to convert
    assert isinstance(note_objects, list)  # noqa: S101
    assert len(note_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_empty_workarounds(
    vulnerability_with_empty_workarounds, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with empty workarounds list."""
    # GIVEN: A GTI vulnerability with empty list for workarounds
    # representing a case where workaround fields exist but contain no data
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_empty_workarounds, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since empty workaround lists provide no guidance information
    assert isinstance(note_objects, list)  # noqa: S101
    assert len(note_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_without_attributes(
    vulnerability_without_attributes, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability without attributes."""
    # GIVEN: A GTI vulnerability with attributes field set to None
    # making it impossible to access any vulnerability data including workarounds
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_without_attributes, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since no attributes are available to process
    assert isinstance(note_objects, list)  # noqa: S101
    assert len(note_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_empty_strings(
    vulnerability_with_empty_workarounds_strings, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with empty workaround strings."""
    # GIVEN: A GTI vulnerability containing mixed valid and invalid workaround strings
    # including empty strings, whitespace-only strings, and None values
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_empty_workarounds_strings,
        mock_organization,
        mock_tlp_marking,
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: Only valid workarounds should be processed into STIX Note objects
    # while empty/invalid strings are skipped without affecting valid ones
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 2  # noqa: S101  # Only valid workarounds

    # Verify only valid workarounds are present
    note_contents = [note.content for note in note_objects]
    assert "Valid workaround text" in note_contents  # noqa: S101
    assert "Another valid workaround" in note_contents  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_long_workaround(
    vulnerability_with_long_workaround, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with very long workaround text."""
    # GIVEN: A GTI vulnerability containing extremely long workaround text
    # to test boundary conditions and ensure long content is handled properly
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_long_workaround, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Note object should be created successfully
    # preserving the full length of the workaround text without truncation
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 1  # noqa: S101
    _then_stix_note_preserves_long_content(note_objects[0])
    _then_stix_note_has_truncated_abstract(note_objects[0])


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_unicode_characters(
    vulnerability_with_unicode_workarounds, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with unicode characters in workarounds."""
    # GIVEN: A GTI vulnerability containing workarounds with unicode characters
    # including non-Latin scripts and special symbols to test character encoding
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_unicode_workarounds, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Note objects should be created successfully
    # preserving all unicode characters in the workaround content without modification
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 2  # noqa: S101
    _then_stix_note_preserves_unicode_characters(note_objects)


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_note_with_invalid_timestamps(
    vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with invalid timestamps."""
    # GIVEN: A GTI vulnerability containing invalid timestamp values
    # that cannot be converted to valid datetime objects
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability workaround data to STIX note objects
    note_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Note objects should be created successfully
    # with fallback timestamps handling invalid input gracefully
    _then_stix_notes_created_successfully(note_objects)
    assert len(note_objects) == 1  # noqa: S101
    _then_stix_note_handles_invalid_timestamps(note_objects[0])


@pytest.mark.order(1)
def test_create_workaround_note_with_complete_data(
    vulnerability_with_workarounds, mock_organization, mock_tlp_marking
):
    """Test creating workaround note with complete data."""
    # GIVEN: A GTI vulnerability note mapper with complete workaround data
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_workarounds, mock_organization, mock_tlp_marking
    )
    workaround_text = "Apply the latest security patches immediately."
    created = datetime.fromtimestamp(1672531200, tz=timezone.utc)
    modified = datetime.fromtimestamp(1672617600, tz=timezone.utc)

    # WHEN: Creating a workaround note from the data
    note = mapper._create_workaround_note(workaround_text, 1, created, modified)

    # THEN: A valid STIX Note object should be created
    # with proper workaround content and metadata properties
    assert note is not None  # noqa: S101
    _then_stix_note_has_workaround_content(note, workaround_text)
    _then_stix_note_has_workaround_labels(note)
    _then_stix_note_has_correct_timestamps(note, created, modified)


@pytest.mark.order(1)
def test_extract_timestamps_with_valid_data(
    vulnerability_with_workarounds, mock_organization, mock_tlp_marking
):
    """Test extracting timestamps with valid data."""
    # GIVEN: A GTI vulnerability note mapper with valid timestamp data
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_workarounds, mock_organization, mock_tlp_marking
    )
    attributes = vulnerability_with_workarounds.attributes

    # WHEN: Extracting timestamps from the attributes
    created, modified = mapper._extract_timestamps(attributes)

    # THEN: Valid datetime objects should be created from timestamps
    # with proper conversion from Unix timestamp format
    assert isinstance(created, datetime)  # noqa: S101
    assert isinstance(modified, datetime)  # noqa: S101
    assert created.year == 2023  # noqa: S101
    assert modified.year == 2023  # noqa: S101


@pytest.mark.order(1)
def test_extract_timestamps_with_invalid_data(
    vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
):
    """Test extracting timestamps with invalid data."""
    # GIVEN: A GTI vulnerability note mapper with invalid timestamp data
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
    )
    attributes = vulnerability_with_invalid_timestamps.attributes

    # WHEN: Extracting timestamps from invalid attributes
    created, modified = mapper._extract_timestamps(attributes)

    # THEN: Fallback datetime objects should be created
    # using current time when conversion fails
    assert isinstance(created, datetime)  # noqa: S101
    assert isinstance(modified, datetime)  # noqa: S101


@pytest.mark.order(1)
def test_build_external_references_with_complete_data(
    vulnerability_with_workarounds, mock_organization, mock_tlp_marking
):
    """Test building external references with complete data."""
    # GIVEN: A GTI vulnerability note mapper with complete vulnerability data
    mapper = _given_gti_vulnerability_note_mapper(
        vulnerability_with_workarounds, mock_organization, mock_tlp_marking
    )

    # WHEN: Building external references for a workaround note
    external_references = mapper._build_external_references(1)

    # THEN: External references should contain vulnerability information
    # linking the workaround back to the source vulnerability
    assert len(external_references) == 1  # noqa: S101
    assert "GTI" in external_references[0]["source_name"]  # noqa: S101
    assert "Workaround 1" in external_references[0]["source_name"]  # noqa: S101
    assert "virustotal.com" in external_references[0]["url"]  # noqa: S101
    assert (  # noqa: S101
        vulnerability_with_workarounds.id in external_references[0]["url"]
    )


@pytest.mark.order(1)
def test_gti_vulnerability_note_mapper_initialization(
    vulnerability_with_workarounds, mock_organization, mock_tlp_marking
):
    """Test GTIVulnerabilityToSTIXNote mapper initialization."""
    # GIVEN: Valid GTI vulnerability data, organization, and TLP marking objects
    # for initializing the mapper with all required dependencies
    # WHEN: Creating a new GTIVulnerabilityToSTIXNote mapper instance
    mapper = GTIVulnerabilityToSTIXNote(
        vulnerability=vulnerability_with_workarounds,
        organization=mock_organization,
        tlp_marking=mock_tlp_marking,
    )

    # THEN: The mapper should be initialized correctly
    # with all provided objects properly assigned to instance attributes
    assert mapper.vulnerability == vulnerability_with_workarounds  # noqa: S101
    assert mapper.organization == mock_organization  # noqa: S101
    assert mapper.tlp_marking == mock_tlp_marking  # noqa: S101


def _given_gti_vulnerability_note_mapper(
    vulnerability: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> GTIVulnerabilityToSTIXNote:
    """Create a GTIVulnerabilityToSTIXNote mapper instance."""
    return GTIVulnerabilityToSTIXNote(
        vulnerability=vulnerability,
        organization=organization,
        tlp_marking=tlp_marking,
    )


def _when_convert_to_stix(mapper: GTIVulnerabilityToSTIXNote) -> list:
    """Convert GTI vulnerability to STIX note objects."""
    return mapper.to_stix()


def _then_stix_notes_created_successfully(note_objects: list):
    """Assert that STIX note objects were created successfully."""
    assert isinstance(note_objects, list)  # noqa: S101
    assert len(note_objects) > 0  # noqa: S101
    for note in note_objects:
        assert hasattr(note, "content")  # noqa: S101
        assert hasattr(note, "type")  # noqa: S101
        assert hasattr(note, "spec_version")  # noqa: S101
        assert hasattr(note, "created")  # noqa: S101
        assert hasattr(note, "modified")  # noqa: S101


def _then_stix_note_has_correct_properties(note, organization: Identity):
    """Assert that STIX note has correct properties."""
    assert note.created_by_ref == organization.id  # noqa: S101
    assert note.spec_version == "2.1"  # noqa: S101
    assert note.type == "note"  # noqa: S101


def _then_stix_note_has_workaround_content(note, expected_content: str):
    """Assert that STIX note has correct workaround content."""
    assert note.content == expected_content  # noqa: S101


def _then_stix_note_has_workaround_labels(note):
    """Assert that STIX note has correct workaround labels."""
    assert "workaround" in note.labels  # noqa: S101


def _then_stix_note_has_correct_timestamps(
    note, expected_created: datetime, expected_modified: datetime
):
    """Assert that STIX note has correct timestamps."""
    assert note.created == expected_created  # noqa: S101
    assert note.modified == expected_modified  # noqa: S101


def _then_stix_note_preserves_long_content(note):
    """Assert that STIX note preserves long content."""
    assert len(note.content) == 500  # noqa: S101
    assert note.content == "A" * 500  # noqa: S101


def _then_stix_note_has_truncated_abstract(note):
    """Assert that STIX note has truncated abstract for long content."""
    assert len(note.abstract) == 100  # noqa: S101
    assert note.abstract.endswith("...")  # noqa: S101


def _then_stix_note_preserves_unicode_characters(note_objects: list):
    """Assert that STIX notes preserve unicode characters."""
    contents = [note.content for note in note_objects]
    assert any("修复安全漏洞" in content for content in contents)  # noqa: S101
    assert any("αβγδε" in content for content in contents)  # noqa: S101
    assert any("🔒" in content for content in contents)  # noqa: S101


def _then_stix_note_handles_invalid_timestamps(note):
    """Assert that STIX note handles invalid timestamps gracefully."""
    assert isinstance(note.created, datetime)  # noqa: S101
    assert isinstance(note.modified, datetime)  # noqa: S101
