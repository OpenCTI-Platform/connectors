"""Tests for the GTIVulnerabilityToSTIXSoftware mapper."""

from uuid import uuid4

import pytest
from connector.src.custom.mappers.gti_vulnerabilities.gti_vulnerability_to_stix_software import (
    GTIVulnerabilityToSTIXSoftware,
)
from connector.src.custom.models.gti.gti_vulnerability_model import (
    CpeObject,
    CpeRange,
    GTIVulnerabilityData,
    VulnerabilityModel,
)
from polyfactory.factories.pydantic_factory import ModelFactory
from polyfactory.fields import Use
from stix2.v21 import Identity, MarkingDefinition  # type: ignore


class CpeObjectFactory(ModelFactory[CpeObject]):
    """Factory for CpeObject model."""

    __model__ = CpeObject


class CpeRangeFactory(ModelFactory[CpeRange]):
    """Factory for CpeRange model."""

    __model__ = CpeRange


class VulnerabilityModelFactory(ModelFactory[VulnerabilityModel]):
    """Factory for VulnerabilityModel."""

    __model__ = VulnerabilityModel


class GTIVulnerabilityDataFactory(ModelFactory[GTIVulnerabilityData]):
    """Factory for GTIVulnerabilityData."""

    __model__ = GTIVulnerabilityData

    type = "vulnerability"
    attributes = Use(VulnerabilityModelFactory.build)


@pytest.fixture
def mock_organization():
    """Mock organization Identity object."""
    return Identity(
        name="Test Organization",
        identity_class="organization",
    )


@pytest.fixture
def mock_tlp_marking():
    """Mock TLP marking definition object."""
    return MarkingDefinition(
        id=f"marking-definition--{uuid4()}",
        definition_type="statement",
        definition={"statement": "Internal Use Only"},
    )


@pytest.fixture
def vulnerability_with_cpe_data() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with CPE data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product="apache_http_server",
                        vendor="apache",
                        version="2.4.41",
                        uri="cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*",
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.fixture
def vulnerability_with_multiple_cpe_data() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with multiple CPE data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product="apache_http_server",
                        vendor="apache",
                        version="2.4.41",
                        uri="cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*",
                    ),
                    end_cpe=CpeObjectFactory.build(
                        product="apache_http_server",
                        vendor="apache",
                        version="2.4.49",
                        uri="cpe:2.3:a:apache:http_server:2.4.49:*:*:*:*:*:*:*",
                    ),
                ),
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product="nginx",
                        vendor="nginx",
                        version="1.18.0",
                        uri="cpe:2.3:a:nginx:nginx:1.18.0:*:*:*:*:*:*:*",
                    ),
                    end_cpe=None,
                ),
            ]
        )
    )


@pytest.fixture
def vulnerability_without_cpe() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability without CPE data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(cpes=None)
    )


@pytest.fixture
def vulnerability_with_empty_cpe() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with empty CPE list."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(cpes=[])
    )


@pytest.fixture
def vulnerability_without_attributes() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability without attributes."""
    return GTIVulnerabilityDataFactory.build(attributes=None)


@pytest.fixture
def vulnerability_with_cpe_no_product() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with CPE data without product."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product=None,
                        vendor="apache",
                        version="2.4.41",
                        uri="cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*",
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.fixture
def vulnerability_with_cpe_no_uri() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with CPE data without URI."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product="apache_http_server",
                        vendor="apache",
                        version="2.4.41",
                        uri=None,
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.fixture
def vulnerability_with_invalid_cpe() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with invalid CPE data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product=None,
                        vendor=None,
                        version=None,
                        uri=None,
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.fixture
def vulnerability_with_cpe_v22_uri() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with CPE v2.2 URI."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product=None,
                        vendor="apache",
                        version="2.4.41",
                        uri="cpe:/a:apache:http_server:2.4.41",
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.fixture
def vulnerability_with_cpe_special_chars() -> GTIVulnerabilityData:
    """Fixture for GTI vulnerability with CPE containing special characters."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cpes=[
                CpeRangeFactory.build(
                    start_cpe=CpeObjectFactory.build(
                        product="microsoft_sql_server",
                        vendor="microsoft",
                        version="2019",
                        uri="cpe:2.3:a:microsoft:sql_server:2019:*:*:*:*:*:*:*",
                    ),
                    end_cpe=None,
                )
            ]
        )
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_cpe_data(
    vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with CPE data to STIX software."""
    # GIVEN: A GTI vulnerability containing CPE data for software identification
    # with valid product, vendor, version, and URI information
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created successfully
    # with proper software identification from CPE data
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 1  # noqa: S101
    _then_stix_software_has_correct_properties(software_objects[0], mock_organization)
    _then_stix_software_has_cpe_properties(
        software_objects[0], "apache_http_server", "apache", "2.4.41"
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_multiple_cpe(
    vulnerability_with_multiple_cpe_data, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with multiple CPE data."""
    # GIVEN: A GTI vulnerability containing multiple CPE ranges
    # with both start and end CPE objects and different software products
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_multiple_cpe_data, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created for all CPE entries
    # with proper software identification for each product
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 3  # noqa: S101
    _then_stix_software_has_correct_properties(software_objects[0], mock_organization)

    # Verify all expected software products are present
    software_names = [software.name for software in software_objects]
    assert "apache_http_server" in software_names  # noqa: S101
    assert "nginx" in software_names  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_without_cpe(
    vulnerability_without_cpe, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability without CPE data."""
    # GIVEN: A GTI vulnerability with no CPE data defined
    # indicating no software identification information is available
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_without_cpe, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since no CPE information is available to convert
    assert isinstance(software_objects, list)  # noqa: S101
    assert len(software_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_empty_cpe(
    vulnerability_with_empty_cpe, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with empty CPE list."""
    # GIVEN: A GTI vulnerability with empty list for CPE data
    # representing a case where CPE fields exist but contain no data
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_empty_cpe, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since empty CPE lists provide no software information
    assert isinstance(software_objects, list)  # noqa: S101
    assert len(software_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_without_attributes(
    vulnerability_without_attributes, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability without attributes."""
    # GIVEN: A GTI vulnerability with attributes field set to None
    # making it impossible to access any vulnerability data including CPE
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_without_attributes, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: An empty list should be returned
    # since no attributes are available to process
    assert isinstance(software_objects, list)  # noqa: S101
    assert len(software_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_cpe_no_product(
    vulnerability_with_cpe_no_product, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with CPE without product name."""
    # GIVEN: A GTI vulnerability containing CPE data without product name
    # but with a valid URI that contains product information
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_no_product, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created using extracted product name from URI
    # demonstrating fallback functionality for missing product names
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 1  # noqa: S101
    _then_stix_software_has_extracted_name(software_objects[0], "http_server")


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_cpe_no_uri(
    vulnerability_with_cpe_no_uri, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with CPE without URI."""
    # GIVEN: A GTI vulnerability containing CPE data without URI
    # but with a valid product name for software identification
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_no_uri, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created using product name
    # even without URI information
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 1  # noqa: S101
    _then_stix_software_has_cpe_properties(
        software_objects[0], "apache_http_server", "apache", "2.4.41"
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_invalid_cpe(
    vulnerability_with_invalid_cpe, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with invalid CPE data."""
    # GIVEN: A GTI vulnerability containing invalid CPE data
    # with no product name or URI for software identification
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_invalid_cpe, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: No software objects should be created from invalid CPE data
    # since both product name and URI are required for identification
    assert isinstance(software_objects, list)  # noqa: S101
    assert len(software_objects) == 0  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_cpe_v22_uri(
    vulnerability_with_cpe_v22_uri, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with CPE v2.2 URI."""
    # GIVEN: A GTI vulnerability containing CPE v2.2 format URI
    # without product name requiring URI parsing for identification
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_v22_uri, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created with extracted product name
    # demonstrating support for CPE v2.2 format URI parsing
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 1  # noqa: S101
    _then_stix_software_has_extracted_name(software_objects[0], "http_server")


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_software_with_special_chars(
    vulnerability_with_cpe_special_chars, mock_organization, mock_tlp_marking
):
    """Test conversion of GTI vulnerability with CPE containing special characters."""
    # GIVEN: A GTI vulnerability containing CPE data with underscores and special characters
    # to test proper handling of product names with formatting
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_special_chars, mock_organization, mock_tlp_marking
    )

    # WHEN: Converting the GTI vulnerability CPE data to STIX software objects
    software_objects = _when_convert_to_stix(mapper)

    # THEN: STIX Software objects should be created preserving special characters
    # in product names without modification or sanitization
    _then_stix_software_created_successfully(software_objects)
    assert len(software_objects) == 1  # noqa: S101
    _then_stix_software_has_cpe_properties(
        software_objects[0], "microsoft_sql_server", "microsoft", "2019"
    )


@pytest.mark.order(1)
def test_process_cpe_range_with_start_and_end(
    vulnerability_with_multiple_cpe_data, mock_organization, mock_tlp_marking
):
    """Test processing CPE range with both start and end CPE objects."""
    # GIVEN: A GTI vulnerability software mapper with CPE range containing both start and end
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_multiple_cpe_data, mock_organization, mock_tlp_marking
    )
    cpe_range = vulnerability_with_multiple_cpe_data.attributes.cpes[0]

    # WHEN: Processing the CPE range
    software_objects = mapper._process_cpe_range(cpe_range)

    # THEN: Software objects should be created for both start and end CPE objects
    # providing complete software version range coverage
    assert len(software_objects) == 2  # noqa: S101
    software_names = [software.name for software in software_objects]
    assert "apache_http_server" in software_names  # noqa: S101


@pytest.mark.order(1)
def test_process_cpe_range_with_start_only(
    vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
):
    """Test processing CPE range with start CPE object only."""
    # GIVEN: A GTI vulnerability software mapper with CPE range containing only start CPE
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
    )
    cpe_range = vulnerability_with_cpe_data.attributes.cpes[0]

    # WHEN: Processing the CPE range
    software_objects = mapper._process_cpe_range(cpe_range)

    # THEN: Software object should be created for start CPE object only
    # handling single-point CPE references appropriately
    assert len(software_objects) == 1  # noqa: S101
    assert software_objects[0].name == "apache_http_server"  # noqa: S101


@pytest.mark.order(1)
def test_create_software_from_cpe_with_all_fields(
    vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
):
    """Test creating software from CPE object with all fields."""
    # GIVEN: A GTI vulnerability software mapper and CPE object with complete data
    mapper = _given_gti_vulnerability_software_mapper(
        vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
    )
    cpe_object = vulnerability_with_cpe_data.attributes.cpes[0].start_cpe

    # WHEN: Creating software from the CPE object
    software = mapper._create_software_from_cpe(cpe_object)

    # THEN: Software object should be created with all CPE field data
    # including product, vendor, version, and URI information
    assert software is not None  # noqa: S101
    _then_stix_software_has_cpe_properties(
        software, "apache_http_server", "apache", "2.4.41"
    )
    assert (  # noqa: S101
        software.cpe == "cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*"
    )


@pytest.mark.order(1)
def test_extract_name_from_uri_cpe_v23():
    """Test extracting product name from CPE v2.3 URI."""
    # GIVEN: A GTI vulnerability software mapper
    mapper = GTIVulnerabilityToSTIXSoftware(None, None, None)
    uri = "cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*"

    # WHEN: Extracting product name from CPE v2.3 URI
    product_name = mapper._extract_name_from_uri(uri)

    # THEN: Product name should be extracted as raw value
    # without any formatting or case conversion
    assert product_name == "http_server"  # noqa: S101


@pytest.mark.order(1)
def test_extract_name_from_uri_cpe_v22():
    """Test extracting product name from CPE v2.2 URI."""
    # GIVEN: A GTI vulnerability software mapper
    mapper = GTIVulnerabilityToSTIXSoftware(None, None, None)
    uri = "cpe:/a:apache:http_server:2.4.41"

    # WHEN: Extracting product name from CPE v2.2 URI
    product_name = mapper._extract_name_from_uri(uri)

    # THEN: Product name should be extracted as raw value
    # handling legacy CPE format appropriately
    assert product_name == "http_server"  # noqa: S101


@pytest.mark.order(1)
def test_extract_name_from_uri_invalid():
    """Test extracting product name from invalid URI."""
    # GIVEN: A GTI vulnerability software mapper
    mapper = GTIVulnerabilityToSTIXSoftware(None, None, None)
    uri = "invalid:uri:format"

    # WHEN: Extracting product name from invalid URI
    product_name = mapper._extract_name_from_uri(uri)

    # THEN: No product name should be extracted from invalid format
    assert product_name is None  # noqa: S101


@pytest.mark.order(1)
def test_extract_name_from_uri_none():
    """Test extracting product name from None URI."""
    # GIVEN: A GTI vulnerability software mapper
    mapper = GTIVulnerabilityToSTIXSoftware(None, None, None)

    # WHEN: Extracting product name from None URI
    product_name = mapper._extract_name_from_uri(None)

    # THEN: No product name should be extracted from None input
    assert product_name is None  # noqa: S101


@pytest.mark.order(1)
def test_gti_vulnerability_software_mapper_initialization(
    vulnerability_with_cpe_data, mock_organization, mock_tlp_marking
):
    """Test GTIVulnerabilityToSTIXSoftware mapper initialization."""
    # GIVEN: Valid GTI vulnerability data, organization, and TLP marking objects
    # for initializing the mapper with all required dependencies
    # WHEN: Creating a new GTIVulnerabilityToSTIXSoftware mapper instance
    mapper = GTIVulnerabilityToSTIXSoftware(
        vulnerability=vulnerability_with_cpe_data,
        organization=mock_organization,
        tlp_marking=mock_tlp_marking,
    )

    # THEN: The mapper should be initialized correctly
    # with all provided objects properly assigned to instance attributes
    assert mapper.vulnerability == vulnerability_with_cpe_data  # noqa: S101
    assert mapper.organization == mock_organization  # noqa: S101
    assert mapper.tlp_marking == mock_tlp_marking  # noqa: S101


def _given_gti_vulnerability_software_mapper(
    vulnerability: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> GTIVulnerabilityToSTIXSoftware:
    """Create a GTIVulnerabilityToSTIXSoftware mapper instance."""
    return GTIVulnerabilityToSTIXSoftware(
        vulnerability=vulnerability,
        organization=organization,
        tlp_marking=tlp_marking,
    )


def _when_convert_to_stix(mapper: GTIVulnerabilityToSTIXSoftware) -> list:
    """Convert GTI vulnerability to STIX software objects."""
    return mapper.to_stix()


def _then_stix_software_created_successfully(software_objects: list):
    """Assert that STIX software objects were created successfully."""
    assert isinstance(software_objects, list)  # noqa: S101
    assert len(software_objects) > 0  # noqa: S101
    for software in software_objects:
        assert hasattr(software, "name")  # noqa: S101
        assert hasattr(software, "type")  # noqa: S101
        assert hasattr(software, "spec_version")  # noqa: S101
        assert hasattr(software, "id")  # noqa: S101
        assert hasattr(software, "object_marking_refs")  # noqa: S101


def _then_stix_software_has_correct_properties(software, organization: Identity):
    """Assert that STIX software has correct properties."""
    assert organization.id in str(software.custom_properties)  # noqa: S101
    assert software.spec_version == "2.1"  # noqa: S101
    assert software.type == "software"  # noqa: S101


def _then_stix_software_has_cpe_properties(
    software, expected_product: str, expected_vendor: str, expected_version: str
):
    """Assert that STIX software has correct CPE properties."""
    assert software.name == expected_product  # noqa: S101
    assert software.vendor == expected_vendor  # noqa: S101
    assert software.version == expected_version  # noqa: S101
    assert (  # noqa: S101
        software.custom_properties.get("x_opencti_product") == expected_product
    )


def _then_stix_software_has_extracted_name(software, expected_name: str):
    """Assert that STIX software has extracted name from URI."""
    assert software.name == expected_name  # noqa: S101
