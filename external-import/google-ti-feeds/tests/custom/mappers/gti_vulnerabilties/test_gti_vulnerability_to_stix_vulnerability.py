"""Module to test the GTI vulnerability to STIX vulnerability mapper."""

from datetime import datetime
from typing import Any
from uuid import uuid4

import pytest
from connector.src.custom.mappers.gti_vulnerabilities.gti_vulnerability_to_stix_vulnerability import (
    GTIVulnerabilityToSTIXVulnerability,
)
from connector.src.custom.models.gti.gti_vulnerability_model import (
    Cvss,
    CvssV2,
    CvssV3,
    CvssV4,
    CvssV4Threat,
    Cwe,
    Epss,
    GTIVulnerabilityData,
    TagDetail,
    VulnerabilityModel,
)
from polyfactory import Use
from polyfactory.factories.pydantic_factory import ModelFactory
from stix2.v21 import Identity, MarkingDefinition  # type: ignore

# =====================
# Polyfactory Factories
# =====================


class CvssV2Factory(ModelFactory[CvssV2]):
    """Factory for CvssV2 model."""

    __model__ = CvssV2


class CvssV3Factory(ModelFactory[CvssV3]):
    """Factory for CvssV3 model."""

    __model__ = CvssV3


class CvssV4ThreatFactory(ModelFactory[CvssV4Threat]):
    """Factory for CvssV4Threat model."""

    __model__ = CvssV4Threat


class CvssV4Factory(ModelFactory[CvssV4]):
    """Factory for CvssV4 model."""

    __model__ = CvssV4

    threat = Use(CvssV4ThreatFactory.build)


class CvssFactory(ModelFactory[Cvss]):
    """Factory for Cvss model."""

    __model__ = Cvss

    cvssv2_0 = Use(CvssV2Factory.build)
    cvssv3_x = Use(CvssV3Factory.build)
    cvssv4_x = Use(CvssV4Factory.build)


class EpssFactory(ModelFactory[Epss]):
    """Factory for Epss model."""

    __model__ = Epss


class CweFactory(ModelFactory[Cwe]):
    """Factory for Cwe model."""

    __model__ = Cwe


class TagDetailFactory(ModelFactory[TagDetail]):
    """Factory for TagDetail model."""

    __model__ = TagDetail


class VulnerabilityModelFactory(ModelFactory[VulnerabilityModel]):
    """Factory for VulnerabilityModel."""

    __model__ = VulnerabilityModel


class GTIVulnerabilityDataFactory(ModelFactory[GTIVulnerabilityData]):
    """Factory for GTIVulnerabilityData."""

    __model__ = GTIVulnerabilityData

    type = "vulnerability"
    attributes = Use(VulnerabilityModelFactory.build)


# =====================
# Fixtures
# =====================


@pytest.fixture
def mock_organization() -> Identity:
    """Fixture for mock organization identity."""
    return Identity(
        id=f"identity--{uuid4()}",
        name="Test Organization",
        identity_class="organization",
    )


@pytest.fixture
def mock_tlp_marking() -> MarkingDefinition:
    """Fixture for mock TLP marking definition."""
    return MarkingDefinition(
        id=f"marking-definition--{uuid4()}",
        definition_type="statement",
        definition={"statement": "Internal Use Only"},
    )


@pytest.fixture
def minimal_vulnerability_data() -> GTIVulnerabilityData:
    """Fixture for minimal vulnerability data."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-1234",
        attributes=VulnerabilityModelFactory.build(
            name="Test Vulnerability",
            description="Test vulnerability description",
            cvss=None,
            epss=None,
            cwe=None,
            tags_details=None,
        ),
    )


@pytest.fixture
def vulnerability_with_cvss_v3() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with CVSSv3 information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-5678",
        attributes=VulnerabilityModelFactory.build(
            name="CVSSv3 Vulnerability",
            cvss=CvssFactory.build(
                cvssv3_x=CvssV3Factory.build(
                    base_score=7.5,
                    vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                ),
                cvssv2_0=None,
                cvssv4_x=None,
            ),
        ),
    )


@pytest.fixture
def vulnerability_with_cvss_v2() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with CVSSv2 information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-9012",
        attributes=VulnerabilityModelFactory.build(
            name="CVSSv2 Vulnerability",
            cvss=CvssFactory.build(
                cvssv2_0=CvssV2Factory.build(
                    base_score=6.8,
                    vector="AV:N/AC:M/Au:N/C:P/I:P/A:P",
                    temporal_score=5.5,
                ),
                cvssv3_x=None,
                cvssv4_x=None,
            ),
        ),
    )


@pytest.fixture
def vulnerability_with_cvss_v4() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with CVSSv4 information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-3456",
        attributes=VulnerabilityModelFactory.build(
            name="CVSSv4 Vulnerability",
            cvss=CvssFactory.build(
                cvssv4_x=CvssV4Factory.build(
                    score=8.2,
                    vector="CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:N/VA:N/SC:N/SI:N/SA:N",
                    threat=CvssV4ThreatFactory.build(
                        exploit_maturity="Proof-of-Concept"
                    ),
                ),
                cvssv2_0=None,
                cvssv3_x=None,
            ),
        ),
    )


@pytest.fixture
def vulnerability_with_all_cvss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with all CVSS versions."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-7890",
        attributes=VulnerabilityModelFactory.build(
            name="All CVSS Vulnerability",
            cvss=CvssFactory.build(
                cvssv2_0=CvssV2Factory.build(
                    base_score=6.8,
                    vector="AV:N/AC:M/Au:N/C:P/I:P/A:P",
                    temporal_score=5.5,
                ),
                cvssv3_x=CvssV3Factory.build(
                    base_score=7.5,
                    vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                ),
                cvssv4_x=CvssV4Factory.build(
                    score=8.2,
                    vector="CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:N/VA:N/SC:N/SI:N/SA:N",
                    threat=CvssV4ThreatFactory.build(exploit_maturity="Functional"),
                ),
            ),
        ),
    )


@pytest.fixture
def vulnerability_with_epss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with EPSS information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-1111",
        attributes=VulnerabilityModelFactory.build(
            name="EPSS Vulnerability",
            epss=EpssFactory.build(score=0.85, percentile=95.5),
        ),
    )


@pytest.fixture
def vulnerability_with_cwe() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with CWE information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-2222",
        attributes=VulnerabilityModelFactory.build(
            name="CWE Vulnerability",
            cwe=CweFactory.build(id="CWE-79", title="Cross-site Scripting"),
        ),
    )


@pytest.fixture
def vulnerability_with_tags() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with tags."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-3333",
        attributes=VulnerabilityModelFactory.build(
            name="Tagged Vulnerability",
            tags_details=[
                TagDetailFactory.build(value="remote-code-execution"),
                TagDetailFactory.build(value="privilege-escalation"),
                TagDetailFactory.build(value="critical-severity"),
            ],
        ),
    )


@pytest.fixture
def vulnerability_with_all_data() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with all information."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-9999",
        attributes=VulnerabilityModelFactory.build(
            name="Complete Vulnerability",
            description="Complete vulnerability with all data",
            cvss=CvssFactory.build(
                cvssv2_0=CvssV2Factory.build(
                    base_score=6.8,
                    vector="AV:N/AC:M/Au:N/C:P/I:P/A:P",
                    temporal_score=5.5,
                ),
                cvssv3_x=CvssV3Factory.build(
                    base_score=7.5,
                    vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
                ),
                cvssv4_x=CvssV4Factory.build(
                    score=8.2,
                    vector="CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:N/VA:N/SC:N/SI:N/SA:N",
                    threat=CvssV4ThreatFactory.build(exploit_maturity="High"),
                ),
            ),
            epss=EpssFactory.build(score=0.95, percentile=99.0),
            cwe=CweFactory.build(id="CWE-89", title="SQL Injection"),
            tags_details=[
                TagDetailFactory.build(value="sql-injection"),
                TagDetailFactory.build(value="web-application"),
                TagDetailFactory.build(value="database"),
            ],
        ),
    )


@pytest.fixture
def vulnerability_without_attributes() -> GTIVulnerabilityData:
    """Fixture for vulnerability data without attributes."""
    return GTIVulnerabilityDataFactory.build(attributes=None)


@pytest.fixture
def vulnerability_with_none_values() -> GTIVulnerabilityData:
    """Fixture for vulnerability with None values."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-0000",
        attributes=VulnerabilityModelFactory.build(
            name="None Values Vulnerability",
            description=None,
            cvss=None,
            epss=None,
            cwe=None,
            tags_details=None,
        ),
    )


@pytest.fixture
def vulnerability_with_invalid_timestamps() -> GTIVulnerabilityData:
    """Fixture for vulnerability with invalid timestamps."""
    return GTIVulnerabilityDataFactory.build(
        id="CVE-2023-8888",
        attributes=VulnerabilityModelFactory.build(
            name="Invalid Timestamps Vulnerability",
            creation_date=-1,
            last_modification_date=-1,
        ),
    )


# =====================
# Test Cases
# =====================


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_minimal_data(
    minimal_vulnerability_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with minimal data to STIX."""
    # Given a GTI vulnerability mapper with minimal data
    mapper = _given_gti_vulnerability_mapper(
        minimal_vulnerability_data, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should be created successfully
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        minimal_vulnerability_data,
        mock_organization,
        mock_tlp_marking,
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_cvss_v3(
    vulnerability_with_cvss_v3: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with CVSSv3 data to STIX."""
    # Given a GTI vulnerability mapper with CVSSv3 data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_cvss_v3, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have CVSSv3 data
    _then_stix_vulnerability_has_cvss_v3_data(
        stix_vulnerability, vulnerability_with_cvss_v3
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_cvss_v2(
    vulnerability_with_cvss_v2: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with CVSSv2 data to STIX."""
    # Given a GTI vulnerability mapper with CVSSv2 data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_cvss_v2, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have CVSSv2 data
    _then_stix_vulnerability_has_cvss_v2_data(
        stix_vulnerability, vulnerability_with_cvss_v2
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_cvss_v4(
    vulnerability_with_cvss_v4: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with CVSSv4 data to STIX."""
    # Given a GTI vulnerability mapper with CVSSv4 data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_cvss_v4, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have CVSSv4 data
    _then_stix_vulnerability_has_cvss_v4_data(
        stix_vulnerability, vulnerability_with_cvss_v4
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_all_cvss(
    vulnerability_with_all_cvss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with all CVSS versions to STIX."""
    # Given a GTI vulnerability mapper with all CVSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_all_cvss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have all CVSS data
    _then_stix_vulnerability_has_all_cvss_data(
        stix_vulnerability, vulnerability_with_all_cvss
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_epss(
    vulnerability_with_epss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with EPSS data to STIX."""
    # Given a GTI vulnerability mapper with EPSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_epss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have EPSS data
    _then_stix_vulnerability_has_epss_data(stix_vulnerability, vulnerability_with_epss)


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_cwe(
    vulnerability_with_cwe: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with CWE data to STIX."""
    # Given a GTI vulnerability mapper with CWE data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_cwe, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have CWE data
    _then_stix_vulnerability_has_cwe_data(stix_vulnerability, vulnerability_with_cwe)


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_tags(
    vulnerability_with_tags: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with tags to STIX."""
    # Given a GTI vulnerability mapper with tags
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_tags, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have labels from tags
    _then_stix_vulnerability_has_labels_from_tags(
        stix_vulnerability, vulnerability_with_tags
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_with_all_data(
    vulnerability_with_all_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with all data to STIX."""
    # Given a GTI vulnerability mapper with all data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_all_data, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should have all data
    _then_stix_vulnerability_has_all_data(
        stix_vulnerability, vulnerability_with_all_data
    )


@pytest.mark.order(1)
def test_gti_vulnerability_to_stix_without_attributes(
    vulnerability_without_attributes: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability without attributes raises error."""
    # Given a GTI vulnerability mapper without attributes
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_without_attributes, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    # Then it should raise a ValueError
    _when_convert_to_stix_raises_error(mapper, ValueError)


@pytest.mark.order(1)
def test_extract_labels_from_tags_details() -> None:
    """Test extracting labels from tags_details."""
    # Given vulnerability attributes with tags_details
    tags_details = [
        TagDetailFactory.build(value="tag1"),
        TagDetailFactory.build(value="tag2"),
        TagDetailFactory.build(value="tag3"),
    ]
    vuln_attributes = VulnerabilityModelFactory.build(tags_details=tags_details)
    # When extracting labels
    labels = _when_extract_labels(vuln_attributes)
    # Then labels should contain tag values
    _then_labels_contain_tag_values(labels, tags_details)


@pytest.mark.order(1)
def test_extract_labels_without_tags() -> None:
    """Test extracting labels without tags_details."""
    # Given vulnerability attributes without tags_details
    vuln_attributes = VulnerabilityModelFactory.build(tags_details=None)
    # When extracting labels
    labels = _when_extract_labels(vuln_attributes)
    # Then labels should be None
    _then_labels_are_none(labels)


@pytest.mark.order(1)
def test_create_external_references_with_all_data(
    vulnerability_with_all_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test creating external references with all data."""
    # Given a GTI vulnerability mapper with all data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_all_data, mock_organization, mock_tlp_marking
    )
    # When creating external references
    external_references = _when_create_external_references(
        mapper, vulnerability_with_all_data.attributes
    )
    # Then external references should contain all data
    _then_external_references_contain_all_data(
        external_references, vulnerability_with_all_data
    )


@pytest.mark.order(1)
def test_create_external_references_minimal_data(
    minimal_vulnerability_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test creating external references with minimal data."""
    # Given a GTI vulnerability mapper with minimal data
    mapper = _given_gti_vulnerability_mapper(
        minimal_vulnerability_data, mock_organization, mock_tlp_marking
    )
    # When creating external references
    external_references = _when_create_external_references(
        mapper, minimal_vulnerability_data.attributes
    )
    # Then external references should contain minimal data
    _then_external_references_contain_minimal_data(
        external_references, minimal_vulnerability_data
    )


@pytest.mark.order(1)
def test_gti_vulnerability_with_invalid_timestamps(
    vulnerability_with_invalid_timestamps: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with invalid timestamps."""
    # Given a GTI vulnerability mapper with invalid timestamps
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should handle invalid timestamps gracefully
    _then_stix_vulnerability_handles_invalid_timestamps(stix_vulnerability)


@pytest.mark.order(1)
def test_extract_cvss_data_comprehensive() -> None:
    """Test extracting comprehensive CVSS data."""
    # Given vulnerability attributes with all CVSS versions
    cvss_data = CvssFactory.build(
        cvssv2_0=CvssV2Factory.build(
            base_score=6.8, vector="AV:N/AC:M/Au:N/C:P/I:P/A:P", temporal_score=5.5
        ),
        cvssv3_x=CvssV3Factory.build(
            base_score=7.5, vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N"
        ),
        cvssv4_x=CvssV4Factory.build(
            score=8.2,
            vector="CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:N/VA:N/SC:N/SI:N/SA:N",
            threat=CvssV4ThreatFactory.build(exploit_maturity="Functional"),
        ),
    )
    vuln_attributes = VulnerabilityModelFactory.build(cvss=cvss_data)

    # When extracting CVSS data
    from uuid import uuid4

    mapper = GTIVulnerabilityToSTIXVulnerability(
        GTIVulnerabilityDataFactory.build(attributes=vuln_attributes),
        Identity(id=f"identity--{uuid4()}", name="Test", identity_class="organization"),
        MarkingDefinition(
            id=f"marking-definition--{uuid4()}",
            definition_type="statement",
            definition={"statement": "test"},
        ),
    )
    extracted_data = mapper._extract_cvss_data(vuln_attributes)

    # Then all CVSS data should be extracted
    _then_cvss_data_contains_all_versions(extracted_data, cvss_data)


# =====================
# Helper Functions
# =====================


def _given_gti_vulnerability_mapper(
    vulnerability: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> GTIVulnerabilityToSTIXVulnerability:
    """Create a GTI vulnerability to STIX vulnerability mapper."""
    return GTIVulnerabilityToSTIXVulnerability(vulnerability, organization, tlp_marking)


def _when_convert_to_stix(mapper: GTIVulnerabilityToSTIXVulnerability) -> Any:
    """Convert the GTI vulnerability to STIX."""
    return mapper.to_stix()


def _when_convert_to_stix_raises_error(
    mapper: GTIVulnerabilityToSTIXVulnerability, expected_error: type
) -> None:
    """Convert the GTI vulnerability to STIX and expect an error."""
    with pytest.raises(expected_error):
        mapper.to_stix()


def _when_extract_labels(attributes: VulnerabilityModel) -> list[str] | None:
    """Extract labels from vulnerability attributes."""
    return GTIVulnerabilityToSTIXVulnerability._extract_labels(attributes)


def _when_create_external_references(
    mapper: GTIVulnerabilityToSTIXVulnerability, attributes: VulnerabilityModel
) -> list[dict[str, str]] | None:
    """Create external references from vulnerability attributes."""
    return mapper._create_external_references(attributes)


def _then_stix_vulnerability_created_successfully(
    stix_vulnerability: Any,
    vulnerability_data: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> None:
    """Assert that STIX vulnerability was created successfully."""  # noqa: S101
    assert stix_vulnerability is not None  # noqa: S101
    assert stix_vulnerability.name == vulnerability_data.attributes.name  # noqa: S101
    assert (  # noqa: S101
        stix_vulnerability.description == vulnerability_data.attributes.description
    )
    assert stix_vulnerability.created_by_ref == organization.id  # noqa: S101
    assert tlp_marking.id in stix_vulnerability.object_marking_refs  # noqa: S101
    assert stix_vulnerability.type == "vulnerability"  # noqa: S101


def _then_stix_vulnerability_has_cvss_v3_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has CVSSv3 data."""  # noqa: S101
    cvss_v3 = vulnerability_data.attributes.cvss.cvssv3_x

    if hasattr(stix_vulnerability, "x_opencti_base_score"):
        assert (  # noqa: S101
            stix_vulnerability.x_opencti_base_score == cvss_v3.base_score
        )
    else:
        custom_props = getattr(stix_vulnerability, "custom_properties", {})
        assert (  # noqa: S101
            custom_props.get("x_opencti_base_score") == cvss_v3.base_score
        )

    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    assert (  # noqa: S101
        custom_props.get("x_opencti_cvss_vector_string") == cvss_v3.vector
    )


def _then_stix_vulnerability_has_cvss_v2_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has CVSSv2 data."""  # noqa: S101
    cvss_v2 = vulnerability_data.attributes.cvss.cvssv2_0
    custom_props = getattr(stix_vulnerability, "custom_properties", {})

    assert (  # noqa: S101
        custom_props.get("x_opencti_cvss_v2_base_score") == cvss_v2.base_score
    )

    assert (  # noqa: S101
        custom_props.get("x_opencti_cvss_v2_vector_string") == cvss_v2.vector
    )

    if cvss_v2.temporal_score is not None:
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v2_temporal_score")
            == cvss_v2.temporal_score
        )


def _then_stix_vulnerability_has_cvss_v4_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has CVSSv4 data."""  # noqa: S101
    cvss_v4 = vulnerability_data.attributes.cvss.cvssv4_x
    custom_props = getattr(stix_vulnerability, "custom_properties", {})

    assert (  # noqa: S101
        custom_props.get("x_opencti_cvss_v4_base_score") == cvss_v4.score
    )

    assert (  # noqa: S101
        custom_props.get("x_opencti_cvss_v4_vector_string") == cvss_v4.vector
    )

    if cvss_v4.threat and cvss_v4.threat.exploit_maturity:
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v4_exploit_maturity")
            == cvss_v4.threat.exploit_maturity
        )


def _then_stix_vulnerability_has_all_cvss_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has all CVSS version data."""  # noqa: S101
    cvss = vulnerability_data.attributes.cvss
    custom_props = getattr(stix_vulnerability, "custom_properties", {})

    if cvss.cvssv2_0:
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v2_base_score") == cvss.cvssv2_0.base_score
        )
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v2_vector_string") == cvss.cvssv2_0.vector
        )
        if cvss.cvssv2_0.temporal_score is not None:
            assert (  # noqa: S101
                custom_props.get("x_opencti_cvss_v2_temporal_score")
                == cvss.cvssv2_0.temporal_score
            )

    if cvss.cvssv3_x:
        if hasattr(stix_vulnerability, "x_opencti_base_score"):
            assert (  # noqa: S101
                stix_vulnerability.x_opencti_base_score == cvss.cvssv3_x.base_score
            )
        else:
            assert (  # noqa: S101
                custom_props.get("x_opencti_base_score") == cvss.cvssv3_x.base_score
            )
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_vector_string") == cvss.cvssv3_x.vector
        )

    if cvss.cvssv4_x:
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v4_base_score") == cvss.cvssv4_x.score
        )
        assert (  # noqa: S101
            custom_props.get("x_opencti_cvss_v4_vector_string") == cvss.cvssv4_x.vector
        )
        if cvss.cvssv4_x.threat and cvss.cvssv4_x.threat.exploit_maturity:
            assert (  # noqa: S101
                custom_props.get("x_opencti_cvss_v4_exploit_maturity")
                == cvss.cvssv4_x.threat.exploit_maturity
            )


def _then_stix_vulnerability_has_epss_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has EPSS data."""  # noqa: S101
    epss = vulnerability_data.attributes.epss

    if epss.score is not None:
        if hasattr(stix_vulnerability, "x_opencti_epss_score"):
            assert stix_vulnerability.x_opencti_epss_score == epss.score  # noqa: S101
        else:
            custom_props = getattr(stix_vulnerability, "custom_properties", {})
            assert custom_props.get("x_opencti_epss_score") == epss.score  # noqa: S101

    if epss.percentile is not None:
        if hasattr(stix_vulnerability, "x_opencti_epss_percentile"):
            assert (  # noqa: S101
                stix_vulnerability.x_opencti_epss_percentile == epss.percentile
            )
        else:
            custom_props = getattr(stix_vulnerability, "custom_properties", {})
            assert (  # noqa: S101
                custom_props.get("x_opencti_epss_percentile") == epss.percentile
            )


def _then_stix_vulnerability_has_cwe_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has CWE data."""  # noqa: S101
    cwe = vulnerability_data.attributes.cwe
    custom_props = getattr(stix_vulnerability, "custom_properties", {})

    assert custom_props.get("x_opencti_cwe") == cwe.id  # noqa: S101


def _then_stix_vulnerability_has_labels_from_tags(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has labels from tags_details."""  # noqa: S101
    tags_details = vulnerability_data.attributes.tags_details

    assert stix_vulnerability.labels is not None  # noqa: S101
    expected_labels = [tag.value for tag in tags_details if tag.value]

    for expected_label in expected_labels:
        assert expected_label in stix_vulnerability.labels  # noqa: S101


def _then_stix_vulnerability_has_all_data(
    stix_vulnerability: Any, vulnerability_data: GTIVulnerabilityData
) -> None:
    """Assert that STIX vulnerability has all data types."""  # noqa: S101
    attributes = vulnerability_data.attributes

    assert stix_vulnerability.name == attributes.name  # noqa: S101
    assert stix_vulnerability.description == attributes.description  # noqa: S101

    if attributes.cvss:
        _then_stix_vulnerability_has_all_cvss_data(
            stix_vulnerability, vulnerability_data
        )

    if attributes.epss:
        _then_stix_vulnerability_has_epss_data(stix_vulnerability, vulnerability_data)

    if attributes.cwe:
        _then_stix_vulnerability_has_cwe_data(stix_vulnerability, vulnerability_data)

    if attributes.tags_details:
        _then_stix_vulnerability_has_labels_from_tags(
            stix_vulnerability, vulnerability_data
        )

    assert stix_vulnerability.external_references is not None  # noqa: S101
    assert len(stix_vulnerability.external_references) >= 1  # noqa: S101  # noqa: S101


def _then_labels_contain_tag_values(
    labels: list[str] | None, tags_details: list[TagDetail]
) -> None:
    """Assert that labels contain tag values."""  # noqa: S101
    expected_labels = [tag.value for tag in tags_details if tag.value]

    if expected_labels:
        assert labels is not None  # noqa: S101
        for expected_label in expected_labels:
            assert expected_label in labels  # noqa: S101
    else:
        assert labels is None or len(labels) == 0  # noqa: S101


def _then_labels_are_none(labels: list[str] | None) -> None:
    """Assert that labels are None."""  # noqa: S101
    assert labels is None  # noqa: S101


def _then_external_references_contain_all_data(
    external_references: list[dict[str, str]] | None,
    vulnerability_data: GTIVulnerabilityData,
) -> None:
    """Assert that external references contain all expected data."""  # noqa: S101
    assert external_references is not None  # noqa: S101
    assert len(external_references) >= 1  # noqa: S101

    gti_refs = [
        ref
        for ref in external_references
        if "[GTI] Vulnerability" in ref.get("source_name", "")
    ]
    assert len(gti_refs) == 1  # noqa: S101
    assert "virustotal.com" in gti_refs[0]["url"]  # noqa: S101
    assert vulnerability_data.id in gti_refs[0]["url"]  # noqa: S101


def _then_external_references_contain_minimal_data(
    external_references: list[dict[str, str]] | None,
    vulnerability_data: GTIVulnerabilityData,
) -> None:
    """Assert that external references contain minimal expected data."""  # noqa: S101
    assert external_references is not None  # noqa: S101
    assert len(external_references) >= 1  # noqa: S101

    gti_refs = [
        ref
        for ref in external_references
        if "[GTI] Vulnerability" in ref.get("source_name", "")
    ]
    assert len(gti_refs) == 1  # noqa: S101


def _then_stix_vulnerability_handles_invalid_timestamps(
    stix_vulnerability: Any,
) -> None:
    """Assert that STIX vulnerability handles invalid timestamps gracefully."""  # noqa: S101
    assert stix_vulnerability is not None  # noqa: S101
    assert isinstance(stix_vulnerability.created, datetime)  # noqa: S101
    assert isinstance(stix_vulnerability.modified, datetime)  # noqa: S101


def _then_cvss_data_contains_all_versions(
    extracted_data: dict[str, Any], original_cvss: Cvss
) -> None:
    """Assert that extracted CVSS data contains all versions."""  # noqa: S101
    if original_cvss.cvssv2_0:
        assert "cvssv2_0_base_score" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv2_0_base_score"] == original_cvss.cvssv2_0.base_score
        )
        assert "cvssv2_0_vector" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv2_0_vector"] == original_cvss.cvssv2_0.vector
        )
        if original_cvss.cvssv2_0.temporal_score is not None:
            assert "cvssv2_0_temporal_score" in extracted_data  # noqa: S101
            assert (  # noqa: S101
                extracted_data["cvssv2_0_temporal_score"]
                == original_cvss.cvssv2_0.temporal_score
            )

    if original_cvss.cvssv3_x:
        assert "cvssv3_x_base_score" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv3_x_base_score"] == original_cvss.cvssv3_x.base_score
        )
        assert "cvssv3_x_vector" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv3_x_vector"] == original_cvss.cvssv3_x.vector
        )

    if original_cvss.cvssv4_x:
        assert "cvssv4_x_score" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv4_x_score"] == original_cvss.cvssv4_x.score
        )
        assert "cvssv4_x_vector" in extracted_data  # noqa: S101
        assert (  # noqa: S101
            extracted_data["cvssv4_x_vector"] == original_cvss.cvssv4_x.vector
        )
        if (
            original_cvss.cvssv4_x.threat
            and original_cvss.cvssv4_x.threat.exploit_maturity
        ):
            assert "cvssv4_x_exploit_maturity" in extracted_data  # noqa: S101
            assert (  # noqa: S101
                extracted_data["cvssv4_x_exploit_maturity"]
                == original_cvss.cvssv4_x.threat.exploit_maturity
            )
