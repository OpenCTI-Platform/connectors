"""Module to test the GTI vulnerability to STIX vulnerability mapper."""

from datetime import datetime
from typing import Any, Dict, List, Optional
from uuid import uuid4

import pytest
from connector.src.custom.mappers.gti_reports.gti_vulnerability_to_stix_vulnerability import (
    GTIVulnerabilityToSTIXVulnerability,
)
from connector.src.custom.models.gti_reports.gti_vulnerability_model import (
    Cvss,
    CvssV3,
    Epss,
    GTIVulnerabilityData,
    VulnerabilityModel,
)
from polyfactory import Use
from polyfactory.factories.pydantic_factory import ModelFactory
from stix2.v21 import Identity, MarkingDefinition  # type: ignore

# =====================
# Polyfactory Factories
# =====================


class CvssV3Factory(ModelFactory[CvssV3]):
    """Factory for CvssV3 model."""

    __model__ = CvssV3


class CvssFactory(ModelFactory[Cvss]):
    """Factory for Cvss model."""

    __model__ = Cvss

    cvssv3 = Use(CvssV3Factory.build)


class EpssFactory(ModelFactory[Epss]):
    """Factory for Epss model."""

    __model__ = Epss


class VulnerabilityModelFactory(ModelFactory[VulnerabilityModel]):
    """Factory for VulnerabilityModel."""

    __model__ = VulnerabilityModel


class GTIVulnerabilityDataFactory(ModelFactory[GTIVulnerabilityData]):
    """Factory for GTIVulnerabilityData."""

    __model__ = GTIVulnerabilityData

    type = "vulnerability"
    attributes = Use(VulnerabilityModelFactory.build)


# =====================
# Fixtures
# =====================


@pytest.fixture
def mock_organization() -> Identity:
    """Fixture for mock organization identity."""
    return Identity(
        id=f"identity--{uuid4()}",
        name="Test Organization",
        identity_class="organization",
    )


@pytest.fixture
def mock_tlp_marking() -> MarkingDefinition:
    """Fixture for mock TLP marking definition."""
    return MarkingDefinition(
        id=f"marking-definition--{uuid4()}",
        definition_type="statement",
        definition={"statement": "Internal Use Only"},
    )


@pytest.fixture
def minimal_vulnerability_data() -> GTIVulnerabilityData:
    """Fixture for minimal vulnerability data."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=None,
            epss=None,
            link=None,
        )
    )


@pytest.fixture
def vulnerability_with_cvss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with CVSS."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(),
            epss=None,
        )
    )


@pytest.fixture
def vulnerability_with_epss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with EPSS."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=None,
            epss=EpssFactory.build(),
        )
    )


@pytest.fixture
def vulnerability_with_all_data() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with all optional fields."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(),
            epss=EpssFactory.build(),
        )
    )


@pytest.fixture
def vulnerability_without_attributes() -> GTIVulnerabilityData:
    """Fixture for vulnerability data without attributes."""
    return GTIVulnerabilityDataFactory.build(attributes=None)


@pytest.fixture
def empty_vulnerability_attributes() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with empty attributes."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            name="",
            description=None,
            cvss=None,
            epss=None,
            link=None,
        ),
    )


@pytest.fixture
def cvss_data() -> CvssV3:
    """Fixture for CVSS v3 data."""
    return CvssV3Factory.build()


@pytest.fixture
def epss_data() -> Epss:
    """Fixture for EPSS data."""
    return EpssFactory.build()


@pytest.fixture
def vulnerability_with_none_values() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with None values."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            name="",
            description=None,
            cvss=None,
            epss=None,
            link=None,
        )
    )


@pytest.fixture
def vulnerability_with_invalid_timestamps() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with invalid timestamps."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            creation_date=-1,
            last_modification_date=0,
        )
    )


@pytest.fixture
def vulnerability_with_invalid_cvss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with invalid CVSS scores."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(
                cvssv3=CvssV3Factory.build(
                    base_score=-1.0,
                    attack_vector="INVALID_VECTOR",
                    vector_string="",
                )
            )
        )
    )


@pytest.fixture
def vulnerability_with_invalid_epss() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with invalid EPSS scores."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            epss=EpssFactory.build(
                score=1.5,
                percentile=-0.1,
            )
        )
    )


@pytest.fixture
def vulnerability_with_malformed_url() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with malformed URL."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            link="not-a-valid-url",
        )
    )


@pytest.fixture
def vulnerability_with_long_strings() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with very long strings."""
    long_string = "A" * 10000
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            name=long_string,
            description=long_string,
        )
    )


@pytest.fixture
def vulnerability_with_unicode_characters() -> GTIVulnerabilityData:
    """Fixture for vulnerability data with unicode characters."""
    return GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            name="ðŸ”¥ Unicode Vulnerability æµ‹è¯•",
            description="Vulnerability with Ã©mojis and spÃ©cial charactÃ©rs: Î±Î²Î³Î´Îµ",
            link="https://example.com/vuln/æµ‹è¯•?param=value&emoji=ðŸ”¥",
        )
    )


# =====================
# Test Cases
# =====================


# Scenario: Create STIX vulnerability with minimal required data
def test_gti_vulnerability_to_stix_minimal_data(
    minimal_vulnerability_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with minimal data to STIX."""
    # Given a GTI vulnerability with minimal data
    mapper = _given_gti_vulnerability_mapper(
        minimal_vulnerability_data, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should be created with basic fields
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        minimal_vulnerability_data,
        mock_organization,
        mock_tlp_marking,
    )


# Scenario: Create STIX vulnerability with CVSS data
def test_gti_vulnerability_to_stix_with_cvss(
    vulnerability_with_cvss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with CVSS data to STIX."""
    # Given a GTI vulnerability with CVSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_cvss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should include CVSS data and labels
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        vulnerability_with_cvss,
        mock_organization,
        mock_tlp_marking,
    )
    _then_stix_vulnerability_has_cvss_data(stix_vulnerability, vulnerability_with_cvss)


# Scenario: Create STIX vulnerability with EPSS data
def test_gti_vulnerability_to_stix_with_epss(
    vulnerability_with_epss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with EPSS data to STIX."""
    # Given a GTI vulnerability with EPSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_epss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should include EPSS data
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        vulnerability_with_epss,
        mock_organization,
        mock_tlp_marking,
    )
    _then_stix_vulnerability_has_epss_data(stix_vulnerability, vulnerability_with_epss)


# Scenario: Create STIX vulnerability with all optional data
def test_gti_vulnerability_to_stix_with_all_data(
    vulnerability_with_all_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test converting GTI vulnerability with all optional data to STIX."""
    # Given a GTI vulnerability with all optional data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_all_data, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should include all data
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        vulnerability_with_all_data,
        mock_organization,
        mock_tlp_marking,
    )
    _then_stix_vulnerability_has_cvss_data(
        stix_vulnerability, vulnerability_with_all_data
    )
    _then_stix_vulnerability_has_epss_data(
        stix_vulnerability, vulnerability_with_all_data
    )
    _then_stix_vulnerability_has_external_references(
        stix_vulnerability, vulnerability_with_all_data
    )


# Scenario: Handle vulnerability without attributes
def test_gti_vulnerability_to_stix_without_attributes(
    vulnerability_without_attributes: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling GTI vulnerability without attributes."""
    # Given a GTI vulnerability without attributes
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_without_attributes, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    # Then should raise ValueError
    _when_convert_to_stix_raises_error(
        mapper, ValueError, "Vulnerability attributes are missing"
    )


# Scenario: Handle vulnerability with empty attributes
def test_gti_vulnerability_to_stix_empty_attributes(
    empty_vulnerability_attributes: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling GTI vulnerability with empty attributes."""
    # Given a GTI vulnerability with empty attributes
    mapper = _given_gti_vulnerability_mapper(
        empty_vulnerability_attributes, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then STIX vulnerability should be created with empty/default values
    _then_stix_vulnerability_created_successfully(
        stix_vulnerability,
        empty_vulnerability_attributes,
        mock_organization,
        mock_tlp_marking,
    )


# Scenario: Test label extraction from CVSS data
def test_extract_labels_from_cvss_data(cvss_data: CvssV3) -> None:
    """Test extracting labels from CVSS data."""
    # Given vulnerability attributes with CVSS data
    vuln_attributes = VulnerabilityModelFactory.build(
        cvss=CvssFactory.build(cvssv3=cvss_data)
    )
    # When extracting labels
    labels = _when_extract_labels(vuln_attributes)
    # Then labels should contain CVSS attributes
    _then_labels_contain_cvss_attributes(labels, cvss_data)


# Scenario: Test label extraction without CVSS data
def test_extract_labels_without_cvss_data() -> None:
    """Test extracting labels without CVSS data."""
    # Given vulnerability attributes without CVSS data
    vuln_attributes = VulnerabilityModelFactory.build(cvss=None)
    # When extracting labels
    labels = _when_extract_labels(vuln_attributes)
    # Then labels should be None
    _then_labels_are_none(labels)


# Scenario: Test external references creation
def test_create_external_references_with_all_data(
    vulnerability_with_all_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test creating external references with all data."""
    # Given a GTI vulnerability with all data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_all_data, mock_organization, mock_tlp_marking
    )
    # When creating external references
    external_refs = _when_create_external_references(
        mapper, vulnerability_with_all_data.attributes
    )
    # Then external references should contain all expected references
    _then_external_references_contain_all_data(
        external_refs, vulnerability_with_all_data
    )


# Scenario: Test external references creation with minimal data
def test_create_external_references_minimal_data(
    minimal_vulnerability_data: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test creating external references with minimal data."""
    # Given a GTI vulnerability with minimal data
    mapper = _given_gti_vulnerability_mapper(
        minimal_vulnerability_data, mock_organization, mock_tlp_marking
    )
    # When creating external references
    external_refs = _when_create_external_references(
        mapper, minimal_vulnerability_data.attributes
    )
    # Then external references should contain only NVD reference
    _then_external_references_contain_nvd_only(
        external_refs, minimal_vulnerability_data
    )


# Scenario: Test CVSS variations
@pytest.mark.parametrize(
    "attack_vector,attack_complexity,privileges_required,user_interaction",
    [
        ("NETWORK", "LOW", "NONE", "NONE"),
        ("ADJACENT_NETWORK", "HIGH", "LOW", "REQUIRED"),
        ("LOCAL", "LOW", "HIGH", "NONE"),
        ("PHYSICAL", "HIGH", "NONE", "REQUIRED"),
    ],
)
def test_cvss_variations(
    attack_vector: str,
    attack_complexity: str,
    privileges_required: str,
    user_interaction: str,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test various CVSS parameter combinations."""
    # Given a vulnerability with specific CVSS parameters
    cvss_data = CvssV3Factory.build(
        attack_vector=attack_vector,
        attack_complexity=attack_complexity,
        privileges_required=privileges_required,
        user_interaction=user_interaction,
    )
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(cvssv3=cvss_data)
        )
    )

    # When converting to STIX
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    stix_vulnerability = _when_convert_to_stix(mapper)

    # Then labels should reflect the CVSS parameters
    expected_labels = [
        f"attack-vector:{attack_vector}",
        f"attack-complexity:{attack_complexity}",
        f"privileges-required:{privileges_required}",
        f"user-interaction:{user_interaction}",
    ]
    for label in expected_labels:
        assert label in stix_vulnerability.labels  # noqa: S101


# Scenario: Test EPSS score variations
@pytest.mark.parametrize(
    "score,percentile",
    [
        (0.1, 0.25),
        (0.5, 0.75),
        (0.9, 0.95),
        (0.99, 0.99),
    ],
)
def test_epss_variations(
    score: float,
    percentile: float,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test various EPSS score and percentile combinations."""
    # Given a vulnerability with specific EPSS data
    epss_data = EpssFactory.build(score=score, percentile=percentile)
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(epss=epss_data)
    )

    # When converting to STIX
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    stix_vulnerability = _when_convert_to_stix(mapper)

    # Then EPSS data should be preserved
    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    assert custom_props.get("x_opencti_epss_score") == score  # noqa: S101
    assert custom_props.get("x_opencti_epss_percentile") == percentile  # noqa: S101


# =====================
# Edge Cases and Error Scenarios
# =====================


# Scenario: Handle None vulnerability object
def test_gti_vulnerability_none_object(
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling None vulnerability object."""
    # Given a None vulnerability object
    # When creating mapper with None vulnerability
    mapper = GTIVulnerabilityToSTIXVulnerability(
        None, mock_organization, mock_tlp_marking
    )
    # Then should raise ValueError when converting to STIX
    with pytest.raises(ValueError, match="Vulnerability attributes are missing"):
        mapper.to_stix()


# Scenario: Handle vulnerability with None values in critical fields
def test_gti_vulnerability_with_none_values(
    vulnerability_with_none_values: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with None values."""
    # Given a vulnerability with None values
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_none_values, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle None values gracefully
    _then_stix_vulnerability_handles_none_values(
        stix_vulnerability, vulnerability_with_none_values
    )


# Scenario: Handle vulnerability with invalid timestamps
def test_gti_vulnerability_invalid_timestamps(
    vulnerability_with_invalid_timestamps: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with invalid timestamps."""
    # Given a vulnerability with invalid timestamps
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_invalid_timestamps, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    # Then should either handle gracefully or raise appropriate error
    try:
        stix_vulnerability = _when_convert_to_stix(mapper)
        _then_stix_vulnerability_handles_invalid_timestamps(stix_vulnerability)
    except (ValueError, OSError):
        # Some systems may raise errors for invalid timestamps
        pass


# Scenario: Handle vulnerability with invalid CVSS data
def test_gti_vulnerability_invalid_cvss(
    vulnerability_with_invalid_cvss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with invalid CVSS data."""
    # Given a vulnerability with invalid CVSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_invalid_cvss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle invalid CVSS data gracefully
    _then_stix_vulnerability_handles_invalid_cvss(
        stix_vulnerability, vulnerability_with_invalid_cvss
    )


# Scenario: Handle vulnerability with invalid EPSS data
def test_gti_vulnerability_invalid_epss(
    vulnerability_with_invalid_epss: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with invalid EPSS data."""
    # Given a vulnerability with invalid EPSS data
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_invalid_epss, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle invalid EPSS data gracefully
    _then_stix_vulnerability_handles_invalid_epss(
        stix_vulnerability, vulnerability_with_invalid_epss
    )


# Scenario: Handle vulnerability with malformed URL
def test_gti_vulnerability_malformed_url(
    vulnerability_with_malformed_url: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with malformed URL."""
    # Given a vulnerability with malformed URL
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_malformed_url, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should include the malformed URL as-is
    _then_stix_vulnerability_includes_malformed_url(
        stix_vulnerability, vulnerability_with_malformed_url
    )


# Scenario: Handle vulnerability with very long strings
def test_gti_vulnerability_long_strings(
    vulnerability_with_long_strings: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with very long strings."""
    # Given a vulnerability with very long strings
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_long_strings, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle long strings without truncation
    _then_stix_vulnerability_preserves_long_strings(
        stix_vulnerability, vulnerability_with_long_strings
    )


# Scenario: Handle vulnerability with unicode characters
def test_gti_vulnerability_unicode_characters(
    vulnerability_with_unicode_characters: GTIVulnerabilityData,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with unicode characters."""
    # Given a vulnerability with unicode characters
    mapper = _given_gti_vulnerability_mapper(
        vulnerability_with_unicode_characters, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should preserve unicode characters
    _then_stix_vulnerability_preserves_unicode(
        stix_vulnerability, vulnerability_with_unicode_characters
    )


# Scenario: Handle empty CVE ID
def test_gti_vulnerability_empty_cve_id(
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with empty CVE ID."""
    # Given a vulnerability with empty CVE ID
    vulnerability = GTIVulnerabilityDataFactory.build(id="")
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle empty CVE ID gracefully
    _then_stix_vulnerability_handles_empty_cve_id(stix_vulnerability)


# Scenario: Handle partial CVSS data
def test_gti_vulnerability_partial_cvss_data(
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with partial CVSS data."""
    # Given a vulnerability with partial CVSS data
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(
                cvssv3=CvssV3Factory.build(
                    base_score=7.5,
                    attack_vector="NETWORK",
                    attack_complexity=None,
                    privileges_required=None,
                    user_interaction=None,
                    vector_string=None,
                )
            )
        )
    )
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle partial CVSS data
    _then_stix_vulnerability_handles_partial_cvss(stix_vulnerability, vulnerability)


# Scenario: Handle CVSS without cvssv3
def test_gti_vulnerability_cvss_without_v3(
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with CVSS but no cvssv3 data."""
    # Given a vulnerability with CVSS but no cvssv3
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(cvss=CvssFactory.build(cvssv3=None))
    )
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should handle missing cvssv3 gracefully
    _then_stix_vulnerability_handles_missing_cvssv3(stix_vulnerability)


# Scenario: Test boundary CVSS scores
@pytest.mark.parametrize(
    "base_score",
    [0.0, 10.0, 0.1, 9.9],
)
def test_gti_vulnerability_boundary_cvss_scores(
    base_score: float,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with boundary CVSS scores."""
    # Given a vulnerability with boundary CVSS score
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            cvss=CvssFactory.build(cvssv3=CvssV3Factory.build(base_score=base_score))
        )
    )
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should preserve boundary CVSS scores
    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    assert custom_props.get("x_opencti_base_score") == base_score  # noqa: S101


# Scenario: Test boundary EPSS scores
@pytest.mark.parametrize(
    "score,percentile",
    [(0.0, 0.0), (1.0, 1.0), (0.000001, 0.000001), (0.999999, 0.999999)],
)
def test_gti_vulnerability_boundary_epss_scores(
    score: float,
    percentile: float,
    mock_organization: Identity,
    mock_tlp_marking: MarkingDefinition,
) -> None:
    """Test handling vulnerability with boundary EPSS scores."""
    # Given a vulnerability with boundary EPSS scores
    vulnerability = GTIVulnerabilityDataFactory.build(
        attributes=VulnerabilityModelFactory.build(
            epss=EpssFactory.build(score=score, percentile=percentile)
        )
    )
    mapper = _given_gti_vulnerability_mapper(
        vulnerability, mock_organization, mock_tlp_marking
    )
    # When converting to STIX
    stix_vulnerability = _when_convert_to_stix(mapper)
    # Then should preserve boundary EPSS scores
    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    assert custom_props.get("x_opencti_epss_score") == score  # noqa: S101
    assert custom_props.get("x_opencti_epss_percentile") == percentile  # noqa: S101


# =====================
# GWT Gherkin-style functions
# =====================


# Given setup GTI vulnerability mapper
def _given_gti_vulnerability_mapper(
    vulnerability: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> GTIVulnerabilityToSTIXVulnerability:
    """Set up the GTI vulnerability mapper."""
    return GTIVulnerabilityToSTIXVulnerability(vulnerability, organization, tlp_marking)


# When convert to STIX
def _when_convert_to_stix(mapper: GTIVulnerabilityToSTIXVulnerability) -> Any:
    """Convert GTI vulnerability to STIX."""
    return mapper.to_stix()


# When convert to STIX raises error
def _when_convert_to_stix_raises_error(
    mapper: GTIVulnerabilityToSTIXVulnerability,
    expected_exception: type,
    expected_message: str,
) -> None:
    """Test that conversion raises expected error."""
    with pytest.raises(expected_exception, match=expected_message):
        mapper.to_stix()


# When extract labels
def _when_extract_labels(attributes: VulnerabilityModel) -> Optional[List[str]]:
    """Extract labels from vulnerability attributes."""
    return GTIVulnerabilityToSTIXVulnerability._extract_labels(attributes)


# When create external references
def _when_create_external_references(
    mapper: GTIVulnerabilityToSTIXVulnerability, attributes: VulnerabilityModel
) -> Optional[List[Dict[str, str]]]:
    """Create external references from vulnerability attributes."""
    return mapper._create_external_references(attributes)


# Then STIX vulnerability created successfully
def _then_stix_vulnerability_created_successfully(
    stix_vulnerability: Any,
    gti_vulnerability: GTIVulnerabilityData,
    organization: Identity,
    tlp_marking: MarkingDefinition,
) -> None:
    """Check if STIX vulnerability was created successfully."""
    assert stix_vulnerability is not None  # noqa: S101
    assert stix_vulnerability.type == "vulnerability"  # noqa: S101
    assert stix_vulnerability.name == gti_vulnerability.attributes.name  # noqa: S101
    assert (  # noqa: S101
        stix_vulnerability.description == gti_vulnerability.attributes.description
    )
    assert stix_vulnerability.created_by_ref == organization.id  # noqa: S101
    assert tlp_marking.id in stix_vulnerability.object_marking_refs  # noqa: S101

    expected_created = datetime.fromtimestamp(
        gti_vulnerability.attributes.creation_date
    )
    expected_modified = datetime.fromtimestamp(
        gti_vulnerability.attributes.last_modification_date
    )
    assert stix_vulnerability.created == expected_created  # noqa: S101
    assert stix_vulnerability.modified == expected_modified  # noqa: S101


# Then STIX vulnerability has CVSS data
def _then_stix_vulnerability_has_cvss_data(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability has CVSS data."""
    cvss = gti_vulnerability.attributes.cvss.cvssv3

    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    if cvss.base_score is not None:
        assert "x_opencti_base_score" in custom_props  # noqa: S101
        assert custom_props["x_opencti_base_score"] == cvss.base_score  # noqa: S101

    if stix_vulnerability.labels:
        if cvss.attack_vector:
            assert (  # noqa: S101
                f"attack-vector:{cvss.attack_vector}" in stix_vulnerability.labels
            )
        if cvss.attack_complexity:
            assert (  # noqa: S101
                f"attack-complexity:{cvss.attack_complexity}"
                in stix_vulnerability.labels
            )
        if cvss.privileges_required:
            assert (  # noqa: S101
                f"privileges-required:{cvss.privileges_required}"
                in stix_vulnerability.labels
            )
        if cvss.user_interaction:
            assert (  # noqa: S101
                f"user-interaction:{cvss.user_interaction}" in stix_vulnerability.labels
            )


# Then STIX vulnerability has EPSS data
def _then_stix_vulnerability_has_epss_data(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability has EPSS data."""
    epss = gti_vulnerability.attributes.epss

    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    if epss.score is not None:
        assert "x_opencti_epss_score" in custom_props  # noqa: S101
        assert custom_props["x_opencti_epss_score"] == epss.score  # noqa: S101
    if epss.percentile is not None:
        assert "x_opencti_epss_percentile" in custom_props  # noqa: S101
        assert (  # noqa: S101
            custom_props["x_opencti_epss_percentile"] == epss.percentile
        )


# Then STIX vulnerability has external references
def _then_stix_vulnerability_has_external_references(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability has external references."""
    assert stix_vulnerability.external_references is not None  # noqa: S101

    nvd_refs = [
        ref
        for ref in stix_vulnerability.external_references
        if ref.source_name == "nvd"
    ]
    assert len(nvd_refs) == 1  # noqa: S101
    assert nvd_refs[0].external_id == gti_vulnerability.id  # noqa: S101
    assert (  # noqa: S101
        nvd_refs[0].url == f"https://nvd.nist.gov/vuln/detail/{gti_vulnerability.id}"
    )

    if gti_vulnerability.attributes.link:
        url_refs = [
            ref
            for ref in stix_vulnerability.external_references
            if ref.source_name == "url"
        ]
        assert len(url_refs) == 1  # noqa: S101
        assert url_refs[0].url == gti_vulnerability.attributes.link  # noqa: S101

    if (
        gti_vulnerability.attributes.cvss
        and gti_vulnerability.attributes.cvss.cvssv3
        and gti_vulnerability.attributes.cvss.cvssv3.vector_string
    ):
        cvss_refs = [
            ref
            for ref in stix_vulnerability.external_references
            if ref.source_name == "cvss-v3"
        ]
        assert len(cvss_refs) == 1  # noqa: S101
        assert (  # noqa: S101
            cvss_refs[0].description
            == gti_vulnerability.attributes.cvss.cvssv3.vector_string
        )


# Then labels contain CVSS attributes
def _then_labels_contain_cvss_attributes(
    labels: Optional[List[str]], cvss: CvssV3
) -> None:
    """Check if labels contain CVSS attributes."""
    expected_labels = []
    if cvss.attack_vector:
        expected_labels.append(f"attack-vector:{cvss.attack_vector}")
    if cvss.attack_complexity:
        expected_labels.append(f"attack-complexity:{cvss.attack_complexity}")
    if cvss.privileges_required:
        expected_labels.append(f"privileges-required:{cvss.privileges_required}")
    if cvss.user_interaction:
        expected_labels.append(f"user-interaction:{cvss.user_interaction}")

    if expected_labels:
        assert labels is not None  # noqa: S101
        for expected_label in expected_labels:
            assert expected_label in labels  # noqa: S101
    else:
        assert labels is None or len(labels) == 0  # noqa: S101


# Then labels are None
def _then_labels_are_none(labels: Optional[List[str]]) -> None:
    """Check if labels are None."""
    assert labels is None  # noqa: S101


# Then external references contain all data
def _then_external_references_contain_all_data(
    external_refs: Optional[List[Dict[str, str]]],
    gti_vulnerability: GTIVulnerabilityData,
) -> None:
    """Check if external references contain all expected data."""
    assert external_refs is not None  # noqa: S101

    nvd_refs = [ref for ref in external_refs if ref.get("source_name") == "nvd"]
    assert len(nvd_refs) == 1  # noqa: S101
    assert nvd_refs[0]["external_id"] == gti_vulnerability.id  # noqa: S101

    if gti_vulnerability.attributes.link:
        url_refs = [ref for ref in external_refs if ref.get("source_name") == "url"]
        assert len(url_refs) == 1  # noqa: S101
        assert url_refs[0]["url"] == gti_vulnerability.attributes.link  # noqa: S101

    if (
        gti_vulnerability.attributes.cvss
        and gti_vulnerability.attributes.cvss.cvssv3
        and gti_vulnerability.attributes.cvss.cvssv3.vector_string
    ):
        cvss_refs = [
            ref for ref in external_refs if ref.get("source_name") == "cvss-v3"
        ]
        assert len(cvss_refs) == 1  # noqa: S101
        assert (  # noqa: S101
            cvss_refs[0]["description"]
            == gti_vulnerability.attributes.cvss.cvssv3.vector_string
        )


# Then external references contain NVD only
def _then_external_references_contain_nvd_only(
    external_refs: Optional[List[Dict[str, str]]],
    gti_vulnerability: GTIVulnerabilityData,
) -> None:
    """Check if external references contain only NVD reference."""
    assert external_refs is not None  # noqa: S101
    assert len(external_refs) == 1  # noqa: S101

    nvd_ref = external_refs[0]
    assert nvd_ref["source_name"] == "nvd"  # noqa: S101
    assert nvd_ref["external_id"] == gti_vulnerability.id  # noqa: S101
    assert (  # noqa: S101
        nvd_ref["url"] == f"https://nvd.nist.gov/vuln/detail/{gti_vulnerability.id}"
    )


# Then STIX vulnerability handles None values
def _then_stix_vulnerability_handles_none_values(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability handles None values gracefully."""
    assert stix_vulnerability is not None  # noqa: S101
    assert stix_vulnerability.name == ""  # noqa: S101
    if gti_vulnerability.attributes.description is None:
        assert stix_vulnerability.description is None  # noqa: S101


# Then STIX vulnerability handles invalid timestamps
def _then_stix_vulnerability_handles_invalid_timestamps(
    stix_vulnerability: Any,
) -> None:
    """Check if STIX vulnerability handles invalid timestamps."""
    assert stix_vulnerability is not None  # noqa: S101
    assert isinstance(stix_vulnerability.created, datetime)  # noqa: S101
    assert isinstance(stix_vulnerability.modified, datetime)  # noqa: S101


# Then STIX vulnerability handles invalid CVSS
def _then_stix_vulnerability_handles_invalid_cvss(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability handles invalid CVSS data."""
    assert stix_vulnerability is not None  # noqa: S101
    if gti_vulnerability.attributes.cvss and gti_vulnerability.attributes.cvss.cvssv3:
        cvss = gti_vulnerability.attributes.cvss.cvssv3
        if cvss.base_score is not None:
            custom_props = getattr(stix_vulnerability, "custom_properties", {})
            assert "x_opencti_base_score" in custom_props  # noqa: S101
            assert custom_props["x_opencti_base_score"] == cvss.base_score  # noqa: S101


# Then STIX vulnerability handles invalid EPSS
def _then_stix_vulnerability_handles_invalid_epss(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability handles invalid EPSS data."""
    assert stix_vulnerability is not None  # noqa: S101
    epss = gti_vulnerability.attributes.epss
    if epss:
        custom_props = getattr(stix_vulnerability, "custom_properties", {})
        if epss.score is not None:
            assert "x_opencti_epss_score" in custom_props  # noqa: S101
            assert custom_props["x_opencti_epss_score"] == epss.score  # noqa: S101
        if epss.percentile is not None:
            assert "x_opencti_epss_percentile" in custom_props  # noqa: S101
            assert (  # noqa: S101
                custom_props["x_opencti_epss_percentile"] == epss.percentile
            )


# Then STIX vulnerability includes malformed URL
def _then_stix_vulnerability_includes_malformed_url(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability includes malformed URL as-is."""
    assert stix_vulnerability is not None  # noqa: S101
    if stix_vulnerability.external_references:
        url_refs = [
            ref
            for ref in stix_vulnerability.external_references
            if ref.source_name == "url"
        ]
        if url_refs:
            assert url_refs[0].url == gti_vulnerability.attributes.link  # noqa: S101


# Then STIX vulnerability preserves long strings
def _then_stix_vulnerability_preserves_long_strings(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability preserves long strings."""
    assert stix_vulnerability is not None  # noqa: S101
    assert stix_vulnerability.name == gti_vulnerability.attributes.name  # noqa: S101
    assert (  # noqa: S101
        stix_vulnerability.description == gti_vulnerability.attributes.description
    )


# Then STIX vulnerability preserves unicode
def _then_stix_vulnerability_preserves_unicode(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability preserves unicode characters."""
    assert stix_vulnerability is not None  # noqa: S101
    assert stix_vulnerability.name == gti_vulnerability.attributes.name  # noqa: S101
    assert (  # noqa: S101
        stix_vulnerability.description == gti_vulnerability.attributes.description
    )

    if stix_vulnerability.external_references:
        url_refs = [
            ref
            for ref in stix_vulnerability.external_references
            if ref.source_name == "url"
        ]
        if url_refs:
            assert url_refs[0].url == gti_vulnerability.attributes.link  # noqa: S101


# Then STIX vulnerability handles empty CVE ID
def _then_stix_vulnerability_handles_empty_cve_id(stix_vulnerability: Any) -> None:
    """Check if STIX vulnerability handles empty CVE ID."""
    assert stix_vulnerability is not None  # noqa: S101
    if stix_vulnerability.external_references:
        nvd_refs = [
            ref
            for ref in stix_vulnerability.external_references
            if ref.source_name == "nvd"
        ]
        if nvd_refs:
            assert hasattr(nvd_refs[0], "external_id")  # noqa: S101


# Then STIX vulnerability handles partial CVSS
def _then_stix_vulnerability_handles_partial_cvss(
    stix_vulnerability: Any, gti_vulnerability: GTIVulnerabilityData
) -> None:
    """Check if STIX vulnerability handles partial CVSS data."""
    assert stix_vulnerability is not None  # noqa: S101
    cvss = gti_vulnerability.attributes.cvss.cvssv3

    if cvss.base_score is not None:
        custom_props = getattr(stix_vulnerability, "custom_properties", {})
        assert "x_opencti_base_score" in custom_props  # noqa: S101
        assert custom_props["x_opencti_base_score"] == cvss.base_score  # noqa: S101

    if stix_vulnerability.labels:
        if cvss.attack_vector:
            assert (  # noqa: S101
                f"attack-vector:{cvss.attack_vector}" in stix_vulnerability.labels
            )
        if not cvss.attack_complexity:
            complexity_labels = [
                label
                for label in stix_vulnerability.labels
                if "attack-complexity:" in label
            ]
            assert len(complexity_labels) == 0  # noqa: S101


# Then STIX vulnerability handles missing cvssv3
def _then_stix_vulnerability_handles_missing_cvssv3(stix_vulnerability: Any) -> None:
    """Check if STIX vulnerability handles missing cvssv3 data."""
    assert stix_vulnerability is not None  # noqa: S101
    custom_props = getattr(stix_vulnerability, "custom_properties", {})
    assert (  # noqa: S101
        "x_opencti_base_score" not in custom_props
        or custom_props.get("x_opencti_base_score") is None
    )
    if stix_vulnerability.labels:
        cvss_labels = [
            label
            for label in stix_vulnerability.labels
            if any(
                prefix in label
                for prefix in [
                    "attack-vector:",
                    "attack-complexity:",
                    "privileges-required:",
                    "user-interaction:",
                ]
            )
        ]
        assert len(cvss_labels) == 0  # noqa: S101
