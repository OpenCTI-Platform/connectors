"""Test module for GenericFetcherConfig functionality."""

from typing import Any, Dict, Optional, Tuple

import pytest
from connector.src.utils.fetchers.generic_fetcher_config import GenericFetcherConfig
from pydantic import BaseModel

# =====================
# Test Models
# =====================


class UserTestModel(BaseModel):
    """Test model for fetcher testing."""

    id: str
    name: str
    description: str


class CustomError(Exception):
    """Custom exception for testing."""

    def __init__(self, message: str, endpoint: Optional[str] = None):
        """Initialize CustomError."""
        super().__init__(message)
        self.endpoint = endpoint


class SimpleError(Exception):
    """Simple exception for testing."""

    pass


# =====================
# Fixtures
# =====================


@pytest.fixture
def basic_config() -> GenericFetcherConfig:
    """Fixture for basic configuration."""
    return GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{user_id}",
        display_name="users",
        exception_class=CustomError,
    )


@pytest.fixture
def save_to_file_config() -> GenericFetcherConfig:
    """Fixture for configuration with save_to_file enabled."""
    return GenericFetcherConfig(
        entity_type="products",
        endpoint="/api/products/{id}",
        display_name="products",
        exception_class=SimpleError,
        save_to_file=True,
    )


@pytest.fixture
def full_config() -> GenericFetcherConfig:
    """Fixture for configuration with all options."""
    return GenericFetcherConfig(
        entity_type="products",
        endpoint="/api/products/{product_id}",
        display_name="products",
        exception_class=CustomError,
        response_model=UserTestModel,
        display_name_singular="product",
        method="POST",
        headers={"Content-Type": "application/json"},
        timeout=30.0,
        response_key="data",
    )


@pytest.fixture
def config_with_plural_display_name() -> GenericFetcherConfig:
    """Fixture for configuration with plural display name."""
    return GenericFetcherConfig(
        entity_type="categories",
        endpoint="/api/categories/{id}",
        display_name="categories",
        exception_class=SimpleError,
    )


@pytest.fixture
def config_with_non_plural_display_name() -> GenericFetcherConfig:
    """Fixture for configuration with non-plural display name."""
    return GenericFetcherConfig(
        entity_type="data",
        endpoint="/api/data/{id}",
        display_name="data",
        exception_class=SimpleError,
    )


# =====================
# Test Cases
# =====================

# Scenario: Creating basic configuration with required parameters


def test_basic_config_creation_with_required_parameters(
    basic_config: GenericFetcherConfig,
) -> None:
    """Test creating configuration with only required parameters."""
    # Given: A basic configuration is created with required parameters
    config = basic_config

    # When: The configuration is inspected
    # Then: All required parameters should be set correctly
    _then_config_has_basic_properties(config)


def test_basic_config_sets_default_values(basic_config: GenericFetcherConfig) -> None:
    """Test that basic configuration sets appropriate default values."""
    # Given: A basic configuration is created
    config = basic_config

    # When: Default values are inspected
    # Then: Defaults should be set correctly
    _then_config_has_default_values(config)


# Scenario: Creating full configuration with all parameters


def test_full_config_creation_with_all_parameters(
    full_config: GenericFetcherConfig,
) -> None:
    """Test creating configuration with all parameters specified."""
    # Given: A full configuration is created with all parameters
    config = full_config

    # When: The configuration is inspected
    # Then: All parameters should be set correctly
    _then_config_has_full_properties(config)


# Scenario: Auto-generation of singular display names


def test_display_name_singular_auto_generated_from_plural(
    config_with_plural_display_name: GenericFetcherConfig,
) -> None:
    """Test automatic generation of singular form from plural display name."""
    # Given: A configuration with a plural display name ending in 's'
    config = config_with_plural_display_name

    # When: The singular display name is inspected
    # Then: It should be automatically generated by removing the 's'
    _then_singular_name_is_auto_generated(config, expected="categorie")


def test_display_name_singular_unchanged_for_non_plural(
    config_with_non_plural_display_name: GenericFetcherConfig,
) -> None:
    """Test that non-plural display names remain unchanged."""
    # Given: A configuration with a non-plural display name
    config = config_with_non_plural_display_name

    # When: The singular display name is inspected
    # Then: It should remain the same as the original display name
    _then_singular_name_unchanged(config, expected="data")


def test_explicit_singular_name_overrides_auto_generation() -> None:
    """Test that explicitly set singular name overrides auto-generation."""
    # Given: A configuration with explicit singular name
    config = GenericFetcherConfig(
        entity_type="people",
        endpoint="/api/people/{id}",
        display_name="people",
        display_name_singular="person",
        exception_class=SimpleError,
    )

    # When: The singular display name is inspected
    # Then: It should use the explicitly set value
    _then_singular_name_is_explicit(config, expected="person")


# Scenario: Endpoint formatting with parameters


def test_format_endpoint_with_single_parameter() -> None:
    """Test formatting endpoint with a single parameter."""
    # Given: A configuration with a parameterized endpoint
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{user_id}",
        display_name="users",
        exception_class=SimpleError,
    )

    # When: The endpoint is formatted with parameters
    formatted_endpoint, exception = _when_endpoint_formatted(config, user_id="123")

    # Then: The endpoint should be correctly formatted
    assert formatted_endpoint is not None  # noqa: S101
    _then_endpoint_formatted_successfully(formatted_endpoint, "/api/users/123")


def test_format_endpoint_with_multiple_parameters() -> None:
    """Test formatting endpoint with multiple parameters."""
    # Given: A configuration with a multi-parameter endpoint
    config = GenericFetcherConfig(
        entity_type="orders",
        endpoint="/api/users/{user_id}/orders/{order_id}",
        display_name="orders",
        exception_class=SimpleError,
    )

    # When: The endpoint is formatted with multiple parameters
    formatted_endpoint, exception = _when_endpoint_formatted(
        config, user_id="123", order_id="ord-456"
    )

    # Then: The endpoint should be correctly formatted
    assert formatted_endpoint is not None  # noqa: S101
    _then_endpoint_formatted_successfully(
        formatted_endpoint, "/api/users/123/orders/ord-456"
    )


def test_format_endpoint_with_missing_parameter() -> None:
    """Test formatting endpoint with missing required parameter."""
    # Given: A configuration with a parameterized endpoint
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{user_id}",
        display_name="users",
        exception_class=SimpleError,
    )

    # When: The endpoint is formatted without required parameters
    formatted_endpoint, exception = _when_endpoint_formatted(config)

    # Then: A ValueError should be raised with appropriate message
    assert exception is not None  # noqa: S101
    _then_endpoint_formatting_failed(exception, expected_param="user_id")


def test_format_endpoint_without_parameters() -> None:
    """Test formatting endpoint that doesn't require parameters."""
    # Given: A configuration with a static endpoint
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users",
        display_name="users",
        exception_class=SimpleError,
    )

    # When: The endpoint is formatted without parameters
    formatted_endpoint, exception = _when_endpoint_formatted(config)

    # Then: The endpoint should remain unchanged
    assert formatted_endpoint is not None  # noqa: S101
    _then_endpoint_formatted_successfully(formatted_endpoint, "/api/users")


# Scenario: Exception creation with different constructors


def test_create_exception_with_endpoint_parameter() -> None:
    """Test creating exception with endpoint parameter."""
    # Given: A configuration with an exception class that accepts endpoint parameter
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{id}",
        display_name="users",
        exception_class=CustomError,
    )

    # When: An exception is created with endpoint parameter
    exception = _when_exception_created(config, "Test error", endpoint="/api/users/123")

    # Then: The exception should be created with the endpoint parameter
    _then_exception_created_with_endpoint(exception, "Test error", "/api/users/123")


def test_create_exception_with_simple_constructor() -> None:
    """Test creating exception with simple message-only constructor."""
    # Given: A configuration with a simple exception class
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{id}",
        display_name="users",
        exception_class=SimpleError,
    )

    # When: An exception is created with additional parameters
    exception = _when_exception_created(config, "Test error", endpoint="/api/users/123")

    # Then: The exception should fall back to message-only constructor
    _then_exception_created_simple(exception, "Test error")


# Scenario: Headers merging and initialization


def test_headers_initialization_with_none() -> None:
    """Test that None headers are initialized to empty dict."""
    # Given: A configuration created without headers
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users",
        display_name="users",
        exception_class=SimpleError,
        headers=None,
    )

    # When: The headers are inspected
    # Then: Headers should be an empty dictionary
    _then_headers_are_empty_dict(config)


def test_headers_initialization_with_values() -> None:
    """Test that provided headers are preserved."""
    # Given: A configuration created with headers
    expected_headers = {
        "Authorization": "Bearer token",
        "Content-Type": "application/json",
    }
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users",
        display_name="users",
        exception_class=SimpleError,
        headers=expected_headers,
    )

    # When: The headers are inspected
    # Then: Headers should match the provided values
    _then_headers_match(config, expected_headers)


# =====================
# GWT Helper Functions
# =====================

# --- GIVEN: Setup conditions (covered by fixtures) ---

# --- WHEN: Execute the system under test ---


def _when_endpoint_formatted(
    config: GenericFetcherConfig, **kwargs: Any
) -> Tuple[Optional[str], Optional[Exception]]:
    """Format the endpoint with provided parameters."""
    try:
        return config.format_endpoint(**kwargs), None
    except Exception as e:
        return None, e


def _when_exception_created(
    config: GenericFetcherConfig, message: str, **kwargs: Any
) -> Exception:
    """Create an exception using the config's exception factory."""
    return config.create_exception(message, **kwargs)


# --- THEN: Verify the expected outcomes ---


def _then_config_has_basic_properties(config: GenericFetcherConfig) -> None:
    """Assert that basic configuration properties are set correctly."""
    assert config.entity_type == "users"  # noqa: S101
    assert config.endpoint == "/api/users/{user_id}"  # noqa: S101
    assert config.display_name == "users"  # noqa: S101
    assert config.exception_class == CustomError  # noqa: S101


def _then_config_has_default_values(config: GenericFetcherConfig) -> None:
    """Assert that default values are set correctly."""
    assert config.response_model is None  # noqa: S101
    assert config.display_name_singular == "user"  # noqa: S101
    assert config.method == "GET"  # noqa: S101
    assert config.headers == {}  # noqa: S101
    assert config.timeout == 60.0  # noqa: S101
    assert config.response_key is None  # noqa: S101


def _then_config_has_full_properties(config: GenericFetcherConfig) -> None:
    """Assert that full configuration properties are set correctly."""
    assert config.entity_type == "products"  # noqa: S101
    assert config.endpoint == "/api/products/{product_id}"  # noqa: S101
    assert config.display_name == "products"  # noqa: S101
    assert config.exception_class == CustomError  # noqa: S101
    assert config.response_model == UserTestModel  # noqa: S101
    assert config.display_name_singular == "product"  # noqa: S101
    assert config.method == "POST"  # noqa: S101
    assert config.headers == {"Content-Type": "application/json"}  # noqa: S101
    assert config.timeout == 30.0  # noqa: S101
    assert config.response_key == "data"  # noqa: S101


def _then_singular_name_is_auto_generated(
    config: GenericFetcherConfig, expected: str
) -> None:
    """Assert that singular name was auto-generated correctly."""
    assert config.display_name_singular == expected  # noqa: S101


def _then_singular_name_unchanged(config: GenericFetcherConfig, expected: str) -> None:
    """Assert that singular name remained unchanged."""
    assert config.display_name_singular == expected  # noqa: S101


def _then_singular_name_is_explicit(
    config: GenericFetcherConfig, expected: str
) -> None:
    """Assert that explicit singular name was used."""
    assert config.display_name_singular == expected  # noqa: S101


def _then_endpoint_formatted_successfully(
    formatted_endpoint: str, expected: str
) -> None:
    """Assert that endpoint was formatted successfully."""
    assert formatted_endpoint == expected  # noqa: S101


def _then_endpoint_formatting_failed(exception: Exception, expected_param: str) -> None:
    """Assert that endpoint formatting failed with expected parameter."""
    assert exception is not None  # noqa: S101
    assert isinstance(exception, ValueError)  # noqa: S101
    assert expected_param in str(exception)  # noqa: S101


def _then_exception_created_with_endpoint(
    exception: Exception, expected_message: str, expected_endpoint: str
) -> None:
    """Assert that exception was created with endpoint parameter."""
    assert isinstance(exception, CustomError)  # noqa: S101
    assert str(exception) == expected_message  # noqa: S101
    assert exception.endpoint == expected_endpoint  # noqa: S101


def _then_exception_created_simple(exception: Exception, expected_message: str) -> None:
    """Assert that exception was created with simple constructor."""
    assert isinstance(exception, SimpleError)  # noqa: S101
    assert str(exception) == expected_message  # noqa: S101


def _then_headers_are_empty_dict(config: GenericFetcherConfig) -> None:
    """Assert that headers are an empty dictionary."""
    assert config.headers == {}  # noqa: S101


def _then_headers_match(
    config: GenericFetcherConfig, expected_headers: Dict[str, str]
) -> None:
    """Assert that headers match expected values."""
    assert config.headers == expected_headers  # noqa: S101


# =====================
# Save to File Tests
# =====================


def test_save_to_file_defaults_to_false(basic_config: GenericFetcherConfig) -> None:
    """Test that save_to_file defaults to False."""
    # Given: A basic configuration is created
    config = basic_config

    # When: The save_to_file property is inspected
    # Then: It should default to False
    assert config.save_to_file is False  # noqa: S101


def test_save_to_file_can_be_enabled(save_to_file_config: GenericFetcherConfig) -> None:
    """Test that save_to_file can be explicitly enabled."""
    # Given: A configuration with save_to_file enabled
    config = save_to_file_config

    # When: The save_to_file property is inspected
    # Then: It should be True
    assert config.save_to_file is True  # noqa: S101


def test_save_to_file_explicit_false() -> None:
    """Test that save_to_file can be explicitly set to False."""
    # Given: A configuration with save_to_file explicitly disabled
    config = GenericFetcherConfig(
        entity_type="users",
        endpoint="/api/users/{id}",
        display_name="users",
        exception_class=SimpleError,
        save_to_file=False,
    )

    # When: The save_to_file property is inspected
    # Then: It should be False
    assert config.save_to_file is False  # noqa: S101


def test_save_to_file_with_other_options() -> None:
    """Test that save_to_file works correctly with other configuration options."""
    # Given: A configuration with save_to_file and other options
    config = GenericFetcherConfig(
        entity_type="products",
        endpoint="/api/products/{id}",
        display_name="products",
        exception_class=SimpleError,
        response_model=UserTestModel,
        timeout=30.0,
        method="POST",
        save_to_file=True,
        headers={"Authorization": "Bearer token"},
    )

    # When: The configuration is inspected
    # Then: All options should be set correctly including save_to_file
    assert config.save_to_file is True  # noqa: S101
    assert config.response_model == UserTestModel  # noqa: S101
    assert config.timeout == 30.0  # noqa: S101
    assert config.method == "POST"  # noqa: S101
    assert (  # noqa: S101
        config.headers is not None and config.headers["Authorization"] == "Bearer token"
    )
